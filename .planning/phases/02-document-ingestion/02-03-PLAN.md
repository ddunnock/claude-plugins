---
phase: 02-document-ingestion
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - mcps/knowledge-mcp/src/knowledge_mcp/chunk/base.py
  - mcps/knowledge-mcp/src/knowledge_mcp/chunk/hierarchical.py
  - mcps/knowledge-mcp/src/knowledge_mcp/chunk/__init__.py
  - mcps/knowledge-mcp/tests/unit/test_chunk/test_hierarchical.py
autonomous: true

must_haves:
  truths:
    - "Chunks respect document structure boundaries (clauses, paragraphs)"
    - "Chunks stay within 500 token target with 1000 token max"
    - "Adjacent chunks have 20% overlap for context continuity"
    - "Tables are never split mid-row"
  artifacts:
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/chunk/base.py"
      provides: "Base chunker interface"
      exports: ["BaseChunker", "ChunkConfig"]
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/chunk/hierarchical.py"
      provides: "Hierarchical chunker wrapping Docling HybridChunker"
      exports: ["HierarchicalChunker"]
  key_links:
    - from: "hierarchical.py"
      to: "docling_core.transforms.chunker"
      via: "HybridChunker"
      pattern: "HybridChunker"
    - from: "hierarchical.py"
      to: "utils/tokenizer.py"
      via: "count_tokens for verification"
      pattern: "count_tokens"
---

<objective>
Create the hierarchical chunker that uses Docling's HybridChunker to split documents while respecting clause boundaries, token limits, and table integrity.

Purpose: Chunking is the critical step that preserves or destroys semantic coherence. The hierarchical chunker ensures chunks stay within embedding limits while maintaining document structure and adding overlap for context continuity.

Output: Base chunker interface, HierarchicalChunker using Docling, with table-aware splitting and overlap handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-document-ingestion/02-CONTEXT.md
@.planning/phases/02-document-ingestion/02-RESEARCH.md
@.planning/phases/02-document-ingestion/02-01-SUMMARY.md
@mcps/knowledge-mcp/src/knowledge_mcp/utils/tokenizer.py
@mcps/knowledge-mcp/src/knowledge_mcp/models/chunk.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base chunker interface and configuration</name>
  <files>
    mcps/knowledge-mcp/src/knowledge_mcp/chunk/base.py
  </files>
  <action>
Create `chunk/base.py` with:

1. `ChunkConfig` dataclass:
   - target_tokens: int = 500 (target chunk size)
   - max_tokens: int = 1000 (hard limit, split if exceeded)
   - overlap_tokens: int = 100 (20% overlap between adjacent chunks)
   - model: str = "text-embedding-3-small" (for token counting)
   - merge_small_chunks: bool = True (merge chunks under 100 tokens with peers)

2. `ChunkResult` dataclass:
   - content: str
   - token_count: int
   - section_hierarchy: list[str]
   - clause_number: str | None
   - page_numbers: list[int]
   - chunk_type: str ("text", "table", "list", "figure")
   - has_overlap: bool (True if chunk starts with overlap from previous)
   - metadata: dict[str, Any] (for additional context like table caption)

3. `BaseChunker` abstract class:
   - `__init__(self, config: ChunkConfig | None = None)`
   - `chunk(elements: list[ParsedElement], metadata: DocumentMetadata) -> list[ChunkResult]` abstract method
   - `_count_tokens(text: str) -> int` helper using tokenizer utility

Follow existing patterns (dataclass, abstract base class, Google docstrings).
  </action>
  <verify>
`poetry run pyright mcps/knowledge-mcp/src/knowledge_mcp/chunk/base.py` reports zero errors.
`poetry run python -c "from knowledge_mcp.chunk.base import BaseChunker, ChunkConfig, ChunkResult; print('OK')"` succeeds.
  </verify>
  <done>Base chunker interface with ChunkConfig (500 token target, 100 token overlap) and ChunkResult model.</done>
</task>

<task type="auto">
  <name>Task 2: Implement HierarchicalChunker with Docling HybridChunker</name>
  <files>
    mcps/knowledge-mcp/src/knowledge_mcp/chunk/hierarchical.py
    mcps/knowledge-mcp/src/knowledge_mcp/chunk/__init__.py
  </files>
  <action>
Create `chunk/hierarchical.py` with `HierarchicalChunker(BaseChunker)`:

1. `__init__(self, config: ChunkConfig | None = None)`:
   - Store config
   - Initialize tiktoken encoding for token counting
   - Prepare Docling HybridChunker with config.max_tokens and merge_peers=config.merge_small_chunks

2. `chunk(elements: list[ParsedElement], metadata: DocumentMetadata) -> list[ChunkResult]`:
   - Group elements by section to maintain hierarchy
   - For text elements: use Docling HybridChunker
   - For tables: call `_chunk_table()` method
   - Add overlap between adjacent chunks via `_add_overlap()`
   - Return list of ChunkResult with all metadata preserved

3. `_chunk_table(element: ParsedElement) -> list[ChunkResult]`:
   - If table fits in max_tokens: single chunk
   - If too large: split by rows, preserve header row in each chunk
   - Include table caption in each chunk
   - Mark chunk_type as "table"

4. `_add_overlap(chunks: list[ChunkResult]) -> list[ChunkResult]`:
   - For each chunk after the first:
   - Take last overlap_tokens from previous chunk's content
   - Prepend with separator "---\n\n"
   - Set has_overlap=True

5. `_extract_clause_number(hierarchy: list[str], heading: str) -> str | None`:
   - Extract clause number from section hierarchy or heading text
   - Use regex pattern from RESEARCH.md: `\b(\d+(?:\.\d+){0,4})\b`

Update `chunk/__init__.py` to export HierarchicalChunker, ChunkConfig, ChunkResult.
  </action>
  <verify>
`poetry run pyright mcps/knowledge-mcp/src/knowledge_mcp/chunk/hierarchical.py` reports zero errors.
`poetry run python -c "from knowledge_mcp.chunk import HierarchicalChunker, ChunkConfig; print('OK')"` succeeds.
  </verify>
  <done>HierarchicalChunker splits documents with clause boundaries, table integrity, and 20% overlap.</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for hierarchical chunker</name>
  <files>
    mcps/knowledge-mcp/tests/unit/test_chunk/__init__.py
    mcps/knowledge-mcp/tests/unit/test_chunk/test_hierarchical.py
  </files>
  <action>
Create test directory structure and `test_hierarchical.py` with tests:

1. Test chunk config defaults (500 target, 1000 max, 100 overlap)
2. Test simple text chunking stays within token limits
3. Test oversized text is split correctly
4. Test table under limit produces single chunk
5. Test large table is split by rows with headers preserved
6. Test overlap is added between adjacent chunks
7. Test section_hierarchy is preserved in chunk results
8. Test clause_number extraction from headings

Mock Docling HybridChunker to avoid external dependencies in unit tests:
- Create fixtures with sample ParsedElement lists
- Verify chunker produces correct ChunkResult structure
- Test edge cases: empty elements, single element, very large element

Follow pytest patterns from existing tests.
  </action>
  <verify>
`poetry run pytest mcps/knowledge-mcp/tests/unit/test_chunk/ -v` passes all tests.
  </verify>
  <done>Hierarchical chunker has comprehensive unit tests for token limits, overlap, and table handling.</done>
</task>

</tasks>

<verification>
Overall plan verification:
```bash
cd mcps/knowledge-mcp
poetry run pytest tests/unit/test_chunk/ -v
poetry run pyright src/knowledge_mcp/chunk/
poetry run python -c "
from knowledge_mcp.chunk import HierarchicalChunker, ChunkConfig, ChunkResult
from knowledge_mcp.chunk.base import BaseChunker
print('All imports OK')
"
```
</verification>

<success_criteria>
1. ChunkConfig defaults: 500 token target, 1000 max, 100 overlap (20%)
2. HierarchicalChunker uses Docling HybridChunker for structure-aware splitting
3. Tables are chunked by rows with headers preserved (never mid-row split)
4. Adjacent chunks have 20% overlap for context continuity
5. Section hierarchy and clause numbers preserved in ChunkResult
6. All code passes pyright strict mode
7. Unit tests cover normal and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-document-ingestion/02-03-SUMMARY.md`
</output>
