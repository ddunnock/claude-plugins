---
phase: 02-document-ingestion
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - mcps/knowledge-mcp/src/knowledge_mcp/ingest/base.py
  - mcps/knowledge-mcp/src/knowledge_mcp/ingest/pdf_ingestor.py
  - mcps/knowledge-mcp/src/knowledge_mcp/ingest/__init__.py
  - mcps/knowledge-mcp/src/knowledge_mcp/models/document.py
  - mcps/knowledge-mcp/tests/unit/test_ingest/test_pdf_ingestor.py
autonomous: true

must_haves:
  truths:
    - "PDFs are parsed with clause hierarchy preserved in output"
    - "Tables are extracted as structured data (not flattened text)"
    - "Page numbers are tracked for each parsed element"
  artifacts:
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/ingest/base.py"
      provides: "Base ingestor interface"
      exports: ["BaseIngestor", "ParsedDocument", "ParsedElement"]
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/ingest/pdf_ingestor.py"
      provides: "Docling-based PDF parser"
      exports: ["PDFIngestor"]
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/models/document.py"
      provides: "Document metadata model"
      exports: ["DocumentMetadata"]
  key_links:
    - from: "pdf_ingestor.py"
      to: "docling.document_converter"
      via: "DocumentConverter.convert()"
      pattern: "DocumentConverter"
    - from: "pdf_ingestor.py"
      to: "base.py"
      via: "implements BaseIngestor"
      pattern: "class PDFIngestor.*BaseIngestor"
---

<objective>
Create the base ingestor interface and Docling-based PDF ingestor that preserves clause hierarchy, extracts tables as structured data, and tracks page numbers.

Purpose: PDFs are the primary format for engineering standards. The ingestor converts them to structured ParsedDocument objects that the chunker can process while preserving all metadata needed for citations.

Output: Base ingestor interface, PDF ingestor using Docling, DocumentMetadata model, unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-document-ingestion/02-CONTEXT.md
@.planning/phases/02-document-ingestion/02-RESEARCH.md
@.planning/phases/02-document-ingestion/02-01-SUMMARY.md
@mcps/knowledge-mcp/src/knowledge_mcp/models/chunk.py
@mcps/knowledge-mcp/src/knowledge_mcp/utils/tokenizer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DocumentMetadata model and base ingestor interface</name>
  <files>
    mcps/knowledge-mcp/src/knowledge_mcp/models/document.py
    mcps/knowledge-mcp/src/knowledge_mcp/ingest/base.py
  </files>
  <action>
Create `models/document.py` with:
- `DocumentMetadata` dataclass with fields:
  - document_id: str (e.g., "ieee-15288-2014")
  - title: str (e.g., "IEEE 15288.2-2014")
  - document_type: str ("standard", "handbook", "guide")
  - source_path: str (original file path per NFR-4.4)
  - version: str | None
  - publication_date: str | None
  - standard_id: str | None (e.g., "IEEE 15288")

Create `ingest/base.py` with:
- `ParsedElement` dataclass:
  - element_type: str ("heading", "paragraph", "table", "list", "figure")
  - content: str (text content or markdown representation)
  - page_number: int | None
  - section_hierarchy: list[str] (e.g., ["4", "4.2", "4.2.3"])
  - heading_level: int | None (for headings only)
  - table_data: list[list[str]] | None (for tables: rows of cells)
  - caption: str | None

- `ParsedDocument` dataclass:
  - metadata: DocumentMetadata
  - elements: list[ParsedElement]

- `BaseIngestor` abstract class:
  - `ingest(file_path: Path) -> ParsedDocument` abstract method
  - `supported_extensions() -> list[str]` class method

Follow existing code patterns (dataclass, __future__ annotations, Google docstrings).
  </action>
  <verify>
`poetry run pyright mcps/knowledge-mcp/src/knowledge_mcp/models/document.py mcps/knowledge-mcp/src/knowledge_mcp/ingest/base.py` reports zero errors.
`poetry run python -c "from knowledge_mcp.ingest.base import BaseIngestor, ParsedDocument; from knowledge_mcp.models.document import DocumentMetadata; print('OK')"` succeeds.
  </verify>
  <done>Base ingestor interface defined with ParsedElement, ParsedDocument, and DocumentMetadata models.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Docling-based PDF ingestor</name>
  <files>
    mcps/knowledge-mcp/src/knowledge_mcp/ingest/pdf_ingestor.py
    mcps/knowledge-mcp/src/knowledge_mcp/ingest/__init__.py
  </files>
  <action>
Create `ingest/pdf_ingestor.py` with `PDFIngestor(BaseIngestor)`:

1. `__init__(self)` - Initialize DocumentConverter from Docling
2. `ingest(file_path: Path) -> ParsedDocument`:
   - Convert PDF using `converter.convert(str(file_path))`
   - Extract DocumentMetadata from document properties and filename
   - Iterate through `doc.iterate_items()` to build ParsedElement list
   - For each element:
     - Detect element_type from Docling's label (DocItemLabel)
     - Extract page_number from element's prov (provenance) info
     - Build section_hierarchy from heading nesting
     - For tables: use `table.export_to_dataframe().values.tolist()` for table_data
     - Extract captions for figures and tables

3. `supported_extensions() -> list[str]` returns [".pdf"]

Handle errors:
- Raise `IngestionError` (from exceptions.py) on parse failures
- Log warnings for elements that can't be parsed

Update `ingest/__init__.py` to export PDFIngestor.

Reference Docling patterns from RESEARCH.md code examples.
  </action>
  <verify>
`poetry run pyright mcps/knowledge-mcp/src/knowledge_mcp/ingest/pdf_ingestor.py` reports zero errors.
`poetry run python -c "from knowledge_mcp.ingest import PDFIngestor; print('OK')"` succeeds.
  </verify>
  <done>PDFIngestor converts PDFs to ParsedDocument with clause hierarchy, tables, and page numbers.</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for PDF ingestor</name>
  <files>
    mcps/knowledge-mcp/tests/unit/test_ingest/__init__.py
    mcps/knowledge-mcp/tests/unit/test_ingest/test_pdf_ingestor.py
  </files>
  <action>
Create test directory structure:
```
tests/unit/test_ingest/
  __init__.py
  test_pdf_ingestor.py
```

Create `test_pdf_ingestor.py` with tests:
1. Test `supported_extensions()` returns [".pdf"]
2. Test that ingest returns ParsedDocument with correct metadata structure
3. Test that file not found raises IngestionError
4. Test that section_hierarchy is populated for elements

Mock Docling's DocumentConverter to avoid actual PDF parsing in unit tests:
- Mock `converter.convert()` to return a fake DoclingDocument
- Mock document iteration to return controlled elements
- Verify the ingestor correctly transforms Docling output to ParsedDocument

Use pytest fixtures for mock setup, following patterns in existing tests (e.g., tests/unit/test_store/).
  </action>
  <verify>
`poetry run pytest mcps/knowledge-mcp/tests/unit/test_ingest/ -v` passes all tests.
  </verify>
  <done>PDF ingestor has unit tests covering normal operation and error cases.</done>
</task>

</tasks>

<verification>
Overall plan verification:
```bash
cd mcps/knowledge-mcp
poetry run pytest tests/unit/test_ingest/ -v
poetry run pyright src/knowledge_mcp/ingest/ src/knowledge_mcp/models/document.py
poetry run python -c "
from knowledge_mcp.ingest import PDFIngestor
from knowledge_mcp.ingest.base import ParsedDocument, ParsedElement
from knowledge_mcp.models.document import DocumentMetadata
print('All imports OK')
"
```
</verification>

<success_criteria>
1. PDFIngestor uses Docling DocumentConverter for PDF parsing
2. ParsedDocument contains list of ParsedElements with element_type, content, page_number
3. Section hierarchy is tracked as list of strings (e.g., ["4", "4.2"])
4. Tables are extracted with table_data as list[list[str]]
5. DocumentMetadata includes source_path per NFR-4.4
6. All code passes pyright strict mode
7. Unit tests pass with mocked Docling
</success_criteria>

<output>
After completion, create `.planning/phases/02-document-ingestion/02-02-SUMMARY.md`
</output>
