---
phase: 01-migration
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - mcps/knowledge-mcp/src/knowledge_mcp/utils/config.py
  - mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py
  - mcps/knowledge-mcp/src/knowledge_mcp/store/chromadb_store.py
  - mcps/knowledge-mcp/tests/unit/test_config.py
  - mcps/knowledge-mcp/tests/unit/test_qdrant_store.py
  - mcps/knowledge-mcp/tests/unit/test_chromadb_store.py
autonomous: true

must_haves:
  truths:
    - "Collection names include embedding model version"
    - "Embedding model is stored in chunk metadata in vector stores"
    - "Model mismatch is detected before ingestion"
  artifacts:
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/utils/config.py"
      provides: "Versioned collection name property"
      contains: "versioned_collection_name"
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py"
      provides: "Embedding model metadata storage and validation"
      contains: "embedding_model"
    - path: "mcps/knowledge-mcp/src/knowledge_mcp/store/chromadb_store.py"
      provides: "Embedding model metadata storage and validation"
      contains: "embedding_model"
  key_links:
    - from: "mcps/knowledge-mcp/src/knowledge_mcp/utils/config.py"
      to: "mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py"
      via: "config.versioned_collection_name"
      pattern: "versioned_collection_name"
    - from: "mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py"
      to: "chunk.embedding_model"
      via: "payload storage"
      pattern: "embedding_model.*chunk"
    - from: "mcps/knowledge-mcp/src/knowledge_mcp/store/__init__.py"
      to: "versioned_collection_name"
      via: "create_store factory"
      pattern: "versioned_collection_name"
---

<objective>
Implement collection name versioning (FR-2.3), embedding model metadata storage (FR-2.4), and model validation before ingestion (FR-2.5). These features prevent embedding model lock-in and silent corruption from model mismatches.

Purpose: Addresses Pitfall #2 (embedding model lock-in) and Pitfall #7 (mixing vectors from different models). Without these safeguards, changing embedding models would silently corrupt search results.

Output: Config property for versioned collection names, stores that persist embedding model in metadata, validation that rejects mismatched models.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-migration/01-RESEARCH.md
@.planning/phases/01-migration/01-02-SUMMARY.md
@mcps/knowledge-mcp/src/knowledge_mcp/utils/config.py
@mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py
@mcps/knowledge-mcp/src/knowledge_mcp/store/chromadb_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add versioned collection name property to config</name>
  <files>
mcps/knowledge-mcp/src/knowledge_mcp/utils/config.py
mcps/knowledge-mcp/tests/unit/test_config.py
  </files>
  <action>
Add a property to KnowledgeConfig that generates collection names with embedded model version.

1. Add the versioned_collection_name property to KnowledgeConfig class in config.py:

```python
@property
def versioned_collection_name(self) -> str:
    """Generate collection name with embedding model version.

    Embeds the model identifier in the collection name to prevent
    mixing vectors from different embedding models (Pitfall #7).

    Format: {base_name}_v1_{model_short}
    Example: se_knowledge_base_v1_te3small

    Returns:
        Versioned collection name string.
    """
    # Extract model short name (e.g., text-embedding-3-small -> te3small)
    model_short = self.embedding_model.replace("text-embedding-", "te").replace("-", "")
    return f"{self.qdrant_collection}_v1_{model_short}"

@property
def versioned_chromadb_collection_name(self) -> str:
    """Generate ChromaDB collection name with embedding model version.

    Same versioning scheme as Qdrant for consistency.

    Returns:
        Versioned collection name string.
    """
    model_short = self.embedding_model.replace("text-embedding-", "te").replace("-", "")
    return f"{self.chromadb_collection}_v1_{model_short}"
```

2. Add tests in test_config.py:

```python
def test_versioned_collection_name_default():
    """Test versioned collection name with default model."""
    config = KnowledgeConfig(openai_api_key="test-key")
    # Default model is text-embedding-3-small
    assert config.versioned_collection_name == "se_knowledge_base_v1_te3small"

def test_versioned_collection_name_custom_base():
    """Test versioned collection name with custom base name."""
    config = KnowledgeConfig(
        openai_api_key="test-key",
        qdrant_collection="my_collection"
    )
    assert config.versioned_collection_name == "my_collection_v1_te3small"

def test_versioned_collection_name_different_model():
    """Test versioned collection name with different embedding model."""
    config = KnowledgeConfig(
        openai_api_key="test-key",
        embedding_model="text-embedding-3-large"
    )
    assert config.versioned_collection_name == "se_knowledge_base_v1_te3large"

def test_versioned_chromadb_collection_name():
    """Test ChromaDB versioned collection name."""
    config = KnowledgeConfig(openai_api_key="test-key")
    assert config.versioned_chromadb_collection_name == "se_knowledge_base_v1_te3small"
```

3. Run tests to verify:
```bash
cd mcps/knowledge-mcp
poetry run pytest tests/unit/test_config.py -v
```

IMPORTANT: The base collection names (qdrant_collection, chromadb_collection) remain as-is for backward compatibility. The versioned_collection_name is used by stores when creating/accessing collections.
  </action>
  <verify>
- `grep "versioned_collection_name" mcps/knowledge-mcp/src/knowledge_mcp/utils/config.py` shows property definition
- `poetry run pytest tests/unit/test_config.py -v -k versioned` passes
- Config property returns format like "se_knowledge_base_v1_te3small"
  </verify>
  <done>
- versioned_collection_name property added to KnowledgeConfig
- versioned_chromadb_collection_name property added for consistency
- Unit tests added and passing
- Property correctly formats model name into collection name
  </done>
</task>

<task type="auto">
  <name>Task 2: Store embedding model metadata and add validation</name>
  <files>
mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py
mcps/knowledge-mcp/src/knowledge_mcp/store/chromadb_store.py
mcps/knowledge-mcp/tests/unit/test_qdrant_store.py
mcps/knowledge-mcp/tests/unit/test_chromadb_store.py
  </files>
  <action>
Update both vector stores to:
1. Use versioned collection names
2. Store embedding_model in chunk payload/metadata
3. Validate model match before ingestion

**For QdrantStore (qdrant_store.py):**

1. Update __init__ to use versioned collection name:
```python
def __init__(self, config: KnowledgeConfig) -> None:
    # Use versioned collection name to prevent model mixing
    self.collection = config.versioned_collection_name  # Changed from config.qdrant_collection
    # ... rest of init unchanged
```

2. Update add_chunks to store embedding_model in payload:
```python
# In the add_chunks method, where PointStruct is created:
point = PointStruct(
    id=chunk.id,
    vector=vectors if self.hybrid_enabled else chunk.embedding,
    payload={
        "content": chunk.content,
        "source": chunk.source,
        "chunk_index": chunk.chunk_index,
        "metadata": chunk.metadata,
        "embedding_model": chunk.embedding_model,  # ADD THIS
        "embedding_dimensions": len(chunk.embedding) if chunk.embedding else 0,  # ADD THIS
    },
)
```

3. Add validate_embedding_model method:
```python
def validate_embedding_model(self, expected_model: str) -> bool:
    """Verify collection uses expected embedding model.

    Args:
        expected_model: The embedding model name to validate against.

    Returns:
        True if model matches or collection is empty.

    Raises:
        ValueError: If collection has data with different embedding model.
    """
    try:
        # Sample one point to check metadata
        results = self.client.scroll(
            collection_name=self.collection,
            limit=1,
        )
        if not results[0]:  # Empty collection
            return True

        point = results[0][0]
        stored_model = point.payload.get("embedding_model")
        if stored_model and stored_model != expected_model:
            raise ValueError(
                f"Collection '{self.collection}' uses {stored_model}, "
                f"but config specifies {expected_model}. "
                f"Use different collection name or recreate collection."
            )
        return True
    except Exception as e:
        if isinstance(e, ValueError):
            raise
        logger.warning("Model validation failed: %s", e)
        return False
```

**For ChromaDBStore (chromadb_store.py):**

1. Update __init__ to accept config (if not already) and use versioned name
2. Store embedding_model in metadata when adding chunks
3. Add the same validate_embedding_model method

**Add tests for both stores:**

```python
# In test_qdrant_store.py
def test_add_chunks_stores_embedding_model():
    """Test that embedding model is stored in payload."""
    # Create chunk with embedding_model
    # Add to store
    # Query and verify embedding_model in payload

def test_validate_embedding_model_empty_collection():
    """Test validation passes on empty collection."""

def test_validate_embedding_model_mismatch():
    """Test validation raises on model mismatch."""
```

Run full test suite after changes:
```bash
cd mcps/knowledge-mcp
poetry run pytest tests/ -v --tb=short
```

**CRITICAL: Verify create_store() uses versioned names:**
After implementation, verify that the create_store() factory in store/__init__.py
instantiates stores with versioned collection names:
```bash
grep -A5 "def create_store" mcps/knowledge-mcp/src/knowledge_mcp/store/__init__.py
# Should show it passes config to store constructors, which now use versioned names
```
  </action>
  <verify>
- `grep "embedding_model" mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py` shows payload field
- `grep "validate_embedding_model" mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py` shows method
- `grep "versioned_collection_name" mcps/knowledge-mcp/src/knowledge_mcp/store/qdrant_store.py` shows usage
- `grep "versioned_collection_name" mcps/knowledge-mcp/src/knowledge_mcp/store/chromadb_store.py` shows usage
- `poetry run pytest tests/ -v` all tests pass
- Verify create_store() flow uses versioned names: stores receive config with versioned_collection_name
  </verify>
  <done>
- QdrantStore uses versioned_collection_name
- QdrantStore stores embedding_model in payload
- QdrantStore has validate_embedding_model method
- ChromaDBStore has matching implementation
- Tests added and passing for both stores
- Model mismatch raises ValueError with clear message
- create_store() instantiates stores that use versioned collection names
  </done>
</task>

</tasks>

<verification>
Phase 1 Plan 03 verification:
1. Config has versioned_collection_name property: `grep versioned_collection_name mcps/knowledge-mcp/src/knowledge_mcp/utils/config.py`
2. Stores use versioned names: `grep versioned_collection_name mcps/knowledge-mcp/src/knowledge_mcp/store/*.py`
3. Embedding model stored: `grep "embedding_model.*chunk\|embedding_model.*payload" mcps/knowledge-mcp/src/knowledge_mcp/store/*.py`
4. Validation method exists: `grep validate_embedding_model mcps/knowledge-mcp/src/knowledge_mcp/store/*.py`
5. All tests pass: `cd mcps/knowledge-mcp && poetry run pytest tests/ -v`
6. create_store() uses versioned names: Store constructors receive config -> use config.versioned_collection_name
</verification>

<success_criteria>
- [ ] versioned_collection_name property exists in KnowledgeConfig
- [ ] QdrantStore uses versioned collection name
- [ ] QdrantStore stores embedding_model in chunk payload
- [ ] QdrantStore has validate_embedding_model method
- [ ] ChromaDBStore has matching implementation
- [ ] Unit tests added for all new functionality
- [ ] All existing tests still pass
- [ ] Collection names format: {base}_v1_{model_short}
- [ ] create_store() factory instantiates stores with versioned collection names
</success_criteria>

<output>
After completion, create `.planning/phases/01-migration/01-03-SUMMARY.md`
</output>
