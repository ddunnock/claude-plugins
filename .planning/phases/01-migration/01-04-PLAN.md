---
phase: 01-migration
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - mcps/knowledge-mcp/tests/integration/test_fallback.py
autonomous: false

must_haves:
  truths:
    - "ChromaDB fallback activates when Qdrant connection fails"
    - "Health checks execute before vector store operations"
    - "Fallback behavior is tested, not just implemented"
  artifacts:
    - path: "mcps/knowledge-mcp/tests/integration/test_fallback.py"
      provides: "Fallback integration tests"
      contains: "test_fallback"
  key_links:
    - from: "mcps/knowledge-mcp/src/knowledge_mcp/store/__init__.py"
      to: "ChromaDBStore"
      via: "create_store fallback"
      pattern: "falling back to ChromaDB"
---

<objective>
Verify ChromaDB fallback works correctly when Qdrant connection fails (FR-2.2, NFR-1.3). This addresses Pitfall #6: "Qdrant single point of failure - implement AND test ChromaDB fallback."

Purpose: Research confirmed the fallback logic exists but we need to verify it works in the new location with updated dependencies. Testing the fallback is as important as implementing it.

Output: Verified fallback behavior with integration test demonstrating Qdrant failure -> ChromaDB activation.

**Important context from research (01-RESEARCH.md):**
NFR-1.1 (health checks) and NFR-1.2 (retry logic) are ALREADY IMPLEMENTED in the migrated code:
- ChromaDB fallback logic exists in create_store() factory
- Health checks exist in both QdrantStore and ChromaDBStore
- Retry logic with exponential backoff (tenacity) exists in OpenAI embedder

This plan VERIFIES these existing behaviors work correctly after migration and dependency updates.
It does NOT implement new health check or retry functionality - those already exist.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-migration/01-RESEARCH.md
@.planning/phases/01-migration/01-03-SUMMARY.md
@mcps/knowledge-mcp/src/knowledge_mcp/store/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create or update fallback integration test</name>
  <files>
mcps/knowledge-mcp/tests/integration/test_fallback.py
  </files>
  <action>
Create an integration test that verifies the complete fallback flow:
1. Configure Qdrant with invalid/unreachable URL
2. Call create_store()
3. Verify ChromaDBStore is returned (not QdrantStore)
4. Verify warning is logged about fallback

**Note:** This tests EXISTING functionality from the migrated codebase. The health_check()
methods and retry logic already exist per 01-RESEARCH.md findings. We are verifying they
work correctly after migration, not implementing them.

Create/update tests/integration/test_fallback.py:

```python
"""Integration tests for vector store fallback behavior."""

import logging
import tempfile
from pathlib import Path
from unittest.mock import patch

import pytest

from knowledge_mcp.store import create_store, QdrantStore
from knowledge_mcp.store.chromadb_store import ChromaDBStore
from knowledge_mcp.utils.config import KnowledgeConfig


class TestQdrantToChromaDBFallback:
    """Test automatic fallback from Qdrant to ChromaDB."""

    @pytest.fixture
    def temp_chromadb_path(self, tmp_path: Path) -> Path:
        """Create temporary directory for ChromaDB."""
        chromadb_dir = tmp_path / "chromadb"
        chromadb_dir.mkdir()
        return chromadb_dir

    @pytest.fixture
    def config_with_bad_qdrant(self, temp_chromadb_path: Path) -> KnowledgeConfig:
        """Create config with unreachable Qdrant URL."""
        return KnowledgeConfig(
            openai_api_key="test-key",
            vector_store="qdrant",
            qdrant_url="http://localhost:9999",  # Unreachable port
            qdrant_api_key="test-api-key",
            chromadb_path=temp_chromadb_path,
        )

    def test_fallback_to_chromadb_on_qdrant_failure(
        self, config_with_bad_qdrant: KnowledgeConfig, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Verify ChromaDB is returned when Qdrant is unavailable."""
        with caplog.at_level(logging.WARNING):
            store = create_store(config_with_bad_qdrant)

        # Should be ChromaDB, not Qdrant
        assert isinstance(store, ChromaDBStore)
        assert not isinstance(store, QdrantStore)

        # Should log warning about fallback
        assert any(
            "falling back to ChromaDB" in record.message.lower()
            or "qdrant unavailable" in record.message.lower()
            for record in caplog.records
        )

    def test_fallback_store_is_functional(
        self, config_with_bad_qdrant: KnowledgeConfig
    ) -> None:
        """Verify fallback ChromaDB store can perform operations."""
        store = create_store(config_with_bad_qdrant)

        # Health check should pass (tests EXISTING health_check() method)
        assert store.health_check()

        # Should be able to search (empty result is fine)
        results = store.search(query_embedding=[0.1] * 1536, top_k=5)
        assert isinstance(results, list)

    def test_no_fallback_when_chromadb_configured(
        self, temp_chromadb_path: Path
    ) -> None:
        """Verify no fallback logic when ChromaDB is primary."""
        config = KnowledgeConfig(
            openai_api_key="test-key",
            vector_store="chromadb",
            chromadb_path=temp_chromadb_path,
        )

        store = create_store(config)

        assert isinstance(store, ChromaDBStore)


class TestHealthCheckBeforeOperations:
    """Test that health checks execute before store operations.

    Note: health_check() methods already exist in both QdrantStore and ChromaDBStore.
    These tests verify the existing functionality works correctly after migration.
    """

    @pytest.fixture
    def working_config(self, tmp_path: Path) -> KnowledgeConfig:
        """Create config with working ChromaDB."""
        chromadb_dir = tmp_path / "chromadb"
        chromadb_dir.mkdir()
        return KnowledgeConfig(
            openai_api_key="test-key",
            vector_store="chromadb",
            chromadb_path=chromadb_dir,
        )

    def test_health_check_called_during_store_creation(
        self, working_config: KnowledgeConfig
    ) -> None:
        """Verify health_check is called when creating store."""
        with patch.object(
            ChromaDBStore, "health_check", return_value=True
        ) as mock_health:
            store = create_store(working_config)
            mock_health.assert_called_once()


class TestBothStoresUnavailable:
    """Test error handling when no stores are available."""

    def test_connection_error_when_all_stores_fail(self, tmp_path: Path) -> None:
        """Verify ConnectionError is raised when both stores fail."""
        config = KnowledgeConfig(
            openai_api_key="test-key",
            vector_store="qdrant",
            qdrant_url="http://localhost:9999",  # Unreachable
            qdrant_api_key="test-key",
            chromadb_path=tmp_path / "nonexistent" / "deep" / "path",  # Will fail
        )

        # Make ChromaDB fail by using path that can't be created
        with patch.object(
            ChromaDBStore, "health_check", return_value=False
        ):
            with pytest.raises(ConnectionError) as exc_info:
                create_store(config)

            # Error message should mention both stores
            assert "qdrant" in str(exc_info.value).lower()
```

Run the tests:
```bash
cd mcps/knowledge-mcp
poetry run pytest tests/integration/test_fallback.py -v
```
  </action>
  <verify>
- `ls mcps/knowledge-mcp/tests/integration/test_fallback.py` exists
- `poetry run pytest tests/integration/test_fallback.py -v` all tests pass
- Test output shows ChromaDBStore returned on Qdrant failure
- Tests verify existing health_check() method works (not implementing new)
  </verify>
  <done>
- Integration test file created/updated
- Test verifies ChromaDB is returned when Qdrant fails
- Test verifies warning is logged
- Test verifies fallback store is functional
- Test verifies error when both stores fail
- Tests confirm existing health_check() and fallback logic work after migration
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1: Migration with the following implemented:
1. Git subtree migration preserving full history
2. Baseline tests established and passing
3. Dependencies updated (MCP SDK 1.25.x, qdrant-client 1.16.2+)
4. Collection name versioning (e.g., se_knowledge_base_v1_te3small)
5. Embedding model metadata stored in vector payloads
6. Model validation before ingestion
7. ChromaDB fallback tested and verified

Note: Health checks (NFR-1.1) and retry logic (NFR-1.2) were already implemented in the
migrated code. This phase verified they work correctly in the new location.
  </what-built>
  <how-to-verify>
1. Verify git history preserved:
   ```bash
   cd mcps/knowledge-mcp
   git log --oneline . | head -10
   ```
   Should show multiple commits from original repo, not just one.

2. Verify all tests pass:
   ```bash
   poetry run pytest tests/ -v --tb=short
   ```
   Should show 80%+ coverage, all tests passing.

3. Verify dependency versions:
   ```bash
   poetry show mcp
   poetry show qdrant-client
   ```
   Should show mcp 1.25.x and qdrant-client 1.16.2+.

4. Verify versioned collection name:
   ```bash
   poetry run python -c "
   from knowledge_mcp.utils.config import KnowledgeConfig
   c = KnowledgeConfig(openai_api_key='test')
   print(f'Versioned name: {c.versioned_collection_name}')
   "
   ```
   Should print: `Versioned name: se_knowledge_base_v1_te3small`

5. Verify fallback test:
   ```bash
   poetry run pytest tests/integration/test_fallback.py -v
   ```
   Should show all fallback tests passing.

6. Verify existing health checks work:
   ```bash
   grep -n "def health_check" mcps/knowledge-mcp/src/knowledge_mcp/store/*.py
   ```
   Should show health_check methods exist in both store implementations.
  </how-to-verify>
  <resume-signal>Type "approved" if all verifications pass, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
Phase 1 complete verification:
1. [ ] Git history preserved: `git log --oneline mcps/knowledge-mcp/ | wc -l` > 1
2. [ ] All tests pass: `poetry run pytest tests/ -v`
3. [ ] Dependencies updated: `poetry show mcp` shows 1.25.x
4. [ ] Collection versioning works: versioned_collection_name returns correct format
5. [ ] Embedding model stored: grep confirms payload includes embedding_model
6. [ ] Model validation exists: validate_embedding_model method in stores
7. [ ] Fallback tested: integration tests demonstrate Qdrant -> ChromaDB fallback
8. [ ] Health checks exist and work: health_check() methods tested in fallback tests
</verification>

<success_criteria>
- [ ] Fallback integration tests pass
- [ ] ChromaDB correctly activates when Qdrant unavailable
- [ ] Warning logged when fallback occurs
- [ ] Health checks execute before store operations (existing functionality verified)
- [ ] Human verified complete Phase 1 functionality
- [ ] All Phase 1 success criteria from ROADMAP.md met:
  - [ ] All existing tests pass when run from mcps/knowledge-mcp/
  - [ ] Dependencies updated to MCP SDK 1.25.0, Qdrant 1.16.2
  - [ ] ChromaDB fallback works when Qdrant connection fails
  - [ ] Collection names include embedding model version
  - [ ] Health checks execute before vector store operations (pre-existing, verified working)
</success_criteria>

<output>
After completion, create `.planning/phases/01-migration/01-04-SUMMARY.md`
</output>
