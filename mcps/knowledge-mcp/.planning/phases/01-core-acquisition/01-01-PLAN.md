---
phase: 01-core-acquisition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_mcp/db/__init__.py
  - src/knowledge_mcp/db/engine.py
  - src/knowledge_mcp/db/models.py
  - src/knowledge_mcp/db/repositories.py
  - src/knowledge_mcp/utils/config.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "PostgreSQL async engine connects successfully"
    - "Session factory creates sessions with expire_on_commit=False"
    - "Source and AcquisitionRequest models define v2 schema"
    - "Repository pattern provides data access layer"
  artifacts:
    - path: "src/knowledge_mcp/db/__init__.py"
      provides: "Package exports for db module"
    - path: "src/knowledge_mcp/db/engine.py"
      provides: "AsyncEngine and session factory"
      exports: ["create_engine_and_session_factory", "get_session"]
    - path: "src/knowledge_mcp/db/models.py"
      provides: "SQLAlchemy ORM models"
      contains: "class Source"
    - path: "src/knowledge_mcp/db/repositories.py"
      provides: "Repository pattern classes"
      exports: ["SourceRepository", "AcquisitionRequestRepository"]
  key_links:
    - from: "src/knowledge_mcp/db/engine.py"
      to: "src/knowledge_mcp/utils/config.py"
      via: "database_url from config"
      pattern: "config\\.database_url"
    - from: "src/knowledge_mcp/db/repositories.py"
      to: "src/knowledge_mcp/db/models.py"
      via: "imports Source, AcquisitionRequest"
      pattern: "from.*models import"
---

<objective>
Create PostgreSQL async foundation with SQLAlchemy 2.0 async engine, session factory, ORM models, and repository pattern.

Purpose: Establish the relational data layer required by all Phase 1 features (sources, acquisition requests, offline sync).
Output: Working db/ module with engine.py, models.py, repositories.py that can connect to PostgreSQL.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-acquisition/01-RESEARCH.md

# Existing files to reference/extend
@src/knowledge_mcp/utils/config.py
@src/knowledge_mcp/exceptions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PostgreSQL dependencies and config</name>
  <files>pyproject.toml, src/knowledge_mcp/utils/config.py</files>
  <action>
    1. Add dependencies to pyproject.toml:
       - sqlalchemy = "^2.0.25"
       - asyncpg = "^0.29.0"
       - alembic = "^1.13.1" (for later migration use)

    2. Extend KnowledgeConfig in config.py:
       - database_url: str (default empty, PostgreSQL connection string)
       - database_pool_size: int = 15
       - database_max_overflow: int = 10
       - database_echo: bool = False (SQL logging)
       - offline_mode: bool = False (force ChromaDB fallback)

    3. Add validation in validate() method:
       - If offline_mode is False, database_url is required
       - database_url must start with "postgresql+asyncpg://"

    4. Update load_config() to read new env vars:
       - DATABASE_URL
       - DATABASE_POOL_SIZE
       - DATABASE_MAX_OVERFLOW
       - DATABASE_ECHO
       - OFFLINE_MODE

    AVOID: Don't make database_url required when offline_mode=True (graceful degradation).
    WHY: Offline mode should work without PostgreSQL for development/testing.
  </action>
  <verify>
    poetry install completes without errors.
    python -c "from knowledge_mcp.utils.config import load_config; c = load_config(); print(c.database_url)"
  </verify>
  <done>
    New PostgreSQL config fields exist and load from environment.
    Config validates database_url when offline_mode=False.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create db/ module with engine and session factory</name>
  <files>src/knowledge_mcp/db/__init__.py, src/knowledge_mcp/db/engine.py</files>
  <action>
    1. Create src/knowledge_mcp/db/__init__.py with exports:
       - from .engine import create_engine_and_session_factory, get_session
       - from .models import Base, Source, AcquisitionRequest
       - from .repositories import SourceRepository, AcquisitionRequestRepository

    2. Create src/knowledge_mcp/db/engine.py following research patterns:
       ```python
       from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
       from knowledge_mcp.utils.config import KnowledgeConfig

       def create_engine_and_session_factory(config: KnowledgeConfig):
           """Create async engine and session factory. Call once at startup."""
           engine = create_async_engine(
               config.database_url,
               echo=config.database_echo,
               pool_size=config.database_pool_size,
               max_overflow=config.database_max_overflow,
               pool_pre_ping=True,  # Verify connections (Pitfall #3)
               pool_recycle=3600,   # Recycle after 1 hour
           )

           session_factory = async_sessionmaker(
               engine,
               expire_on_commit=False,  # CRITICAL for async (Pitfall #1)
               class_=AsyncSession,
           )

           return engine, session_factory

       @asynccontextmanager
       async def get_session(session_factory):
           """Context manager for database sessions with proper cleanup."""
           async with session_factory() as session:
               try:
                   yield session
                   await session.commit()
               except Exception:
                   await session.rollback()
                   raise
       ```

    AVOID: Using scoped_session (doesn't work with asyncio - Anti-Pattern from research).
    WHY: Thread-local storage doesn't work with asyncio tasks.
  </action>
  <verify>
    python -c "from knowledge_mcp.db import create_engine_and_session_factory"
    ruff check src/knowledge_mcp/db/
    pyright src/knowledge_mcp/db/
  </verify>
  <done>
    db/ module exists with engine.py.
    create_engine_and_session_factory() creates AsyncEngine with pool_pre_ping=True.
    get_session() context manager handles commit/rollback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SQLAlchemy ORM models</name>
  <files>src/knowledge_mcp/db/models.py</files>
  <action>
    Create src/knowledge_mcp/db/models.py with v2 data models:

    ```python
    from datetime import datetime
    from enum import Enum
    from typing import Optional
    from sqlalchemy import String, Text, DateTime, Integer, Enum as SAEnum, ForeignKey
    from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

    class Base(DeclarativeBase):
        """Base class for all ORM models."""
        pass

    class SourceType(str, Enum):
        """Types of knowledge sources."""
        DOCUMENT = "document"  # PDF, DOCX
        WEB = "web"           # Web page
        STANDARD = "standard" # Technical standard

    class SourceStatus(str, Enum):
        """Source ingestion status."""
        PENDING = "pending"
        INGESTING = "ingesting"
        COMPLETE = "complete"
        FAILED = "failed"

    class AuthorityTier(str, Enum):
        """Authority level for scoring."""
        TIER1 = "tier1"  # Standards (IEEE, ISO)
        TIER2 = "tier2"  # Handbooks (NASA, INCOSE)
        TIER3 = "tier3"  # Articles, blogs

    class Source(Base):
        """Knowledge source metadata."""
        __tablename__ = "sources"

        id: Mapped[int] = mapped_column(primary_key=True)
        url: Mapped[str] = mapped_column(String(2048), nullable=False, unique=True)
        title: Mapped[Optional[str]] = mapped_column(String(500))
        source_type: Mapped[SourceType] = mapped_column(SAEnum(SourceType))
        status: Mapped[SourceStatus] = mapped_column(SAEnum(SourceStatus), default=SourceStatus.PENDING)
        authority_tier: Mapped[AuthorityTier] = mapped_column(SAEnum(AuthorityTier), default=AuthorityTier.TIER3)

        # Timestamps
        created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
        updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
        last_ingested_at: Mapped[Optional[datetime]] = mapped_column(DateTime)

        # Ingestion metadata
        chunk_count: Mapped[int] = mapped_column(Integer, default=0)
        error_message: Mapped[Optional[str]] = mapped_column(Text)

        # Relationship to acquisition requests (if this was requested)
        acquisition_request_id: Mapped[Optional[int]] = mapped_column(ForeignKey("acquisition_requests.id"))

    class AcquisitionRequestStatus(str, Enum):
        """Status of acquisition request."""
        PENDING = "pending"
        IN_PROGRESS = "in_progress"
        COMPLETED = "completed"
        FAILED = "failed"
        CANCELLED = "cancelled"

    class AcquisitionRequest(Base):
        """Track requests for new knowledge content."""
        __tablename__ = "acquisition_requests"

        id: Mapped[int] = mapped_column(primary_key=True)
        url: Mapped[str] = mapped_column(String(2048), nullable=False)
        reason: Mapped[Optional[str]] = mapped_column(Text)  # Why this content is needed
        priority: Mapped[int] = mapped_column(Integer, default=0)  # Higher = more urgent
        status: Mapped[AcquisitionRequestStatus] = mapped_column(
            SAEnum(AcquisitionRequestStatus),
            default=AcquisitionRequestStatus.PENDING
        )

        # Timestamps
        created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
        updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
        completed_at: Mapped[Optional[datetime]] = mapped_column(DateTime)

        # Result tracking
        source_id: Mapped[Optional[int]] = mapped_column(Integer)  # Links to created Source
        error_message: Mapped[Optional[str]] = mapped_column(Text)
    ```

    AVOID: Lazy-loading relationships without explicit eager loading.
    WHY: Lazy loading fails in async context (Pitfall #1 from research).

    Note: Using Mapped[] syntax for SQLAlchemy 2.0 type hints.
  </action>
  <verify>
    python -c "from knowledge_mcp.db.models import Base, Source, AcquisitionRequest; print('Models loaded')"
    pyright src/knowledge_mcp/db/models.py
  </verify>
  <done>
    Source model with url, title, source_type, status, authority_tier, timestamps.
    AcquisitionRequest model with url, reason, priority, status, timestamps.
    All enums defined (SourceType, SourceStatus, AuthorityTier, AcquisitionRequestStatus).
  </done>
</task>

<task type="auto">
  <name>Task 4: Create repository pattern classes</name>
  <files>src/knowledge_mcp/db/repositories.py</files>
  <action>
    Create src/knowledge_mcp/db/repositories.py with repository pattern:

    ```python
    from typing import Optional, List
    from datetime import datetime
    from sqlalchemy import select, update
    from sqlalchemy.ext.asyncio import AsyncSession

    from knowledge_mcp.db.models import (
        Source, SourceType, SourceStatus, AuthorityTier,
        AcquisitionRequest, AcquisitionRequestStatus,
    )

    class SourceRepository:
        """Repository for Source model operations."""

        def __init__(self, session: AsyncSession):
            self.session = session

        async def create(
            self,
            url: str,
            source_type: SourceType,
            title: Optional[str] = None,
            authority_tier: AuthorityTier = AuthorityTier.TIER3,
        ) -> Source:
            """Create a new source."""
            source = Source(
                url=url,
                source_type=source_type,
                title=title,
                authority_tier=authority_tier,
            )
            self.session.add(source)
            await self.session.flush()  # Get ID without committing
            return source

        async def get_by_id(self, source_id: int) -> Optional[Source]:
            """Get source by ID."""
            stmt = select(Source).where(Source.id == source_id)
            result = await self.session.execute(stmt)
            return result.scalar_one_or_none()

        async def get_by_url(self, url: str) -> Optional[Source]:
            """Get source by URL."""
            stmt = select(Source).where(Source.url == url)
            result = await self.session.execute(stmt)
            return result.scalar_one_or_none()

        async def list_by_type(self, source_type: SourceType) -> List[Source]:
            """List sources by type."""
            stmt = select(Source).where(Source.source_type == source_type).order_by(Source.created_at.desc())
            result = await self.session.execute(stmt)
            return list(result.scalars().all())

        async def list_by_status(self, status: SourceStatus) -> List[Source]:
            """List sources by status."""
            stmt = select(Source).where(Source.status == status).order_by(Source.created_at.desc())
            result = await self.session.execute(stmt)
            return list(result.scalars().all())

        async def update_status(
            self,
            source_id: int,
            status: SourceStatus,
            error_message: Optional[str] = None,
            chunk_count: Optional[int] = None,
        ) -> None:
            """Update source status after ingestion."""
            values = {"status": status, "updated_at": datetime.utcnow()}
            if error_message is not None:
                values["error_message"] = error_message
            if chunk_count is not None:
                values["chunk_count"] = chunk_count
            if status == SourceStatus.COMPLETE:
                values["last_ingested_at"] = datetime.utcnow()

            stmt = update(Source).where(Source.id == source_id).values(**values)
            await self.session.execute(stmt)


    class AcquisitionRequestRepository:
        """Repository for AcquisitionRequest model operations."""

        def __init__(self, session: AsyncSession):
            self.session = session

        async def create(
            self,
            url: str,
            reason: Optional[str] = None,
            priority: int = 0,
        ) -> AcquisitionRequest:
            """Create a new acquisition request."""
            request = AcquisitionRequest(
                url=url,
                reason=reason,
                priority=priority,
            )
            self.session.add(request)
            await self.session.flush()
            return request

        async def get_by_id(self, request_id: int) -> Optional[AcquisitionRequest]:
            """Get request by ID."""
            stmt = select(AcquisitionRequest).where(AcquisitionRequest.id == request_id)
            result = await self.session.execute(stmt)
            return result.scalar_one_or_none()

        async def list_pending(self) -> List[AcquisitionRequest]:
            """List pending acquisition requests by priority."""
            stmt = (
                select(AcquisitionRequest)
                .where(AcquisitionRequest.status == AcquisitionRequestStatus.PENDING)
                .order_by(AcquisitionRequest.priority.desc(), AcquisitionRequest.created_at)
            )
            result = await self.session.execute(stmt)
            return list(result.scalars().all())

        async def update_status(
            self,
            request_id: int,
            status: AcquisitionRequestStatus,
            source_id: Optional[int] = None,
            error_message: Optional[str] = None,
        ) -> None:
            """Update request status."""
            values = {"status": status, "updated_at": datetime.utcnow()}
            if source_id is not None:
                values["source_id"] = source_id
            if error_message is not None:
                values["error_message"] = error_message
            if status == AcquisitionRequestStatus.COMPLETED:
                values["completed_at"] = datetime.utcnow()

            stmt = update(AcquisitionRequest).where(AcquisitionRequest.id == request_id).values(**values)
            await self.session.execute(stmt)
    ```

    AVOID: Sharing AsyncSession across multiple tasks.
    WHY: Each task needs its own session (Pattern #5 from research).
  </action>
  <verify>
    python -c "from knowledge_mcp.db.repositories import SourceRepository, AcquisitionRequestRepository"
    pyright src/knowledge_mcp/db/repositories.py
    ruff check src/knowledge_mcp/db/
  </verify>
  <done>
    SourceRepository with create, get_by_id, get_by_url, list_by_type, list_by_status, update_status.
    AcquisitionRequestRepository with create, get_by_id, list_pending, update_status.
    Repository pattern enforces session-per-operation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Imports work:**
   ```bash
   python -c "from knowledge_mcp.db import create_engine_and_session_factory, get_session, Source, AcquisitionRequest, SourceRepository"
   ```

2. **Type checking passes:**
   ```bash
   pyright src/knowledge_mcp/db/
   ```

3. **Linting passes:**
   ```bash
   ruff check src/knowledge_mcp/db/
   ```

4. **Config extension works:**
   ```bash
   DATABASE_URL="postgresql+asyncpg://user:pass@localhost/test" python -c "
   from knowledge_mcp.utils.config import load_config
   c = load_config()
   print(f'URL: {c.database_url}')
   print(f'Pool: {c.database_pool_size}')
   "
   ```
</verification>

<success_criteria>
- [ ] pyproject.toml has sqlalchemy ^2.0.25, asyncpg ^0.29.0, alembic ^1.13.1
- [ ] KnowledgeConfig has database_url, database_pool_size, database_max_overflow, offline_mode
- [ ] db/__init__.py exports all public APIs
- [ ] db/engine.py creates AsyncEngine with pool_pre_ping=True, expire_on_commit=False
- [ ] db/models.py defines Source, AcquisitionRequest with proper enums and timestamps
- [ ] db/repositories.py implements SourceRepository, AcquisitionRequestRepository
- [ ] All code passes pyright and ruff checks
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-acquisition/01-01-SUMMARY.md`
</output>
