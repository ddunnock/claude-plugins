---
phase: 01-core-acquisition
plan: 06
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03", "01-04", "01-05"]
files_modified:
  - src/knowledge_mcp/server.py
  - src/knowledge_mcp/tools/__init__.py
  - src/knowledge_mcp/tools/acquisition.py
autonomous: true

must_haves:
  truths:
    - "knowledge_ingest triggers document/web ingestion"
    - "knowledge_sources lists/filters sources"
    - "knowledge_assess identifies coverage gaps"
    - "knowledge_preflight verifies URL accessibility"
    - "knowledge_acquire ingests web content"
    - "knowledge_request creates acquisition requests"
  artifacts:
    - path: "src/knowledge_mcp/tools/acquisition.py"
      provides: "Tool handler implementations"
      exports: ["handle_ingest", "handle_sources", "handle_assess", "handle_preflight", "handle_acquire", "handle_request"]
      min_lines: 300
    - path: "src/knowledge_mcp/server.py"
      provides: "MCP server with 8 tools total"
      contains: "knowledge_ingest"
  key_links:
    - from: "src/knowledge_mcp/server.py"
      to: "src/knowledge_mcp/tools/acquisition.py"
      via: "imports tool handlers"
      pattern: "from.*tools.acquisition import"
    - from: "src/knowledge_mcp/tools/acquisition.py"
      to: "src/knowledge_mcp/db/repositories.py"
      via: "database operations"
      pattern: "SourceRepository|AcquisitionRequestRepository"
    - from: "src/knowledge_mcp/tools/acquisition.py"
      to: "src/knowledge_mcp/ingest/web_ingestor.py"
      via: "web crawling"
      pattern: "WebIngestor"
---

<objective>
Implement 6 new MCP tools for content acquisition: ingest, sources, assess, preflight, acquire, request.

Purpose: Expose Phase 1 capabilities via MCP protocol (FR-2.1 through FR-2.5).
Output: Extended server.py with 8 total tools (2 existing + 6 new), tool handlers in tools/acquisition.py.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-acquisition/01-RESEARCH.md

# Depends on all prior plan outputs
@src/knowledge_mcp/server.py
@src/knowledge_mcp/db/repositories.py
@src/knowledge_mcp/ingest/web_ingestor.py
@src/knowledge_mcp/search/coverage.py
@src/knowledge_mcp/sync/offline.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tools module with acquisition handlers</name>
  <files>src/knowledge_mcp/tools/__init__.py, src/knowledge_mcp/tools/acquisition.py</files>
  <action>
    1. Create src/knowledge_mcp/tools/__init__.py:
       ```python
       """MCP tool implementations for Knowledge MCP."""

       from .acquisition import (
           handle_ingest,
           handle_sources,
           handle_assess,
           handle_preflight,
           handle_acquire,
           handle_request,
       )

       __all__ = [
           "handle_ingest",
           "handle_sources",
           "handle_assess",
           "handle_preflight",
           "handle_acquire",
           "handle_request",
       ]
       ```

    2. Create src/knowledge_mcp/tools/acquisition.py with tool handlers:
       ```python
       """
       Acquisition tool handlers for Knowledge MCP.

       Implements handlers for:
       - knowledge_ingest: Trigger document/web ingestion
       - knowledge_sources: List/filter knowledge sources
       - knowledge_assess: Assess coverage gaps
       - knowledge_preflight: Check URL accessibility
       - knowledge_acquire: Acquire web content
       - knowledge_request: Create acquisition request

       All handlers are async and return dict suitable for JSON serialization.
       """

       from __future__ import annotations

       import logging
       from typing import Any, Dict, List, Optional, TYPE_CHECKING

       if TYPE_CHECKING:
           from sqlalchemy.ext.asyncio import AsyncSession

       from knowledge_mcp.db.models import SourceType, SourceStatus, AuthorityTier
       from knowledge_mcp.db.repositories import SourceRepository, AcquisitionRequestRepository
       from knowledge_mcp.ingest import WebIngestor, WebIngestorConfig, check_url_accessible
       from knowledge_mcp.search import CoverageAssessor, SemanticSearcher

       logger = logging.getLogger(__name__)


       async def handle_ingest(
           session: "AsyncSession",
           url: str,
           source_type: str = "web",
           authority_tier: str = "tier3",
           title: Optional[str] = None,
       ) -> Dict[str, Any]:
           """
           Handle knowledge_ingest tool call.

           Creates source record and triggers ingestion if web URL.

           Args:
               session: Database session.
               url: URL or path to ingest.
               source_type: Type (document, web, standard).
               authority_tier: Authority level (tier1, tier2, tier3).
               title: Optional title override.

           Returns:
               Dict with source_id and status.
           """
           try:
               # Validate source type
               try:
                   st = SourceType(source_type)
               except ValueError:
                   return {"error": f"Invalid source_type: {source_type}", "isError": True}

               # Validate authority tier
               try:
                   at = AuthorityTier(authority_tier)
               except ValueError:
                   return {"error": f"Invalid authority_tier: {authority_tier}", "isError": True}

               # Create source record
               repo = SourceRepository(session)

               # Check if source already exists
               existing = await repo.get_by_url(url)
               if existing:
                   return {
                       "source_id": existing.id,
                       "status": existing.status.value,
                       "message": "Source already exists",
                       "already_exists": True,
                   }

               # Create new source
               source = await repo.create(
                   url=url,
                   source_type=st,
                   authority_tier=at,
                   title=title,
               )

               # For web sources, trigger ingestion
               if st == SourceType.WEB:
                   await repo.update_status(source.id, SourceStatus.INGESTING)

                   ingestor = WebIngestor()
                   result = await ingestor.ingest(url)

                   if result.success:
                       await repo.update_status(
                           source.id,
                           SourceStatus.COMPLETE,
                           chunk_count=result.word_count // 100,  # Rough estimate
                       )
                       return {
                           "source_id": source.id,
                           "status": "complete",
                           "title": result.title or title,
                           "word_count": result.word_count,
                           "message": "Web content ingested successfully",
                       }
                   else:
                       await repo.update_status(
                           source.id,
                           SourceStatus.FAILED,
                           error_message=result.error,
                       )
                       return {
                           "source_id": source.id,
                           "status": "failed",
                           "error": result.error,
                           "isError": True,
                       }

               # For documents, mark as pending (ingestion via CLI)
               return {
                   "source_id": source.id,
                   "status": "pending",
                   "message": f"Source created. Run CLI to ingest {source_type} content.",
               }

           except Exception as e:
               logger.error(f"Ingest error: {e}")
               return {"error": str(e), "isError": True}


       async def handle_sources(
           session: "AsyncSession",
           source_type: Optional[str] = None,
           status: Optional[str] = None,
           authority_tier: Optional[str] = None,
           limit: int = 50,
       ) -> Dict[str, Any]:
           """
           Handle knowledge_sources tool call.

           Lists and filters knowledge sources.

           Args:
               session: Database session.
               source_type: Filter by type.
               status: Filter by status.
               authority_tier: Filter by authority.
               limit: Maximum results.

           Returns:
               Dict with sources list.
           """
           try:
               from sqlalchemy import select
               from knowledge_mcp.db.models import Source

               # Build query
               stmt = select(Source).order_by(Source.created_at.desc()).limit(limit)

               if source_type:
                   try:
                       st = SourceType(source_type)
                       stmt = stmt.where(Source.source_type == st)
                   except ValueError:
                       return {"error": f"Invalid source_type: {source_type}", "isError": True}

               if status:
                   try:
                       ss = SourceStatus(status)
                       stmt = stmt.where(Source.status == ss)
                   except ValueError:
                       return {"error": f"Invalid status: {status}", "isError": True}

               if authority_tier:
                   try:
                       at = AuthorityTier(authority_tier)
                       stmt = stmt.where(Source.authority_tier == at)
                   except ValueError:
                       return {"error": f"Invalid authority_tier: {authority_tier}", "isError": True}

               # Execute query
               result = await session.execute(stmt)
               sources = list(result.scalars().all())

               # Format response
               return {
                   "sources": [
                       {
                           "id": s.id,
                           "url": s.url,
                           "title": s.title,
                           "source_type": s.source_type.value,
                           "status": s.status.value,
                           "authority_tier": s.authority_tier.value,
                           "chunk_count": s.chunk_count,
                           "created_at": s.created_at.isoformat() if s.created_at else None,
                       }
                       for s in sources
                   ],
                   "total": len(sources),
               }

           except Exception as e:
               logger.error(f"Sources error: {e}")
               return {"error": str(e), "isError": True}


       async def handle_assess(
           searcher: SemanticSearcher,
           areas: List[str],
           threshold: float = 0.5,
       ) -> Dict[str, Any]:
           """
           Handle knowledge_assess tool call.

           Assesses coverage for specified knowledge areas.

           Args:
               searcher: SemanticSearcher instance.
               areas: Knowledge areas to assess.
               threshold: Similarity threshold for coverage.

           Returns:
               Dict with coverage report.
           """
           try:
               from knowledge_mcp.search.coverage import CoverageConfig

               config = CoverageConfig(similarity_threshold=threshold)
               assessor = CoverageAssessor(searcher, config)
               report = await assessor.assess(areas)

               return report.to_dict()

           except Exception as e:
               logger.error(f"Assess error: {e}")
               return {"error": str(e), "isError": True}


       async def handle_preflight(
           url: str,
           check_robots: bool = True,
       ) -> Dict[str, Any]:
           """
           Handle knowledge_preflight tool call.

           Checks if URL is accessible and respects robots.txt.

           Args:
               url: URL to check.
               check_robots: Whether to check robots.txt.

           Returns:
               Dict with accessibility status.
           """
           try:
               accessible, error = await check_url_accessible(url, check_robots)

               return {
                   "url": url,
                   "accessible": accessible,
                   "robots_checked": check_robots,
                   "error": error,
               }

           except Exception as e:
               logger.error(f"Preflight error: {e}")
               return {"error": str(e), "isError": True, "accessible": False}


       async def handle_acquire(
           session: "AsyncSession",
           url: str,
           authority_tier: str = "tier3",
           title: Optional[str] = None,
           reason: Optional[str] = None,
       ) -> Dict[str, Any]:
           """
           Handle knowledge_acquire tool call.

           Acquires web content: preflight check, create source, ingest.

           Args:
               session: Database session.
               url: URL to acquire.
               authority_tier: Authority level.
               title: Optional title.
               reason: Why this content is needed.

           Returns:
               Dict with acquisition result.
           """
           try:
               # Preflight check first
               accessible, error = await check_url_accessible(url)
               if not accessible:
                   return {
                       "url": url,
                       "acquired": False,
                       "error": f"Preflight failed: {error}",
                       "isError": True,
                   }

               # Ingest the content
               result = await handle_ingest(
                   session=session,
                   url=url,
                   source_type="web",
                   authority_tier=authority_tier,
                   title=title,
               )

               # Check if ingest succeeded
               if result.get("isError"):
                   return {
                       "url": url,
                       "acquired": False,
                       "error": result.get("error"),
                       "isError": True,
                   }

               return {
                   "url": url,
                   "acquired": True,
                   "source_id": result.get("source_id"),
                   "title": result.get("title"),
                   "word_count": result.get("word_count"),
                   "reason": reason,
               }

           except Exception as e:
               logger.error(f"Acquire error: {e}")
               return {"error": str(e), "isError": True, "acquired": False}


       async def handle_request(
           session: "AsyncSession",
           url: str,
           reason: Optional[str] = None,
           priority: int = 0,
       ) -> Dict[str, Any]:
           """
           Handle knowledge_request tool call.

           Creates an acquisition request for later processing.

           Args:
               session: Database session.
               url: URL to request.
               reason: Why this content is needed.
               priority: Request priority (higher = more urgent).

           Returns:
               Dict with request details.
           """
           try:
               repo = AcquisitionRequestRepository(session)

               # Create request
               request = await repo.create(
                   url=url,
                   reason=reason,
                   priority=priority,
               )

               return {
                   "request_id": request.id,
                   "url": request.url,
                   "reason": request.reason,
                   "priority": request.priority,
                   "status": request.status.value,
                   "created_at": request.created_at.isoformat() if request.created_at else None,
                   "message": "Acquisition request created",
               }

           except Exception as e:
               logger.error(f"Request error: {e}")
               return {"error": str(e), "isError": True}
       ```
  </action>
  <verify>
    python -c "from knowledge_mcp.tools import handle_ingest, handle_sources, handle_assess, handle_preflight, handle_acquire, handle_request"
    pyright src/knowledge_mcp/tools/acquisition.py
    ruff check src/knowledge_mcp/tools/acquisition.py
  </verify>
  <done>
    tools/__init__.py exports all handlers.
    acquisition.py implements 6 tool handlers.
    Handlers return JSON-serializable dicts.
    Error handling returns isError: True.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend server.py with new tools</name>
  <files>src/knowledge_mcp/server.py</files>
  <action>
    Extend server.py to register 6 new tools and wire up handlers.

    1. Add imports at top of server.py:
       ```python
       from knowledge_mcp.tools.acquisition import (
           handle_ingest,
           handle_sources,
           handle_assess,
           handle_preflight,
           handle_acquire,
           handle_request,
       )
       from knowledge_mcp.db.engine import create_engine_and_session_factory, get_session
       ```

    2. Add database initialization in _ensure_dependencies():
       - Check if offline_mode in config
       - If not offline, create engine and session_factory
       - Store as self._engine, self._session_factory

    3. Add 6 new Tool definitions in handle_list_tools():

       ```python
       Tool(
           name="knowledge_ingest",
           description="""Trigger ingestion of a document or web URL into the knowledge base.

       Use this to add new content sources. For web URLs, content is crawled and ingested immediately.
       For documents (PDF, DOCX), creates a source record for CLI ingestion.

       Parameters:
       - url (required): URL or file path to ingest
       - source_type: "document", "web", or "standard" (default: "web")
       - authority_tier: "tier1" (standards), "tier2" (handbooks), "tier3" (articles) (default: "tier3")
       - title: Optional title override""",
           inputSchema={...}
       ),

       Tool(
           name="knowledge_sources",
           description="""List and filter knowledge sources in the database.

       Returns sources with their status, type, and metadata.
       Use filters to find specific types of content.""",
           inputSchema={...}
       ),

       Tool(
           name="knowledge_assess",
           description="""Assess knowledge coverage for specified topics.

       Identifies gaps where the knowledge base has low or no coverage.
       Returns priority rankings and suggested queries for acquisition.""",
           inputSchema={...}
       ),

       Tool(
           name="knowledge_preflight",
           description="""Check if a URL is accessible before acquisition.

       Verifies the URL can be reached and respects robots.txt.
       Use before knowledge_acquire to validate URLs.""",
           inputSchema={...}
       ),

       Tool(
           name="knowledge_acquire",
           description="""Acquire web content: preflight, create source, and ingest.

       Complete workflow for adding web content. Checks accessibility,
       creates source record, and ingests content.""",
           inputSchema={...}
       ),

       Tool(
           name="knowledge_request",
           description="""Create an acquisition request for content to be added later.

       Use when content cannot be acquired immediately (auth required,
       manual review needed, etc.). Tracks pending acquisitions.""",
           inputSchema={...}
       )
       ```

    4. Add handlers in handle_call_tool():
       ```python
       elif name == "knowledge_ingest":
           return await self._handle_knowledge_ingest(arguments)
       elif name == "knowledge_sources":
           return await self._handle_knowledge_sources(arguments)
       # ... etc for all 6 tools
       ```

    5. Implement handler methods that:
       - Get session from self._session_factory
       - Call appropriate handler from tools/acquisition.py
       - Return TextContent with JSON result

    AVOID: Blocking database operations in async handlers.
    WHY: All database operations use AsyncSession, must be awaited.
  </action>
  <verify>
    python -c "
    from knowledge_mcp.server import KnowledgeMCPServer
    # Server should be importable
    print('Server imports OK')
    "
    pyright src/knowledge_mcp/server.py
    ruff check src/knowledge_mcp/server.py
  </verify>
  <done>
    server.py registers 8 tools (2 existing + 6 new).
    Tool definitions have comprehensive descriptions.
    Tool handlers use async database sessions.
    handle_call_tool dispatches to appropriate handlers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for new tools</name>
  <files>tests/integration/test_acquisition_tools.py</files>
  <action>
    Create tests/integration/test_acquisition_tools.py:

    ```python
    """Integration tests for acquisition MCP tools."""

    from unittest.mock import AsyncMock, MagicMock, patch
    import pytest

    from knowledge_mcp.server import KnowledgeMCPServer


    class TestAcquisitionToolsListed:
        """Test that all acquisition tools are registered."""

        @pytest.fixture
        def server(self) -> KnowledgeMCPServer:
            """Create server instance."""
            return KnowledgeMCPServer()

        @pytest.mark.asyncio
        async def test_all_tools_listed(self, server: KnowledgeMCPServer) -> None:
            """Test all 8 tools are listed."""
            # Get tools handler
            tools = await server.server._tool_manager.list_tools()

            tool_names = [t.name for t in tools]
            expected = [
                "knowledge_search",
                "knowledge_stats",
                "knowledge_ingest",
                "knowledge_sources",
                "knowledge_assess",
                "knowledge_preflight",
                "knowledge_acquire",
                "knowledge_request",
            ]

            for name in expected:
                assert name in tool_names, f"Missing tool: {name}"

        @pytest.mark.asyncio
        async def test_ingest_tool_schema(self, server: KnowledgeMCPServer) -> None:
            """Test knowledge_ingest has correct schema."""
            tools = await server.server._tool_manager.list_tools()
            ingest_tool = next(t for t in tools if t.name == "knowledge_ingest")

            schema = ingest_tool.inputSchema
            assert "url" in schema["properties"]
            assert "source_type" in schema["properties"]
            assert "url" in schema["required"]

        @pytest.mark.asyncio
        async def test_assess_tool_schema(self, server: KnowledgeMCPServer) -> None:
            """Test knowledge_assess has correct schema."""
            tools = await server.server._tool_manager.list_tools()
            assess_tool = next(t for t in tools if t.name == "knowledge_assess")

            schema = assess_tool.inputSchema
            assert "areas" in schema["properties"]
            assert "areas" in schema["required"]

        @pytest.mark.asyncio
        async def test_preflight_tool_schema(self, server: KnowledgeMCPServer) -> None:
            """Test knowledge_preflight has correct schema."""
            tools = await server.server._tool_manager.list_tools()
            preflight_tool = next(t for t in tools if t.name == "knowledge_preflight")

            schema = preflight_tool.inputSchema
            assert "url" in schema["properties"]
            assert "check_robots" in schema["properties"]


    class TestToolDescriptions:
        """Test tool descriptions are helpful."""

        @pytest.fixture
        def server(self) -> KnowledgeMCPServer:
            """Create server instance."""
            return KnowledgeMCPServer()

        @pytest.mark.asyncio
        async def test_ingest_description(self, server: KnowledgeMCPServer) -> None:
            """Test ingest has helpful description."""
            tools = await server.server._tool_manager.list_tools()
            ingest_tool = next(t for t in tools if t.name == "knowledge_ingest")

            desc = ingest_tool.description
            assert "document" in desc.lower()
            assert "web" in desc.lower()
            assert "url" in desc.lower()

        @pytest.mark.asyncio
        async def test_assess_description(self, server: KnowledgeMCPServer) -> None:
            """Test assess has helpful description."""
            tools = await server.server._tool_manager.list_tools()
            assess_tool = next(t for t in tools if t.name == "knowledge_assess")

            desc = assess_tool.description
            assert "coverage" in desc.lower()
            assert "gap" in desc.lower()
    ```

    Note: These tests verify tool registration without requiring database.
    Full end-to-end tests require PostgreSQL setup.
  </action>
  <verify>
    pytest tests/integration/test_acquisition_tools.py -v
  </verify>
  <done>
    Integration tests verify all 8 tools registered.
    Tests check input schemas have required fields.
    Tests verify descriptions are helpful.
    Tests run without database (mocking where needed).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Imports work:**
   python -c "
   from knowledge_mcp.server import KnowledgeMCPServer
   from knowledge_mcp.tools import handle_ingest, handle_sources, handle_assess, handle_preflight, handle_acquire, handle_request
   print('All imports OK')
   "

2. **Type checking passes:**
   pyright src/knowledge_mcp/tools/
   pyright src/knowledge_mcp/server.py

3. **Linting passes:**
   ruff check src/knowledge_mcp/tools/
   ruff check src/knowledge_mcp/server.py

4. **Unit tests pass:**
   pytest tests/unit/ -v

5. **Integration tests pass:**
   pytest tests/integration/test_acquisition_tools.py -v
</verification>

<success_criteria>
- [ ] tools/__init__.py exports 6 handlers
- [ ] acquisition.py implements handle_ingest, handle_sources, handle_assess, handle_preflight, handle_acquire, handle_request
- [ ] Each handler returns JSON-serializable dict with isError on failure
- [ ] server.py registers 8 tools total
- [ ] Tool definitions have comprehensive descriptions
- [ ] Tool inputSchemas have all required fields
- [ ] handle_call_tool dispatches to correct handlers
- [ ] Database operations use async sessions
- [ ] Integration tests verify tool registration
- [ ] All code passes pyright and ruff checks
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-acquisition/01-06-SUMMARY.md`
</output>
