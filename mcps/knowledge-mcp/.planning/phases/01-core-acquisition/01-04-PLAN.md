---
phase: 01-core-acquisition
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/knowledge_mcp/sync/__init__.py
  - src/knowledge_mcp/sync/offline.py
  - src/knowledge_mcp/utils/config.py
autonomous: true

must_haves:
  truths:
    - "Offline mode uses ChromaDB when PostgreSQL unavailable"
    - "Source metadata syncs to ChromaDB for offline queries"
    - "Sync manager detects online/offline state"
    - "Offline mode provides degraded but functional knowledge search"
  artifacts:
    - path: "src/knowledge_mcp/sync/__init__.py"
      provides: "Package exports for sync module"
    - path: "src/knowledge_mcp/sync/offline.py"
      provides: "Offline sync manager"
      exports: ["OfflineSyncManager", "SyncStatus"]
      min_lines: 100
  key_links:
    - from: "src/knowledge_mcp/sync/offline.py"
      to: "src/knowledge_mcp/store/chromadb_store.py"
      via: "ChromaDB for offline storage"
      pattern: "chromadb"
    - from: "src/knowledge_mcp/sync/offline.py"
      to: "src/knowledge_mcp/db/models.py"
      via: "Source model for metadata"
      pattern: "from.*models import"
---

<objective>
Implement offline sync manager that syncs PostgreSQL source metadata to ChromaDB for offline operation.

Purpose: Enable graceful degradation when PostgreSQL is unavailable (NFR-2.2: Offline mode availability 100%).
Output: OfflineSyncManager class that maintains ChromaDB copy of essential metadata for offline search.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-acquisition/01-RESEARCH.md

# Depends on Plan 01 outputs
@src/knowledge_mcp/db/models.py
@src/knowledge_mcp/store/chromadb_store.py
@src/knowledge_mcp/utils/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync module structure</name>
  <files>src/knowledge_mcp/sync/__init__.py, src/knowledge_mcp/sync/offline.py</files>
  <action>
    1. Create src/knowledge_mcp/sync/__init__.py:
       ```python
       """Offline synchronization module for Knowledge MCP."""

       from .offline import OfflineSyncManager, SyncStatus

       __all__ = ["OfflineSyncManager", "SyncStatus"]
       ```

    2. Create src/knowledge_mcp/sync/offline.py with initial structure:
       ```python
       """
       Offline sync manager for Knowledge MCP.

       Syncs PostgreSQL source metadata to ChromaDB for offline operation.
       Enables graceful degradation when database is unavailable.

       Strategy from research:
       - Sync minimal metadata only (source_id, url, type, authority_tier)
       - Store as ChromaDB metadata attached to source documents
       - Accept reduced functionality offline (no complex queries)

       Example:
           >>> sync_manager = OfflineSyncManager(config)
           >>> await sync_manager.sync_sources(session)
           >>> status = await sync_manager.get_status()
       """

       from __future__ import annotations

       import json
       import logging
       from dataclasses import dataclass, field
       from datetime import datetime
       from enum import Enum
       from pathlib import Path
       from typing import Optional, List, Dict, Any, TYPE_CHECKING

       if TYPE_CHECKING:
           from sqlalchemy.ext.asyncio import AsyncSession

       logger = logging.getLogger(__name__)


       class SyncStatus(str, Enum):
           """Sync state between PostgreSQL and ChromaDB."""
           SYNCED = "synced"
           PENDING = "pending"
           OFFLINE = "offline"
           ERROR = "error"


       @dataclass
       class SyncState:
           """Current sync state."""
           status: SyncStatus
           last_sync: Optional[datetime] = None
           sources_synced: int = 0
           error_message: Optional[str] = None
           is_online: bool = True


       @dataclass
       class OfflineSyncConfig:
           """Configuration for offline sync."""
           chromadb_path: Path = field(default_factory=lambda: Path("./collections/chromadb"))
           metadata_collection: str = "sources_metadata"
           sync_interval_seconds: int = 300  # 5 minutes
           batch_size: int = 100


       class OfflineSyncManager:
           """
           Manages synchronization between PostgreSQL and ChromaDB.

           Provides:
           - Source metadata sync to ChromaDB
           - Online/offline state detection
           - Graceful degradation when database unavailable
           """
           pass  # Implementation in Task 2
       ```
  </action>
  <verify>
    python -c "from knowledge_mcp.sync import OfflineSyncManager, SyncStatus"
  </verify>
  <done>
    sync/ module created with __init__.py.
    SyncStatus enum and SyncState dataclass defined.
    OfflineSyncConfig dataclass with defaults.
    Module imports work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OfflineSyncManager</name>
  <files>src/knowledge_mcp/sync/offline.py</files>
  <action>
    Complete the OfflineSyncManager class in offline.py:

    ```python
    class OfflineSyncManager:
        """
        Manages synchronization between PostgreSQL and ChromaDB.

        Provides:
        - Source metadata sync to ChromaDB
        - Online/offline state detection
        - Graceful degradation when database unavailable
        """

        def __init__(self, config: Optional[OfflineSyncConfig] = None):
            """
            Initialize sync manager.

            Args:
                config: Sync configuration. Uses defaults if None.
            """
            self.config = config or OfflineSyncConfig()
            self._state = SyncState(status=SyncStatus.PENDING)
            self._chroma_client: Optional[Any] = None

        def _get_chroma_client(self):
            """Lazy-load ChromaDB client."""
            if self._chroma_client is None:
                import chromadb
                self._chroma_client = chromadb.PersistentClient(
                    path=str(self.config.chromadb_path)
                )
            return self._chroma_client

        def _get_metadata_collection(self):
            """Get or create metadata collection."""
            client = self._get_chroma_client()
            return client.get_or_create_collection(
                name=self.config.metadata_collection,
                metadata={"purpose": "offline_source_metadata"}
            )

        async def check_database_connection(self, session_factory) -> bool:
            """
            Check if PostgreSQL is accessible.

            Args:
                session_factory: Async session factory from db/engine.py

            Returns:
                True if database is accessible.
            """
            try:
                async with session_factory() as session:
                    from sqlalchemy import text
                    await session.execute(text("SELECT 1"))
                    return True
            except Exception as e:
                logger.warning(f"Database connection check failed: {e}")
                return False

        async def sync_sources(self, session: "AsyncSession") -> SyncState:
            """
            Sync source metadata from PostgreSQL to ChromaDB.

            Args:
                session: Active database session.

            Returns:
                Current sync state after operation.
            """
            from sqlalchemy import select
            from knowledge_mcp.db.models import Source

            try:
                # Query all sources
                stmt = select(Source).order_by(Source.id)
                result = await session.execute(stmt)
                sources = list(result.scalars().all())

                # Get ChromaDB collection
                collection = self._get_metadata_collection()

                # Sync in batches
                synced = 0
                for i in range(0, len(sources), self.config.batch_size):
                    batch = sources[i:i + self.config.batch_size]

                    # Prepare data for ChromaDB
                    ids = [f"source_{s.id}" for s in batch]
                    documents = [s.url for s in batch]  # URL as document
                    metadatas = [
                        {
                            "source_id": s.id,
                            "url": s.url,
                            "title": s.title or "",
                            "source_type": s.source_type.value if s.source_type else "",
                            "status": s.status.value if s.status else "",
                            "authority_tier": s.authority_tier.value if s.authority_tier else "",
                            "chunk_count": s.chunk_count or 0,
                            "synced_at": datetime.utcnow().isoformat(),
                        }
                        for s in batch
                    ]

                    # Upsert to ChromaDB
                    collection.upsert(
                        ids=ids,
                        documents=documents,
                        metadatas=metadatas,
                    )
                    synced += len(batch)

                self._state = SyncState(
                    status=SyncStatus.SYNCED,
                    last_sync=datetime.utcnow(),
                    sources_synced=synced,
                    is_online=True,
                )
                logger.info(f"Synced {synced} sources to ChromaDB")
                return self._state

            except Exception as e:
                self._state = SyncState(
                    status=SyncStatus.ERROR,
                    error_message=str(e),
                    is_online=False,
                )
                logger.error(f"Sync failed: {e}")
                return self._state

        def get_offline_sources(
            self,
            source_type: Optional[str] = None,
            authority_tier: Optional[str] = None,
            limit: int = 100,
        ) -> List[Dict[str, Any]]:
            """
            Query sources from ChromaDB offline store.

            Args:
                source_type: Filter by source type.
                authority_tier: Filter by authority tier.
                limit: Maximum results to return.

            Returns:
                List of source metadata dicts.
            """
            collection = self._get_metadata_collection()

            # Build where clause
            where = {}
            if source_type:
                where["source_type"] = source_type
            if authority_tier:
                where["authority_tier"] = authority_tier

            # Query ChromaDB
            results = collection.get(
                where=where if where else None,
                limit=limit,
                include=["metadatas", "documents"],
            )

            # Format results
            sources = []
            if results and results.get("metadatas"):
                for i, metadata in enumerate(results["metadatas"]):
                    sources.append({
                        "id": metadata.get("source_id"),
                        "url": metadata.get("url"),
                        "title": metadata.get("title"),
                        "source_type": metadata.get("source_type"),
                        "status": metadata.get("status"),
                        "authority_tier": metadata.get("authority_tier"),
                        "chunk_count": metadata.get("chunk_count"),
                    })

            return sources

        def get_state(self) -> SyncState:
            """Get current sync state."""
            return self._state

        def is_offline_mode(self) -> bool:
            """Check if operating in offline mode."""
            return not self._state.is_online
    ```

    AVOID: Syncing full relational data (relationships, complex queries).
    WHY: ChromaDB is optimized for vectors, not relational data (Pitfall #6 from research).
  </action>
  <verify>
    python -c "
    from knowledge_mcp.sync import OfflineSyncManager, SyncStatus
    mgr = OfflineSyncManager()
    print(f'Status: {mgr.get_state().status}')
    print(f'Offline: {mgr.is_offline_mode()}')
    "
    pyright src/knowledge_mcp/sync/offline.py
  </verify>
  <done>
    OfflineSyncManager with sync_sources(), get_offline_sources(), check_database_connection().
    SyncState tracks sync status, last sync time, error messages.
    ChromaDB stores minimal metadata (source_id, url, type, authority_tier).
    Offline queries work when PostgreSQL unavailable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for OfflineSyncManager</name>
  <files>tests/unit/test_sync/test_offline.py, tests/unit/test_sync/__init__.py</files>
  <action>
    Create tests/unit/test_sync/__init__.py (empty file).

    Create tests/unit/test_sync/test_offline.py:

    ```python
    """Unit tests for OfflineSyncManager."""

    from datetime import datetime
    from pathlib import Path
    from unittest.mock import AsyncMock, MagicMock, patch
    import pytest
    import tempfile

    from knowledge_mcp.sync.offline import (
        OfflineSyncManager,
        OfflineSyncConfig,
        SyncStatus,
        SyncState,
    )


    class TestSyncStatus:
        """Tests for SyncStatus enum."""

        def test_enum_values(self) -> None:
            """Test all status values exist."""
            assert SyncStatus.SYNCED == "synced"
            assert SyncStatus.PENDING == "pending"
            assert SyncStatus.OFFLINE == "offline"
            assert SyncStatus.ERROR == "error"


    class TestSyncState:
        """Tests for SyncState dataclass."""

        def test_default_values(self) -> None:
            """Test default state values."""
            state = SyncState(status=SyncStatus.PENDING)
            assert state.status == SyncStatus.PENDING
            assert state.last_sync is None
            assert state.sources_synced == 0
            assert state.is_online is True

        def test_custom_values(self) -> None:
            """Test state with custom values."""
            now = datetime.utcnow()
            state = SyncState(
                status=SyncStatus.SYNCED,
                last_sync=now,
                sources_synced=42,
                is_online=True,
            )
            assert state.sources_synced == 42
            assert state.last_sync == now


    class TestOfflineSyncConfig:
        """Tests for OfflineSyncConfig."""

        def test_default_values(self) -> None:
            """Test default configuration."""
            config = OfflineSyncConfig()
            assert config.metadata_collection == "sources_metadata"
            assert config.sync_interval_seconds == 300
            assert config.batch_size == 100

        def test_custom_values(self) -> None:
            """Test custom configuration."""
            config = OfflineSyncConfig(
                chromadb_path=Path("/tmp/test"),
                batch_size=50,
            )
            assert config.chromadb_path == Path("/tmp/test")
            assert config.batch_size == 50


    class TestOfflineSyncManager:
        """Tests for OfflineSyncManager class."""

        @pytest.fixture
        def temp_chromadb_path(self):
            """Create temporary directory for ChromaDB."""
            with tempfile.TemporaryDirectory() as tmpdir:
                yield Path(tmpdir)

        @pytest.fixture
        def manager(self, temp_chromadb_path: Path) -> OfflineSyncManager:
            """Create manager with temp storage."""
            config = OfflineSyncConfig(chromadb_path=temp_chromadb_path)
            return OfflineSyncManager(config)

        def test_init_default_config(self) -> None:
            """Test initialization with default config."""
            manager = OfflineSyncManager()
            assert manager.config is not None
            assert manager.get_state().status == SyncStatus.PENDING

        def test_init_custom_config(self, temp_chromadb_path: Path) -> None:
            """Test initialization with custom config."""
            config = OfflineSyncConfig(chromadb_path=temp_chromadb_path)
            manager = OfflineSyncManager(config)
            assert manager.config.chromadb_path == temp_chromadb_path

        def test_get_state(self, manager: OfflineSyncManager) -> None:
            """Test get_state returns current state."""
            state = manager.get_state()
            assert isinstance(state, SyncState)
            assert state.status == SyncStatus.PENDING

        def test_is_offline_mode_initially(self, manager: OfflineSyncManager) -> None:
            """Test is_offline_mode returns False initially."""
            # Initial state has is_online=True
            assert manager.is_offline_mode() is False

        @pytest.mark.asyncio
        async def test_check_database_connection_success(
            self, manager: OfflineSyncManager
        ) -> None:
            """Test database connection check succeeds."""
            # Mock session factory
            mock_session = AsyncMock()
            mock_session.execute = AsyncMock(return_value=MagicMock())

            mock_factory = MagicMock()
            mock_factory.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_factory.return_value.__aexit__ = AsyncMock(return_value=None)

            result = await manager.check_database_connection(mock_factory)
            assert result is True

        @pytest.mark.asyncio
        async def test_check_database_connection_failure(
            self, manager: OfflineSyncManager
        ) -> None:
            """Test database connection check fails gracefully."""
            # Mock session factory that raises
            mock_factory = MagicMock()
            mock_factory.return_value.__aenter__ = AsyncMock(
                side_effect=Exception("Connection refused")
            )

            result = await manager.check_database_connection(mock_factory)
            assert result is False

        def test_get_offline_sources_empty(
            self, manager: OfflineSyncManager
        ) -> None:
            """Test get_offline_sources with empty collection."""
            # Initialize collection
            manager._get_metadata_collection()

            sources = manager.get_offline_sources()
            assert sources == []

        def test_get_offline_sources_with_data(
            self, manager: OfflineSyncManager
        ) -> None:
            """Test get_offline_sources returns synced data."""
            # Manually add data to collection
            collection = manager._get_metadata_collection()
            collection.upsert(
                ids=["source_1"],
                documents=["https://example.com"],
                metadatas=[{
                    "source_id": 1,
                    "url": "https://example.com",
                    "title": "Test",
                    "source_type": "web",
                    "status": "complete",
                    "authority_tier": "tier2",
                    "chunk_count": 10,
                }],
            )

            sources = manager.get_offline_sources()
            assert len(sources) == 1
            assert sources[0]["url"] == "https://example.com"
            assert sources[0]["source_type"] == "web"

        def test_get_offline_sources_with_filter(
            self, manager: OfflineSyncManager
        ) -> None:
            """Test get_offline_sources with type filter."""
            collection = manager._get_metadata_collection()
            collection.upsert(
                ids=["source_1", "source_2"],
                documents=["https://web.com", "file://doc.pdf"],
                metadatas=[
                    {"source_id": 1, "url": "https://web.com", "source_type": "web", "authority_tier": "tier2", "title": "", "status": "", "chunk_count": 0},
                    {"source_id": 2, "url": "file://doc.pdf", "source_type": "document", "authority_tier": "tier1", "title": "", "status": "", "chunk_count": 0},
                ],
            )

            web_sources = manager.get_offline_sources(source_type="web")
            assert len(web_sources) == 1
            assert web_sources[0]["source_type"] == "web"
    ```

    AVOID: Testing actual PostgreSQL connections in unit tests.
    WHY: Unit tests should be fast and not depend on external services.
  </action>
  <verify>
    pytest tests/unit/test_sync/test_offline.py -v
  </verify>
  <done>
    Unit tests for SyncStatus, SyncState, OfflineSyncConfig, OfflineSyncManager.
    Tests cover initialization, state management, offline queries.
    All tests pass without external dependencies.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Imports work:**
   python -c "from knowledge_mcp.sync import OfflineSyncManager, SyncStatus"

2. **Type checking passes:**
   pyright src/knowledge_mcp/sync/

3. **Linting passes:**
   ruff check src/knowledge_mcp/sync/

4. **Unit tests pass:**
   pytest tests/unit/test_sync/ -v
</verification>

<success_criteria>
- [ ] sync/__init__.py exports OfflineSyncManager, SyncStatus
- [ ] SyncStatus enum with SYNCED, PENDING, OFFLINE, ERROR values
- [ ] SyncState dataclass with status, last_sync, sources_synced, error_message, is_online
- [ ] OfflineSyncConfig with chromadb_path, metadata_collection, sync_interval_seconds, batch_size
- [ ] OfflineSyncManager.sync_sources() syncs PostgreSQL sources to ChromaDB
- [ ] OfflineSyncManager.get_offline_sources() queries ChromaDB for offline data
- [ ] OfflineSyncManager.check_database_connection() tests PostgreSQL availability
- [ ] OfflineSyncManager.is_offline_mode() returns current online/offline state
- [ ] Unit tests pass
- [ ] All code passes pyright and ruff checks
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-acquisition/01-04-SUMMARY.md`
</output>
