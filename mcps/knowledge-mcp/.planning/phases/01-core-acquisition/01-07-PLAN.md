---
phase: 01-core-acquisition
plan: 07
type: execute
wave: 3
depends_on: ["01-03", "01-06"]
files_modified:
  - tests/integration/test_database.py
  - tests/unit/test_db/test_repositories.py
  - tests/unit/test_db/__init__.py
autonomous: true
user_setup:
  - service: postgresql
    why: "Database for integration tests"
    env_vars:
      - name: DATABASE_URL
        source: "Local PostgreSQL or Docker container"
    dashboard_config:
      - task: "Create test database"
        location: "psql or pgAdmin"

must_haves:
  truths:
    - "Repository unit tests pass with mocked sessions"
    - "Integration tests connect to real PostgreSQL"
    - "Migrations apply and rollback cleanly"
    - "Test coverage for db/ module >= 80%"
  artifacts:
    - path: "tests/unit/test_db/test_repositories.py"
      provides: "Repository unit tests"
      min_lines: 150
    - path: "tests/integration/test_database.py"
      provides: "Database integration tests"
      min_lines: 100
  key_links:
    - from: "tests/unit/test_db/test_repositories.py"
      to: "src/knowledge_mcp/db/repositories.py"
      via: "tests repository methods"
      pattern: "SourceRepository|AcquisitionRequestRepository"
---

<objective>
Add comprehensive tests for database layer: repository unit tests and integration tests for migrations and queries.

Purpose: Ensure db/ module meets 80% coverage requirement and migrations work correctly.
Output: Unit tests for repositories, integration tests for database operations.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Tests target these files
@src/knowledge_mcp/db/models.py
@src/knowledge_mcp/db/repositories.py
@src/knowledge_mcp/db/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repository unit tests</name>
  <files>tests/unit/test_db/__init__.py, tests/unit/test_db/test_repositories.py</files>
  <action>
    1. Create tests/unit/test_db/__init__.py (empty file).

    2. Create tests/unit/test_db/test_repositories.py:

    ```python
    """Unit tests for database repositories."""

    from datetime import datetime
    from unittest.mock import AsyncMock, MagicMock, patch
    import pytest

    from knowledge_mcp.db.models import (
        Source, SourceType, SourceStatus, AuthorityTier,
        AcquisitionRequest, AcquisitionRequestStatus,
    )
    from knowledge_mcp.db.repositories import (
        SourceRepository,
        AcquisitionRequestRepository,
    )


    class TestSourceRepository:
        """Tests for SourceRepository."""

        @pytest.fixture
        def mock_session(self) -> MagicMock:
            """Create mock async session."""
            session = MagicMock()
            session.add = MagicMock()
            session.flush = AsyncMock()
            session.execute = AsyncMock()
            return session

        @pytest.fixture
        def repo(self, mock_session: MagicMock) -> SourceRepository:
            """Create repository with mock session."""
            return SourceRepository(mock_session)

        @pytest.mark.asyncio
        async def test_create_source(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test creating a new source."""
            source = await repo.create(
                url="https://example.com",
                source_type=SourceType.WEB,
                title="Test",
                authority_tier=AuthorityTier.TIER2,
            )

            mock_session.add.assert_called_once()
            mock_session.flush.assert_awaited_once()

        @pytest.mark.asyncio
        async def test_get_by_id_found(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test getting source by ID when it exists."""
            mock_source = Source(
                id=1,
                url="https://example.com",
                source_type=SourceType.WEB,
            )
            mock_result = MagicMock()
            mock_result.scalar_one_or_none.return_value = mock_source
            mock_session.execute.return_value = mock_result

            source = await repo.get_by_id(1)

            assert source is not None
            assert source.id == 1

        @pytest.mark.asyncio
        async def test_get_by_id_not_found(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test getting source by ID when it doesn't exist."""
            mock_result = MagicMock()
            mock_result.scalar_one_or_none.return_value = None
            mock_session.execute.return_value = mock_result

            source = await repo.get_by_id(999)

            assert source is None

        @pytest.mark.asyncio
        async def test_get_by_url(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test getting source by URL."""
            mock_source = Source(
                id=1,
                url="https://example.com",
                source_type=SourceType.WEB,
            )
            mock_result = MagicMock()
            mock_result.scalar_one_or_none.return_value = mock_source
            mock_session.execute.return_value = mock_result

            source = await repo.get_by_url("https://example.com")

            assert source is not None
            assert source.url == "https://example.com"

        @pytest.mark.asyncio
        async def test_list_by_type(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test listing sources by type."""
            mock_sources = [
                Source(id=1, url="https://a.com", source_type=SourceType.WEB),
                Source(id=2, url="https://b.com", source_type=SourceType.WEB),
            ]
            mock_result = MagicMock()
            mock_result.scalars.return_value.all.return_value = mock_sources
            mock_session.execute.return_value = mock_result

            sources = await repo.list_by_type(SourceType.WEB)

            assert len(sources) == 2

        @pytest.mark.asyncio
        async def test_list_by_status(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test listing sources by status."""
            mock_sources = [
                Source(id=1, url="https://a.com", source_type=SourceType.WEB, status=SourceStatus.COMPLETE),
            ]
            mock_result = MagicMock()
            mock_result.scalars.return_value.all.return_value = mock_sources
            mock_session.execute.return_value = mock_result

            sources = await repo.list_by_status(SourceStatus.COMPLETE)

            assert len(sources) == 1

        @pytest.mark.asyncio
        async def test_update_status(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test updating source status."""
            await repo.update_status(
                source_id=1,
                status=SourceStatus.COMPLETE,
                chunk_count=10,
            )

            mock_session.execute.assert_awaited_once()

        @pytest.mark.asyncio
        async def test_update_status_with_error(
            self, repo: SourceRepository, mock_session: MagicMock
        ) -> None:
            """Test updating source status with error message."""
            await repo.update_status(
                source_id=1,
                status=SourceStatus.FAILED,
                error_message="Connection timeout",
            )

            mock_session.execute.assert_awaited_once()


    class TestAcquisitionRequestRepository:
        """Tests for AcquisitionRequestRepository."""

        @pytest.fixture
        def mock_session(self) -> MagicMock:
            """Create mock async session."""
            session = MagicMock()
            session.add = MagicMock()
            session.flush = AsyncMock()
            session.execute = AsyncMock()
            return session

        @pytest.fixture
        def repo(self, mock_session: MagicMock) -> AcquisitionRequestRepository:
            """Create repository with mock session."""
            return AcquisitionRequestRepository(mock_session)

        @pytest.mark.asyncio
        async def test_create_request(
            self, repo: AcquisitionRequestRepository, mock_session: MagicMock
        ) -> None:
            """Test creating acquisition request."""
            request = await repo.create(
                url="https://example.com",
                reason="Need documentation",
                priority=5,
            )

            mock_session.add.assert_called_once()
            mock_session.flush.assert_awaited_once()

        @pytest.mark.asyncio
        async def test_get_by_id(
            self, repo: AcquisitionRequestRepository, mock_session: MagicMock
        ) -> None:
            """Test getting request by ID."""
            mock_request = AcquisitionRequest(
                id=1,
                url="https://example.com",
            )
            mock_result = MagicMock()
            mock_result.scalar_one_or_none.return_value = mock_request
            mock_session.execute.return_value = mock_result

            request = await repo.get_by_id(1)

            assert request is not None
            assert request.id == 1

        @pytest.mark.asyncio
        async def test_list_pending(
            self, repo: AcquisitionRequestRepository, mock_session: MagicMock
        ) -> None:
            """Test listing pending requests."""
            mock_requests = [
                AcquisitionRequest(id=1, url="https://a.com", priority=10),
                AcquisitionRequest(id=2, url="https://b.com", priority=5),
            ]
            mock_result = MagicMock()
            mock_result.scalars.return_value.all.return_value = mock_requests
            mock_session.execute.return_value = mock_result

            requests = await repo.list_pending()

            assert len(requests) == 2

        @pytest.mark.asyncio
        async def test_update_status_completed(
            self, repo: AcquisitionRequestRepository, mock_session: MagicMock
        ) -> None:
            """Test marking request as completed."""
            await repo.update_status(
                request_id=1,
                status=AcquisitionRequestStatus.COMPLETED,
                source_id=42,
            )

            mock_session.execute.assert_awaited_once()

        @pytest.mark.asyncio
        async def test_update_status_failed(
            self, repo: AcquisitionRequestRepository, mock_session: MagicMock
        ) -> None:
            """Test marking request as failed."""
            await repo.update_status(
                request_id=1,
                status=AcquisitionRequestStatus.FAILED,
                error_message="Site blocked",
            )

            mock_session.execute.assert_awaited_once()
    ```
  </action>
  <verify>
    pytest tests/unit/test_db/test_repositories.py -v
  </verify>
  <done>
    Unit tests for SourceRepository and AcquisitionRequestRepository.
    Tests cover create, get, list, update operations.
    Tests use mocked AsyncSession (no database required).
    All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database integration tests</name>
  <files>tests/integration/test_database.py</files>
  <action>
    Create tests/integration/test_database.py:

    ```python
    """Integration tests for database layer.

    These tests require a PostgreSQL database.
    Set DATABASE_URL environment variable to run.

    Example:
        DATABASE_URL=postgresql+asyncpg://user:pass@localhost/test_knowledge_mcp pytest tests/integration/test_database.py
    """

    import os
    from datetime import datetime

    import pytest

    # Skip all tests if DATABASE_URL not set
    DATABASE_URL = os.getenv("DATABASE_URL", "")
    pytestmark = pytest.mark.skipif(
        not DATABASE_URL or not DATABASE_URL.startswith("postgresql"),
        reason="DATABASE_URL not set or not PostgreSQL"
    )


    @pytest.fixture(scope="module")
    async def engine_and_session():
        """Create engine and session factory for tests."""
        from knowledge_mcp.db.engine import create_engine_and_session_factory
        from knowledge_mcp.utils.config import KnowledgeConfig

        config = KnowledgeConfig(
            database_url=DATABASE_URL,
            database_pool_size=5,
            database_max_overflow=5,
        )

        engine, session_factory = create_engine_and_session_factory(config)

        yield engine, session_factory

        await engine.dispose()


    @pytest.fixture
    async def session(engine_and_session):
        """Create a session for each test."""
        _, session_factory = engine_and_session

        async with session_factory() as session:
            yield session
            await session.rollback()  # Rollback after each test


    class TestDatabaseConnection:
        """Test database connectivity."""

        @pytest.mark.asyncio
        async def test_connection_works(self, session) -> None:
            """Test basic database connection."""
            from sqlalchemy import text

            result = await session.execute(text("SELECT 1"))
            assert result.scalar() == 1

        @pytest.mark.asyncio
        async def test_tables_exist(self, session) -> None:
            """Test that migration tables exist."""
            from sqlalchemy import text

            # Check sources table
            result = await session.execute(text(
                "SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sources')"
            ))
            assert result.scalar() is True

            # Check acquisition_requests table
            result = await session.execute(text(
                "SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'acquisition_requests')"
            ))
            assert result.scalar() is True


    class TestSourceRepositoryIntegration:
        """Integration tests for SourceRepository."""

        @pytest.mark.asyncio
        async def test_create_and_get_source(self, session) -> None:
            """Test creating and retrieving a source."""
            from knowledge_mcp.db.models import SourceType, AuthorityTier
            from knowledge_mcp.db.repositories import SourceRepository

            repo = SourceRepository(session)

            # Create
            source = await repo.create(
                url=f"https://test-{datetime.utcnow().timestamp()}.com",
                source_type=SourceType.WEB,
                title="Test Source",
                authority_tier=AuthorityTier.TIER2,
            )

            assert source.id is not None

            # Get by ID
            retrieved = await repo.get_by_id(source.id)
            assert retrieved is not None
            assert retrieved.title == "Test Source"

        @pytest.mark.asyncio
        async def test_unique_url_constraint(self, session) -> None:
            """Test that duplicate URLs are rejected."""
            from sqlalchemy.exc import IntegrityError
            from knowledge_mcp.db.models import SourceType
            from knowledge_mcp.db.repositories import SourceRepository

            repo = SourceRepository(session)
            url = f"https://unique-{datetime.utcnow().timestamp()}.com"

            # First create succeeds
            await repo.create(url=url, source_type=SourceType.WEB)
            await session.flush()

            # Second create should fail
            with pytest.raises(IntegrityError):
                await repo.create(url=url, source_type=SourceType.WEB)
                await session.flush()


    class TestAcquisitionRequestRepositoryIntegration:
        """Integration tests for AcquisitionRequestRepository."""

        @pytest.mark.asyncio
        async def test_create_and_list_pending(self, session) -> None:
            """Test creating requests and listing pending."""
            from knowledge_mcp.db.repositories import AcquisitionRequestRepository

            repo = AcquisitionRequestRepository(session)

            # Create requests with different priorities
            await repo.create(
                url=f"https://low-{datetime.utcnow().timestamp()}.com",
                reason="Low priority",
                priority=1,
            )
            await repo.create(
                url=f"https://high-{datetime.utcnow().timestamp()}.com",
                reason="High priority",
                priority=10,
            )
            await session.flush()

            # List pending (should be ordered by priority desc)
            pending = await repo.list_pending()
            assert len(pending) >= 2

            # Highest priority first
            priorities = [p.priority for p in pending[:2]]
            assert priorities[0] >= priorities[1]


    class TestAlembicMigrations:
        """Test Alembic migrations."""

        @pytest.mark.asyncio
        async def test_current_revision(self, session) -> None:
            """Test that alembic_version table exists and has revision."""
            from sqlalchemy import text

            # Check alembic_version exists
            result = await session.execute(text(
                "SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'alembic_version')"
            ))
            assert result.scalar() is True

            # Check version is set
            result = await session.execute(text("SELECT version_num FROM alembic_version"))
            version = result.scalar()
            assert version is not None
    ```

    Note: These tests skip if DATABASE_URL is not set or not PostgreSQL.
  </action>
  <verify>
    # Without DATABASE_URL, tests skip
    pytest tests/integration/test_database.py -v

    # With DATABASE_URL, tests run (if available)
    # DATABASE_URL=postgresql+asyncpg://user:pass@localhost/test pytest tests/integration/test_database.py -v
  </verify>
  <done>
    Integration tests for database connectivity.
    Tests verify tables exist after migration.
    Tests for SourceRepository and AcquisitionRequestRepository.
    Tests skip gracefully when DATABASE_URL not set.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify test coverage for db/ module</name>
  <files>tests/unit/test_db/test_models.py, tests/unit/test_db/test_engine.py</files>
  <action>
    Add additional unit tests to ensure db/ module coverage:

    1. Create tests/unit/test_db/test_models.py:
    ```python
    """Unit tests for database models."""

    from datetime import datetime
    import pytest

    from knowledge_mcp.db.models import (
        Source, SourceType, SourceStatus, AuthorityTier,
        AcquisitionRequest, AcquisitionRequestStatus,
    )


    class TestSourceType:
        """Tests for SourceType enum."""

        def test_values(self) -> None:
            """Test all enum values exist."""
            assert SourceType.DOCUMENT == "document"
            assert SourceType.WEB == "web"
            assert SourceType.STANDARD == "standard"

        def test_from_string(self) -> None:
            """Test creating from string."""
            assert SourceType("web") == SourceType.WEB


    class TestSourceStatus:
        """Tests for SourceStatus enum."""

        def test_values(self) -> None:
            """Test all enum values exist."""
            assert SourceStatus.PENDING == "pending"
            assert SourceStatus.INGESTING == "ingesting"
            assert SourceStatus.COMPLETE == "complete"
            assert SourceStatus.FAILED == "failed"


    class TestAuthorityTier:
        """Tests for AuthorityTier enum."""

        def test_values(self) -> None:
            """Test all enum values exist."""
            assert AuthorityTier.TIER1 == "tier1"
            assert AuthorityTier.TIER2 == "tier2"
            assert AuthorityTier.TIER3 == "tier3"


    class TestAcquisitionRequestStatus:
        """Tests for AcquisitionRequestStatus enum."""

        def test_values(self) -> None:
            """Test all enum values exist."""
            assert AcquisitionRequestStatus.PENDING == "pending"
            assert AcquisitionRequestStatus.IN_PROGRESS == "in_progress"
            assert AcquisitionRequestStatus.COMPLETED == "completed"
            assert AcquisitionRequestStatus.FAILED == "failed"
            assert AcquisitionRequestStatus.CANCELLED == "cancelled"


    class TestSourceModel:
        """Tests for Source model."""

        def test_create_source(self) -> None:
            """Test Source model creation."""
            source = Source(
                url="https://example.com",
                source_type=SourceType.WEB,
            )
            assert source.url == "https://example.com"
            assert source.source_type == SourceType.WEB

        def test_default_values(self) -> None:
            """Test default values are set."""
            source = Source(
                url="https://example.com",
                source_type=SourceType.WEB,
            )
            assert source.status == SourceStatus.PENDING
            assert source.authority_tier == AuthorityTier.TIER3
            assert source.chunk_count == 0


    class TestAcquisitionRequestModel:
        """Tests for AcquisitionRequest model."""

        def test_create_request(self) -> None:
            """Test AcquisitionRequest model creation."""
            request = AcquisitionRequest(
                url="https://example.com",
                reason="Need this content",
                priority=5,
            )
            assert request.url == "https://example.com"
            assert request.reason == "Need this content"
            assert request.priority == 5

        def test_default_values(self) -> None:
            """Test default values are set."""
            request = AcquisitionRequest(url="https://example.com")
            assert request.status == AcquisitionRequestStatus.PENDING
            assert request.priority == 0
    ```

    2. Create tests/unit/test_db/test_engine.py:
    ```python
    """Unit tests for database engine module."""

    from unittest.mock import MagicMock, patch
    import pytest


    class TestCreateEngineAndSessionFactory:
        """Tests for engine creation."""

        def test_creates_engine_with_config(self) -> None:
            """Test engine is created with correct settings."""
            from knowledge_mcp.utils.config import KnowledgeConfig

            config = KnowledgeConfig(
                database_url="postgresql+asyncpg://user:pass@localhost/test",
                database_pool_size=20,
                database_max_overflow=10,
                database_echo=True,
            )

            with patch('knowledge_mcp.db.engine.create_async_engine') as mock_create:
                mock_engine = MagicMock()
                mock_create.return_value = mock_engine

                from knowledge_mcp.db.engine import create_engine_and_session_factory
                engine, factory = create_engine_and_session_factory(config)

                mock_create.assert_called_once()
                call_kwargs = mock_create.call_args.kwargs
                assert call_kwargs['pool_size'] == 20
                assert call_kwargs['max_overflow'] == 10
                assert call_kwargs['pool_pre_ping'] is True
                assert call_kwargs['echo'] is True


    class TestGetSession:
        """Tests for session context manager."""

        @pytest.mark.asyncio
        async def test_commits_on_success(self) -> None:
            """Test session commits on successful exit."""
            from unittest.mock import AsyncMock

            mock_session = AsyncMock()
            mock_factory = MagicMock()
            mock_factory.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_factory.return_value.__aexit__ = AsyncMock(return_value=None)

            from knowledge_mcp.db.engine import get_session

            async with get_session(mock_factory) as session:
                pass  # Success path

            mock_session.commit.assert_awaited_once()

        @pytest.mark.asyncio
        async def test_rollback_on_exception(self) -> None:
            """Test session rolls back on exception."""
            from unittest.mock import AsyncMock

            mock_session = AsyncMock()
            mock_factory = MagicMock()
            mock_factory.return_value.__aenter__ = AsyncMock(return_value=mock_session)
            mock_factory.return_value.__aexit__ = AsyncMock(return_value=None)

            from knowledge_mcp.db.engine import get_session

            with pytest.raises(ValueError):
                async with get_session(mock_factory) as session:
                    raise ValueError("Test error")

            mock_session.rollback.assert_awaited_once()
    ```

    Run coverage report:
    ```bash
    pytest tests/unit/test_db/ --cov=src/knowledge_mcp/db --cov-report=term-missing
    ```
  </action>
  <verify>
    pytest tests/unit/test_db/ -v --cov=src/knowledge_mcp/db --cov-report=term-missing
    # Should show >= 80% coverage for db/ module
  </verify>
  <done>
    Unit tests for all model enums and classes.
    Unit tests for engine creation and session management.
    Coverage for db/ module >= 80%.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Unit tests pass:**
   pytest tests/unit/test_db/ -v

2. **Integration tests skip gracefully (or pass with DB):**
   pytest tests/integration/test_database.py -v

3. **Coverage meets threshold:**
   pytest tests/unit/test_db/ --cov=src/knowledge_mcp/db --cov-report=term-missing
   # Should show >= 80%

4. **All tests together:**
   pytest tests/ -v --ignore=tests/integration
</verification>

<success_criteria>
- [ ] tests/unit/test_db/test_repositories.py with SourceRepository and AcquisitionRequestRepository tests
- [ ] tests/unit/test_db/test_models.py with enum and model tests
- [ ] tests/unit/test_db/test_engine.py with engine and session tests
- [ ] tests/integration/test_database.py with database connectivity tests
- [ ] Integration tests skip when DATABASE_URL not set
- [ ] All unit tests pass without database
- [ ] db/ module coverage >= 80%
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-acquisition/01-07-SUMMARY.md`
</output>
