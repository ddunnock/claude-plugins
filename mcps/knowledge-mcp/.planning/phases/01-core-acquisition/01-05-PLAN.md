---
phase: 01-core-acquisition
plan: 05
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/knowledge_mcp/search/coverage.py
  - src/knowledge_mcp/search/__init__.py
autonomous: true

must_haves:
  truths:
    - "Coverage assessment identifies knowledge gaps"
    - "Gaps reported with confidence scores"
    - "Low similarity scores indicate areas needing content"
    - "Assessment provides actionable recommendations"
  artifacts:
    - path: "src/knowledge_mcp/search/coverage.py"
      provides: "Coverage assessment algorithm"
      exports: ["CoverageAssessor", "CoverageGap", "CoverageReport"]
      min_lines: 150
  key_links:
    - from: "src/knowledge_mcp/search/coverage.py"
      to: "src/knowledge_mcp/search/semantic_search.py"
      via: "SemanticSearcher for content lookup"
      pattern: "SemanticSearcher"
    - from: "src/knowledge_mcp/search/coverage.py"
      to: "src/knowledge_mcp/embed"
      via: "Embedder for query embedding"
      pattern: "from.*embed import"
---

<objective>
Implement coverage assessment algorithm to identify knowledge gaps in the vector store.

Purpose: Enable knowledge gap detection (FR-2.4: Coverage assessment) to guide content acquisition.
Output: CoverageAssessor class that analyzes areas of low coverage and reports gaps with confidence scores.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-acquisition/01-RESEARCH.md

# Uses existing search infrastructure
@src/knowledge_mcp/search/semantic_search.py
@src/knowledge_mcp/embed/openai_embedder.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create coverage assessment module</name>
  <files>src/knowledge_mcp/search/coverage.py, src/knowledge_mcp/search/__init__.py</files>
  <action>
    Create src/knowledge_mcp/search/coverage.py:

    ```python
    """
    Coverage assessment for knowledge gaps.

    Uses semantic search to identify areas where knowledge base
    has low coverage, providing actionable gap reports.

    Based on semantic entropy approach from research:
    - Low similarity scores indicate sparse coverage
    - High entropy among results suggests uncertainty
    - Combines both signals for confidence scoring

    Example:
        >>> assessor = CoverageAssessor(searcher)
        >>> report = await assessor.assess(["system requirements", "trade studies"])
        >>> for gap in report.gaps:
        ...     print(f"{gap.area}: {gap.confidence:.2f}")
    """

    from __future__ import annotations

    import logging
    import math
    from dataclasses import dataclass, field
    from enum import Enum
    from typing import List, Optional, Dict, Any

    from knowledge_mcp.search import SemanticSearcher

    logger = logging.getLogger(__name__)


    class CoveragePriority(str, Enum):
        """Priority level for addressing gaps."""
        HIGH = "high"           # No content, urgent
        MEDIUM = "medium"       # Some content, improvement needed
        LOW = "low"             # Adequate, optional enhancement
        SUFFICIENT = "sufficient"  # Good coverage, no action needed


    @dataclass
    class CoverageGap:
        """A detected knowledge gap."""
        area: str                    # Knowledge area queried
        priority: CoveragePriority   # How urgent to address
        confidence: float            # 0-1, how certain we are this is a gap
        reason: str                  # Human-readable explanation
        max_similarity: float        # Best match score found
        result_count: int            # How many results returned
        suggested_query: Optional[str] = None  # Suggested search for acquisition


    @dataclass
    class CoveredArea:
        """An adequately covered knowledge area."""
        area: str
        chunk_count: int
        avg_similarity: float
        best_match_title: Optional[str] = None


    @dataclass
    class CoverageReport:
        """Complete coverage assessment report."""
        gaps: List[CoverageGap] = field(default_factory=list)
        covered: List[CoveredArea] = field(default_factory=list)
        total_areas: int = 0
        coverage_ratio: float = 0.0
        overall_priority: CoveragePriority = CoveragePriority.SUFFICIENT

        def to_dict(self) -> Dict[str, Any]:
            """Convert to dictionary for JSON serialization."""
            return {
                "gaps": [
                    {
                        "area": g.area,
                        "priority": g.priority.value,
                        "confidence": round(g.confidence, 3),
                        "reason": g.reason,
                        "max_similarity": round(g.max_similarity, 3),
                        "result_count": g.result_count,
                        "suggested_query": g.suggested_query,
                    }
                    for g in self.gaps
                ],
                "covered": [
                    {
                        "area": c.area,
                        "chunk_count": c.chunk_count,
                        "avg_similarity": round(c.avg_similarity, 3),
                        "best_match_title": c.best_match_title,
                    }
                    for c in self.covered
                ],
                "summary": {
                    "total_areas": self.total_areas,
                    "coverage_ratio": round(self.coverage_ratio, 3),
                    "gaps_count": len(self.gaps),
                    "covered_count": len(self.covered),
                    "overall_priority": self.overall_priority.value,
                },
            }


    @dataclass
    class CoverageConfig:
        """Configuration for coverage assessment."""
        similarity_threshold: float = 0.5    # Below this = gap
        high_confidence_threshold: float = 0.3  # Below this = high priority
        min_results_for_coverage: int = 3    # Need at least this many results
        n_results: int = 10                  # Results to fetch per area
        entropy_weight: float = 0.3          # Weight of entropy in confidence


    class CoverageAssessor:
        """
        Assesses knowledge coverage and identifies gaps.

        Uses semantic search to probe coverage in specified areas.
        Calculates confidence using similarity scores and entropy.

        Example:
            >>> searcher = SemanticSearcher(embedder, store)
            >>> assessor = CoverageAssessor(searcher)
            >>> report = await assessor.assess(["requirements management"])
        """

        def __init__(
            self,
            searcher: SemanticSearcher,
            config: Optional[CoverageConfig] = None,
        ):
            """
            Initialize coverage assessor.

            Args:
                searcher: SemanticSearcher instance for queries.
                config: Assessment configuration.
            """
            self.searcher = searcher
            self.config = config or CoverageConfig()

        async def assess(self, knowledge_areas: List[str]) -> CoverageReport:
            """
            Assess coverage for specified knowledge areas.

            Args:
                knowledge_areas: List of topics/areas to check.

            Returns:
                CoverageReport with gaps and covered areas.
            """
            gaps: List[CoverageGap] = []
            covered: List[CoveredArea] = []

            for area in knowledge_areas:
                gap, covered_area = await self._assess_area(area)
                if gap:
                    gaps.append(gap)
                if covered_area:
                    covered.append(covered_area)

            # Calculate overall stats
            total = len(knowledge_areas)
            coverage_ratio = len(covered) / total if total > 0 else 0.0

            # Determine overall priority
            high_priority_gaps = sum(1 for g in gaps if g.priority == CoveragePriority.HIGH)
            if high_priority_gaps > total * 0.5:
                overall_priority = CoveragePriority.HIGH
            elif len(gaps) > len(covered):
                overall_priority = CoveragePriority.MEDIUM
            elif gaps:
                overall_priority = CoveragePriority.LOW
            else:
                overall_priority = CoveragePriority.SUFFICIENT

            return CoverageReport(
                gaps=gaps,
                covered=covered,
                total_areas=total,
                coverage_ratio=coverage_ratio,
                overall_priority=overall_priority,
            )

        async def _assess_area(
            self, area: str
        ) -> tuple[Optional[CoverageGap], Optional[CoveredArea]]:
            """
            Assess a single knowledge area.

            Returns tuple of (gap, covered_area) - one will be None.
            """
            try:
                # Search for content in this area
                results = await self.searcher.search(
                    query=area,
                    n_results=self.config.n_results,
                )

                # No results = definite gap
                if not results:
                    return CoverageGap(
                        area=area,
                        priority=CoveragePriority.HIGH,
                        confidence=1.0,
                        reason="No content found",
                        max_similarity=0.0,
                        result_count=0,
                        suggested_query=f"'{area}' documentation OR tutorial OR guide",
                    ), None

                # Extract similarity scores
                similarities = [r.score for r in results]
                max_sim = max(similarities)
                avg_sim = sum(similarities) / len(similarities)

                # Calculate entropy (uncertainty)
                entropy = self._calculate_entropy(similarities)

                # Determine if this is a gap
                if max_sim < self.config.similarity_threshold:
                    # Low similarity = gap
                    confidence = self._calculate_gap_confidence(
                        max_sim, entropy, len(results)
                    )
                    priority = self._determine_priority(max_sim, confidence)

                    return CoverageGap(
                        area=area,
                        priority=priority,
                        confidence=confidence,
                        reason=f"Low relevance scores (max: {max_sim:.2f})",
                        max_similarity=max_sim,
                        result_count=len(results),
                        suggested_query=f"'{area}' best practices OR standards",
                    ), None

                # Adequate coverage
                best_match = results[0]
                return None, CoveredArea(
                    area=area,
                    chunk_count=len(results),
                    avg_similarity=avg_sim,
                    best_match_title=best_match.document_title,
                )

            except Exception as e:
                logger.warning(f"Error assessing area '{area}': {e}")
                # Return as gap with error reason
                return CoverageGap(
                    area=area,
                    priority=CoveragePriority.MEDIUM,
                    confidence=0.5,
                    reason=f"Assessment error: {str(e)}",
                    max_similarity=0.0,
                    result_count=0,
                ), None

        def _calculate_entropy(self, similarities: List[float]) -> float:
            """
            Calculate Shannon entropy of similarity distribution.

            Higher entropy = more uncertainty = likely gap.
            """
            if not similarities or len(similarities) < 2:
                return 0.0

            # Normalize to probabilities
            total = sum(similarities)
            if total == 0:
                return 1.0  # Max entropy if no signal

            probs = [s / total for s in similarities]

            # Shannon entropy
            entropy = 0.0
            for p in probs:
                if p > 0:
                    entropy -= p * math.log2(p)

            # Normalize to 0-1 (max entropy for n items is log2(n))
            max_entropy = math.log2(len(similarities))
            return entropy / max_entropy if max_entropy > 0 else 0.0

        def _calculate_gap_confidence(
            self, max_sim: float, entropy: float, result_count: int
        ) -> float:
            """
            Calculate confidence that this is a genuine gap.

            Combines:
            - Low similarity (inverted)
            - High entropy (uncertainty)
            - Low result count
            """
            # Similarity component: lower = more confident it's a gap
            sim_component = 1.0 - (max_sim / self.config.similarity_threshold)
            sim_component = max(0.0, min(1.0, sim_component))

            # Entropy component: higher = more uncertain = more likely gap
            entropy_component = entropy

            # Result count component: fewer results = more confident gap
            count_component = 1.0 - (result_count / self.config.n_results)
            count_component = max(0.0, min(1.0, count_component))

            # Weighted combination
            confidence = (
                sim_component * 0.5 +
                entropy_component * self.config.entropy_weight +
                count_component * (0.5 - self.config.entropy_weight)
            )

            return min(1.0, confidence)

        def _determine_priority(
            self, max_sim: float, confidence: float
        ) -> CoveragePriority:
            """Determine gap priority based on metrics."""
            if max_sim < self.config.high_confidence_threshold:
                return CoveragePriority.HIGH
            elif confidence > 0.7:
                return CoveragePriority.HIGH
            elif confidence > 0.4:
                return CoveragePriority.MEDIUM
            else:
                return CoveragePriority.LOW


    async def assess_knowledge_coverage(
        searcher: SemanticSearcher,
        areas: List[str],
        config: Optional[CoverageConfig] = None,
    ) -> CoverageReport:
        """
        Convenience function for coverage assessment.

        Args:
            searcher: SemanticSearcher instance.
            areas: Knowledge areas to assess.
            config: Optional configuration.

        Returns:
            CoverageReport with results.
        """
        assessor = CoverageAssessor(searcher, config)
        return await assessor.assess(areas)
    ```

    Update src/knowledge_mcp/search/__init__.py to add exports:
    ```python
    from .coverage import (
        CoverageAssessor,
        CoverageConfig,
        CoverageGap,
        CoverageReport,
        CoveragePriority,
        assess_knowledge_coverage,
    )
    ```
  </action>
  <verify>
    python -c "from knowledge_mcp.search import CoverageAssessor, CoverageReport, CoveragePriority"
    pyright src/knowledge_mcp/search/coverage.py
    ruff check src/knowledge_mcp/search/coverage.py
  </verify>
  <done>
    CoverageAssessor class with assess() method.
    CoverageGap, CoveredArea, CoverageReport dataclasses.
    Entropy-based confidence scoring.
    Priority determination (HIGH/MEDIUM/LOW/SUFFICIENT).
    Convenience function assess_knowledge_coverage().
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for coverage assessment</name>
  <files>tests/unit/test_search/test_coverage.py</files>
  <action>
    Create tests/unit/test_search/test_coverage.py:

    ```python
    """Unit tests for coverage assessment."""

    from unittest.mock import AsyncMock, MagicMock
    import pytest

    from knowledge_mcp.search.coverage import (
        CoverageAssessor,
        CoverageConfig,
        CoverageGap,
        CoveredArea,
        CoverageReport,
        CoveragePriority,
        assess_knowledge_coverage,
    )
    from knowledge_mcp.search.models import SearchResult


    class TestCoveragePriority:
        """Tests for CoveragePriority enum."""

        def test_enum_values(self) -> None:
            """Test priority values."""
            assert CoveragePriority.HIGH == "high"
            assert CoveragePriority.MEDIUM == "medium"
            assert CoveragePriority.LOW == "low"
            assert CoveragePriority.SUFFICIENT == "sufficient"


    class TestCoverageGap:
        """Tests for CoverageGap dataclass."""

        def test_creation(self) -> None:
            """Test gap creation."""
            gap = CoverageGap(
                area="test area",
                priority=CoveragePriority.HIGH,
                confidence=0.9,
                reason="No content",
                max_similarity=0.1,
                result_count=0,
            )
            assert gap.area == "test area"
            assert gap.priority == CoveragePriority.HIGH
            assert gap.confidence == 0.9


    class TestCoverageReport:
        """Tests for CoverageReport dataclass."""

        def test_to_dict(self) -> None:
            """Test serialization to dict."""
            report = CoverageReport(
                gaps=[
                    CoverageGap(
                        area="gap1",
                        priority=CoveragePriority.HIGH,
                        confidence=0.8,
                        reason="No content",
                        max_similarity=0.0,
                        result_count=0,
                    )
                ],
                covered=[
                    CoveredArea(
                        area="covered1",
                        chunk_count=5,
                        avg_similarity=0.75,
                    )
                ],
                total_areas=2,
                coverage_ratio=0.5,
            )

            d = report.to_dict()
            assert d["summary"]["total_areas"] == 2
            assert d["summary"]["coverage_ratio"] == 0.5
            assert len(d["gaps"]) == 1
            assert len(d["covered"]) == 1


    class TestCoverageConfig:
        """Tests for CoverageConfig."""

        def test_default_values(self) -> None:
            """Test default configuration."""
            config = CoverageConfig()
            assert config.similarity_threshold == 0.5
            assert config.n_results == 10

        def test_custom_values(self) -> None:
            """Test custom configuration."""
            config = CoverageConfig(similarity_threshold=0.7, n_results=20)
            assert config.similarity_threshold == 0.7
            assert config.n_results == 20


    class TestCoverageAssessor:
        """Tests for CoverageAssessor class."""

        @pytest.fixture
        def mock_searcher(self) -> MagicMock:
            """Create mock searcher."""
            searcher = MagicMock()
            searcher.search = AsyncMock()
            return searcher

        @pytest.fixture
        def assessor(self, mock_searcher: MagicMock) -> CoverageAssessor:
            """Create assessor with mock searcher."""
            return CoverageAssessor(mock_searcher)

        @pytest.mark.asyncio
        async def test_assess_empty_areas(self, assessor: CoverageAssessor) -> None:
            """Test assessment with no areas."""
            report = await assessor.assess([])
            assert report.total_areas == 0
            assert report.coverage_ratio == 0.0
            assert len(report.gaps) == 0

        @pytest.mark.asyncio
        async def test_assess_no_results_is_gap(
            self, assessor: CoverageAssessor, mock_searcher: MagicMock
        ) -> None:
            """Test that no results means gap."""
            mock_searcher.search.return_value = []

            report = await assessor.assess(["nonexistent topic"])

            assert len(report.gaps) == 1
            assert report.gaps[0].area == "nonexistent topic"
            assert report.gaps[0].priority == CoveragePriority.HIGH
            assert report.gaps[0].confidence == 1.0
            assert "No content found" in report.gaps[0].reason

        @pytest.mark.asyncio
        async def test_assess_high_similarity_is_covered(
            self, assessor: CoverageAssessor, mock_searcher: MagicMock
        ) -> None:
            """Test that high similarity means covered."""
            mock_searcher.search.return_value = [
                SearchResult(
                    content="Relevant content",
                    score=0.85,
                    document_title="Good Doc",
                    document_type="standard",
                    section_title="Section",
                    chunk_type="paragraph",
                    section_hierarchy="",
                    clause_number="",
                    page_numbers=[],
                    normative=True,
                )
            ]

            report = await assessor.assess(["well covered topic"])

            assert len(report.covered) == 1
            assert len(report.gaps) == 0
            assert report.covered[0].area == "well covered topic"
            assert report.covered[0].avg_similarity == 0.85

        @pytest.mark.asyncio
        async def test_assess_low_similarity_is_gap(
            self, assessor: CoverageAssessor, mock_searcher: MagicMock
        ) -> None:
            """Test that low similarity means gap."""
            mock_searcher.search.return_value = [
                SearchResult(
                    content="Vaguely related",
                    score=0.2,
                    document_title="Some Doc",
                    document_type="article",
                    section_title="Section",
                    chunk_type="paragraph",
                    section_hierarchy="",
                    clause_number="",
                    page_numbers=[],
                    normative=False,
                )
            ]

            report = await assessor.assess(["poorly covered topic"])

            assert len(report.gaps) == 1
            assert report.gaps[0].area == "poorly covered topic"
            assert "Low relevance" in report.gaps[0].reason

        def test_calculate_entropy_empty(self, assessor: CoverageAssessor) -> None:
            """Test entropy with empty list."""
            entropy = assessor._calculate_entropy([])
            assert entropy == 0.0

        def test_calculate_entropy_single(self, assessor: CoverageAssessor) -> None:
            """Test entropy with single value."""
            entropy = assessor._calculate_entropy([0.5])
            assert entropy == 0.0

        def test_calculate_entropy_uniform(self, assessor: CoverageAssessor) -> None:
            """Test entropy with uniform distribution."""
            # Uniform distribution has max entropy
            entropy = assessor._calculate_entropy([0.25, 0.25, 0.25, 0.25])
            assert entropy > 0.9  # Should be close to 1.0

        def test_calculate_entropy_concentrated(self, assessor: CoverageAssessor) -> None:
            """Test entropy with concentrated distribution."""
            # One dominant value has low entropy
            entropy = assessor._calculate_entropy([0.9, 0.05, 0.03, 0.02])
            assert entropy < 0.5

        def test_determine_priority_very_low_similarity(
            self, assessor: CoverageAssessor
        ) -> None:
            """Test HIGH priority for very low similarity."""
            priority = assessor._determine_priority(0.1, 0.5)
            assert priority == CoveragePriority.HIGH

        def test_determine_priority_high_confidence(
            self, assessor: CoverageAssessor
        ) -> None:
            """Test HIGH priority for high confidence gap."""
            priority = assessor._determine_priority(0.4, 0.8)
            assert priority == CoveragePriority.HIGH

        def test_determine_priority_medium(
            self, assessor: CoverageAssessor
        ) -> None:
            """Test MEDIUM priority."""
            priority = assessor._determine_priority(0.4, 0.5)
            assert priority == CoveragePriority.MEDIUM


    class TestAssessKnowledgeCoverage:
        """Tests for convenience function."""

        @pytest.mark.asyncio
        async def test_function_creates_assessor(self) -> None:
            """Test function creates assessor and runs."""
            mock_searcher = MagicMock()
            mock_searcher.search = AsyncMock(return_value=[])

            report = await assess_knowledge_coverage(
                mock_searcher, ["test area"]
            )

            assert isinstance(report, CoverageReport)
            assert report.total_areas == 1
    ```
  </action>
  <verify>
    pytest tests/unit/test_search/test_coverage.py -v
  </verify>
  <done>
    Unit tests for all coverage classes and functions.
    Tests cover edge cases (empty, single, uniform distributions).
    Tests verify priority determination logic.
    All tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Imports work:**
   python -c "from knowledge_mcp.search import CoverageAssessor, CoverageReport, assess_knowledge_coverage"

2. **Type checking passes:**
   pyright src/knowledge_mcp/search/coverage.py

3. **Linting passes:**
   ruff check src/knowledge_mcp/search/coverage.py

4. **Unit tests pass:**
   pytest tests/unit/test_search/test_coverage.py -v
</verification>

<success_criteria>
- [ ] CoverageAssessor class with assess() method
- [ ] CoverageGap dataclass with area, priority, confidence, reason, max_similarity
- [ ] CoveredArea dataclass with area, chunk_count, avg_similarity
- [ ] CoverageReport with gaps, covered, coverage_ratio, to_dict()
- [ ] CoveragePriority enum (HIGH, MEDIUM, LOW, SUFFICIENT)
- [ ] Entropy-based confidence calculation
- [ ] Priority determination based on similarity and confidence
- [ ] assess_knowledge_coverage() convenience function
- [ ] Unit tests pass
- [ ] All code passes pyright and ruff checks
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-acquisition/01-05-SUMMARY.md`
</output>
