---
phase: 05-extended-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_mcp/cli/main.py
  - src/knowledge_mcp/cli/ingest.py
  - src/knowledge_mcp/cli/__init__.py
  - src/knowledge_mcp/__main__.py
  - pyproject.toml
  - tests/unit/test_cli/test_ingest.py
autonomous: true

must_haves:
  truths:
    - "`knowledge ingest docs <path>` CLI command ingests documents"
    - "CLI shows progress bar during ingestion"
    - "CLI reports success with chunk count"
    - "Invalid paths produce helpful error messages"
  artifacts:
    - path: "src/knowledge_mcp/cli/main.py"
      provides: "Typer app instance with subcommand registration"
      exports: ["app", "cli"]
    - path: "src/knowledge_mcp/cli/ingest.py"
      provides: "Ingest subcommand group"
      exports: ["ingest_app", "ingest_docs"]
    - path: "tests/unit/test_cli/test_ingest.py"
      provides: "CLI ingest tests with CliRunner"
      min_lines: 50
  key_links:
    - from: "src/knowledge_mcp/cli/main.py"
      to: "src/knowledge_mcp/cli/ingest.py"
      via: "app.add_typer(ingest_app)"
      pattern: "add_typer.*ingest"
    - from: "src/knowledge_mcp/cli/ingest.py"
      to: "src/knowledge_mcp/ingest/pipeline.py"
      via: "IngestionPipeline().ingest()"
      pattern: "IngestionPipeline"
    - from: "pyproject.toml"
      to: "src/knowledge_mcp/cli/main.py"
      via: "poetry script entry point"
      pattern: 'knowledge = "knowledge_mcp.cli.main:cli"'
---

<objective>
Implement Typer-based CLI framework with `knowledge ingest docs <path>` command.

Purpose: Provide user-friendly CLI for document ingestion, extensible for v2 `ingest web` command.
Output: Working CLI that ingests documents with progress bars and helpful error messages.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-extended-features/05-CONTEXT.md
@.planning/phases/05-extended-features/05-RESEARCH.md
@src/knowledge_mcp/cli/__init__.py
@src/knowledge_mcp/__main__.py
@src/knowledge_mcp/ingest/pipeline.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Typer dependency and create CLI framework</name>
  <files>
    pyproject.toml
    src/knowledge_mcp/cli/main.py
    src/knowledge_mcp/cli/__init__.py
    src/knowledge_mcp/__main__.py
  </files>
  <action>
1. Update pyproject.toml:
   - Add `typer = ">=0.12.0"` to main dependencies (after `tenacity`)
   - Update poetry script: change `knowledge-mcp = "knowledge_mcp.__main__:cli"` to `knowledge = "knowledge_mcp.cli.main:cli"`
   - Keep `knowledge-ingest = "knowledge_mcp.cli.ingest:main"` for backwards compatibility

2. Create src/knowledge_mcp/cli/main.py:
   ```python
   """Main CLI application for Knowledge MCP."""
   import typer

   app = typer.Typer(
       name="knowledge",
       no_args_is_help=True,
       help="Knowledge MCP - Semantic search over technical documents",
   )

   # Subcommand registration will be added here

   def cli() -> None:
       """CLI entry point."""
       app()

   if __name__ == "__main__":
       cli()
   ```

3. Update src/knowledge_mcp/cli/__init__.py:
   - Export `app` and `cli` from main.py
   - Update __all__ list

4. Update src/knowledge_mcp/__main__.py:
   - Change to import and call cli() from cli.main
   - Keep the asyncio.run(server_main()) path as a `serve` subcommand for later
   - For now, just call cli() directly
  </action>
  <verify>
    `poetry install` succeeds and `poetry run knowledge --help` shows help text with app name
  </verify>
  <done>Typer framework installed, `knowledge` CLI entry point works, shows help with no args</done>
</task>

<task type="auto">
  <name>Task 2: Implement ingest docs subcommand</name>
  <files>
    src/knowledge_mcp/cli/ingest.py
    src/knowledge_mcp/cli/main.py
  </files>
  <action>
1. Create src/knowledge_mcp/cli/ingest.py with complete implementation:

```python
"""Ingest subcommand group for document ingestion."""
from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING

import typer
from rich.console import Console
from rich.progress import track

from knowledge_mcp.ingest.pipeline import IngestionPipeline
from knowledge_mcp.exceptions import IngestionError

if TYPE_CHECKING:
    from knowledge_mcp.models.chunk import KnowledgeChunk

ingest_app = typer.Typer(help="Document ingestion commands")
console = Console()

SUPPORTED_EXTENSIONS = {".pdf", ".docx"}


@ingest_app.command("docs")
def ingest_docs(
    path: Path = typer.Argument(
        ...,
        help="Path to document file or directory",
        exists=True,
        resolve_path=True,
    ),
    collection: str = typer.Option(
        "knowledge",
        "--collection", "-c",
        help="Vector store collection name",
    ),
    recursive: bool = typer.Option(
        False,
        "--recursive", "-r",
        help="Recursively process directories",
    ),
) -> None:
    """Ingest local documents into the knowledge base."""
    # Collect files to process
    files: list[Path] = []
    if path.is_file():
        if path.suffix.lower() in SUPPORTED_EXTENSIONS:
            files.append(path)
        else:
            console.print(
                f"[red]Error:[/red] Unsupported file type: {path.suffix}. "
                f"Supported: {', '.join(SUPPORTED_EXTENSIONS)}"
            )
            raise typer.Exit(1)
    else:
        # Directory - glob for supported files
        pattern = "**/*" if recursive else "*"
        for ext in SUPPORTED_EXTENSIONS:
            files.extend(path.glob(f"{pattern}{ext}"))

    if not files:
        console.print(
            f"[yellow]Warning:[/yellow] No PDF or DOCX files found in {path}"
        )
        raise typer.Exit(0)

    console.print(f"\n[bold]Ingesting {len(files)} document(s)...[/bold]\n")

    # Initialize pipeline
    pipeline = IngestionPipeline()

    # Track results
    total_chunks = 0
    successful = 0
    failed: list[tuple[Path, str]] = []

    # Process files with progress bar
    for file_path in track(files, description="Processing..."):
        try:
            chunks: list[KnowledgeChunk] = pipeline.ingest(file_path)
            total_chunks += len(chunks)
            successful += 1
            console.print(f"  [green]OK[/green] {file_path.name}: {len(chunks)} chunks")
        except IngestionError as e:
            failed.append((file_path, str(e)))
            console.print(f"  [red]FAIL[/red] {file_path.name}: {e}")
        except Exception as e:
            failed.append((file_path, str(e)))
            console.print(f"  [red]FAIL[/red] {file_path.name}: {e}")

    # Summary
    console.print(f"\n[bold]Summary:[/bold]")
    console.print(f"  Processed: {successful}/{len(files)} documents")
    console.print(f"  Total chunks: {total_chunks}")

    if failed:
        console.print(f"\n[red]Failed files ({len(failed)}):[/red]")
        for fp, err in failed:
            console.print(f"  - {fp.name}: {err}")
        raise typer.Exit(1)

    console.print(f"\n[green]Ingestion complete.[/green]")


def main() -> None:
    """Backwards-compatible entry point."""
    ingest_app()
```

2. Update src/knowledge_mcp/cli/main.py to register the ingest subcommand:

```python
"""Main CLI application for Knowledge MCP."""
import typer

from knowledge_mcp.cli.ingest import ingest_app

app = typer.Typer(
    name="knowledge",
    no_args_is_help=True,
    help="Knowledge MCP - Semantic search over technical documents",
)

# Register ingest subcommand group
app.add_typer(ingest_app, name="ingest")


def cli() -> None:
    """CLI entry point."""
    app()


if __name__ == "__main__":
    cli()
```
  </action>
  <verify>
    - `poetry run knowledge ingest --help` shows ingest subcommands
    - `poetry run knowledge ingest docs --help` shows docs command help
    - `poetry run knowledge ingest docs /nonexistent` shows error about path not existing
  </verify>
  <done>
    - `knowledge ingest docs <path>` processes PDF/DOCX files
    - Progress bar shows during multi-file ingestion
    - Invalid paths produce contextual error messages
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CLI tests with CliRunner</name>
  <files>
    tests/unit/test_cli/__init__.py
    tests/unit/test_cli/test_ingest.py
  </files>
  <action>
1. Create tests/unit/test_cli/__init__.py (empty)

2. Create tests/unit/test_cli/test_ingest.py:
   ```python
   """Unit tests for ingest CLI commands."""
   from pathlib import Path
   from unittest.mock import MagicMock, patch

   import pytest
   from typer.testing import CliRunner

   from knowledge_mcp.cli.main import app

   runner = CliRunner()

   class TestIngestDocs:
       """Tests for knowledge ingest docs command."""

       def test_ingest_docs_help(self) -> None:
           """Test help message displays."""
           result = runner.invoke(app, ["ingest", "docs", "--help"])
           assert result.exit_code == 0
           assert "Ingest local documents" in result.stdout

       def test_ingest_docs_nonexistent_path(self, tmp_path: Path) -> None:
           """Test error on nonexistent path."""
           result = runner.invoke(app, ["ingest", "docs", str(tmp_path / "nope")])
           assert result.exit_code != 0
           # Typer shows path validation error

       def test_ingest_docs_empty_directory(self, tmp_path: Path) -> None:
           """Test warning on empty directory."""
           result = runner.invoke(app, ["ingest", "docs", str(tmp_path)])
           assert "No PDF or DOCX files" in result.stdout or result.exit_code == 0

       @patch("knowledge_mcp.cli.ingest.IngestionPipeline")
       def test_ingest_docs_success(
           self,
           mock_pipeline_cls: MagicMock,
           tmp_path: Path,
       ) -> None:
           """Test successful file ingestion."""
           # Create test file
           test_pdf = tmp_path / "test.pdf"
           test_pdf.touch()

           # Mock pipeline
           mock_pipeline = MagicMock()
           mock_pipeline.ingest.return_value = [MagicMock(), MagicMock()]  # 2 chunks
           mock_pipeline_cls.return_value = mock_pipeline

           result = runner.invoke(app, ["ingest", "docs", str(test_pdf)])

           assert result.exit_code == 0
           mock_pipeline.ingest.assert_called_once()
   ```

3. Test cases to cover:
   - Help text displays correctly
   - Nonexistent path produces error
   - Empty directory produces warning
   - Single file ingestion (mocked pipeline)
   - Directory with multiple files (mocked pipeline)
   - Error in one file doesn't stop others
  </action>
  <verify>
    `poetry run pytest tests/unit/test_cli/test_ingest.py -v` passes
  </verify>
  <done>
    - All CLI tests pass
    - Tests cover help, error cases, and success cases
    - Pipeline is mocked to avoid real file processing
  </done>
</task>

</tasks>

<verification>
1. `poetry install` completes successfully
2. `poetry run knowledge --help` shows "Knowledge MCP" help
3. `poetry run knowledge ingest docs --help` shows ingest command help
4. `poetry run pytest tests/unit/test_cli/ -v` passes all tests
5. `poetry run pyright src/knowledge_mcp/cli/` reports no errors
</verification>

<success_criteria>
- `knowledge ingest docs <path>` CLI command exists and shows help
- CLI framework uses Typer with subcommand pattern
- Tests cover help, error handling, and success cases
- pyright passes on new CLI code
</success_criteria>

<output>
After completion, create `.planning/phases/05-extended-features/05-01-SUMMARY.md`
</output>
