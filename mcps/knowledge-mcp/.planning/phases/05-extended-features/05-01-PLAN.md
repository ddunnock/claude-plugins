---
phase: 05-extended-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_mcp/cli/main.py
  - src/knowledge_mcp/cli/ingest.py
  - src/knowledge_mcp/cli/__init__.py
  - src/knowledge_mcp/__main__.py
  - pyproject.toml
  - tests/unit/test_cli/test_ingest.py
autonomous: true

must_haves:
  truths:
    - "`knowledge ingest docs <path>` CLI command ingests documents"
    - "CLI shows progress bar during ingestion"
    - "CLI reports success with chunk count"
    - "Invalid paths produce helpful error messages"
  artifacts:
    - path: "src/knowledge_mcp/cli/main.py"
      provides: "Typer app instance with subcommand registration"
      exports: ["app", "cli"]
    - path: "src/knowledge_mcp/cli/ingest.py"
      provides: "Ingest subcommand group"
      exports: ["ingest_app", "ingest_docs"]
    - path: "tests/unit/test_cli/test_ingest.py"
      provides: "CLI ingest tests with CliRunner"
      min_lines: 50
  key_links:
    - from: "src/knowledge_mcp/cli/main.py"
      to: "src/knowledge_mcp/cli/ingest.py"
      via: "app.add_typer(ingest_app)"
      pattern: "add_typer.*ingest"
    - from: "src/knowledge_mcp/cli/ingest.py"
      to: "src/knowledge_mcp/ingest/pipeline.py"
      via: "IngestionPipeline().ingest()"
      pattern: "IngestionPipeline"
    - from: "pyproject.toml"
      to: "src/knowledge_mcp/cli/main.py"
      via: "poetry script entry point"
      pattern: 'knowledge = "knowledge_mcp.cli.main:cli"'
---

<objective>
Implement Typer-based CLI framework with `knowledge ingest docs <path>` command.

Purpose: Provide user-friendly CLI for document ingestion, extensible for v2 `ingest web` command.
Output: Working CLI that ingests documents with progress bars and helpful error messages.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-extended-features/05-CONTEXT.md
@.planning/phases/05-extended-features/05-RESEARCH.md
@src/knowledge_mcp/cli/__init__.py
@src/knowledge_mcp/__main__.py
@src/knowledge_mcp/ingest/pipeline.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Typer dependency and create CLI framework</name>
  <files>
    pyproject.toml
    src/knowledge_mcp/cli/main.py
    src/knowledge_mcp/cli/__init__.py
    src/knowledge_mcp/__main__.py
  </files>
  <action>
1. Update pyproject.toml:
   - Add `typer = ">=0.12.0"` to main dependencies (after `tenacity`)
   - Update poetry script: change `knowledge-mcp = "knowledge_mcp.__main__:cli"` to `knowledge = "knowledge_mcp.cli.main:cli"`
   - Keep `knowledge-ingest = "knowledge_mcp.cli.ingest:main"` for backwards compatibility

2. Create src/knowledge_mcp/cli/main.py:
   ```python
   """Main CLI application for Knowledge MCP."""
   import typer

   app = typer.Typer(
       name="knowledge",
       no_args_is_help=True,
       help="Knowledge MCP - Semantic search over technical documents",
   )

   # Subcommand registration will be added here

   def cli() -> None:
       """CLI entry point."""
       app()

   if __name__ == "__main__":
       cli()
   ```

3. Update src/knowledge_mcp/cli/__init__.py:
   - Export `app` and `cli` from main.py
   - Update __all__ list

4. Update src/knowledge_mcp/__main__.py:
   - Change to import and call cli() from cli.main
   - Keep the asyncio.run(server_main()) path as a `serve` subcommand for later
   - For now, just call cli() directly
  </action>
  <verify>
    `poetry install` succeeds and `poetry run knowledge --help` shows help text with app name
  </verify>
  <done>Typer framework installed, `knowledge` CLI entry point works, shows help with no args</done>
</task>

<task type="auto">
  <name>Task 2: Implement ingest docs subcommand</name>
  <files>
    src/knowledge_mcp/cli/ingest.py
    src/knowledge_mcp/cli/main.py
  </files>
  <action>
1. Create src/knowledge_mcp/cli/ingest.py:
   ```python
   """Ingest subcommand group for document ingestion."""
   from pathlib import Path
   import typer
   from rich.progress import track
   from rich.console import Console

   ingest_app = typer.Typer(help="Document ingestion commands")
   console = Console()

   @ingest_app.command("docs")
   def ingest_docs(
       path: Path = typer.Argument(
           ...,
           help="Path to document file or directory",
           exists=True,  # Typer validates path exists
           resolve_path=True,
       ),
       collection: str = typer.Option(
           "knowledge",
           "--collection", "-c",
           help="Vector store collection name",
       ),
       recursive: bool = typer.Option(
           False,
           "--recursive", "-r",
           help="Recursively process directories",
       ),
   ) -> None:
       """Ingest local documents into the knowledge base."""
       # Implementation details:
       # 1. Detect file vs directory
       # 2. Collect supported files (.pdf, .docx)
       # 3. Use IngestionPipeline to process each
       # 4. Show progress bar with rich.progress.track
       # 5. Report summary (files processed, chunks created)
   ```

2. Key implementation details:
   - If path is file: process single file
   - If path is directory: glob for .pdf and .docx files
   - Use `track()` for progress bar over files
   - Catch IngestionError per file, continue with others, report at end
   - Use Console for styled output (green success, red errors)
   - Report total: "Ingested X documents (Y chunks)"

3. Error handling:
   - FileNotFoundError: "Error: Path not found: {path}" (Typer's exists=True handles this)
   - No supported files found: "Warning: No PDF or DOCX files found in {path}"
   - IngestionError: Log error, continue, report failures at end

4. Update src/knowledge_mcp/cli/main.py:
   - Import ingest_app from ingest module
   - Register with `app.add_typer(ingest_app, name="ingest")`
  </action>
  <verify>
    - `poetry run knowledge ingest --help` shows ingest subcommands
    - `poetry run knowledge ingest docs --help` shows docs command help
    - `poetry run knowledge ingest docs /nonexistent` shows error about path not existing
  </verify>
  <done>
    - `knowledge ingest docs <path>` processes PDF/DOCX files
    - Progress bar shows during multi-file ingestion
    - Invalid paths produce contextual error messages
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CLI tests with CliRunner</name>
  <files>
    tests/unit/test_cli/__init__.py
    tests/unit/test_cli/test_ingest.py
  </files>
  <action>
1. Create tests/unit/test_cli/__init__.py (empty)

2. Create tests/unit/test_cli/test_ingest.py:
   ```python
   """Unit tests for ingest CLI commands."""
   from pathlib import Path
   from unittest.mock import MagicMock, patch

   import pytest
   from typer.testing import CliRunner

   from knowledge_mcp.cli.main import app

   runner = CliRunner()

   class TestIngestDocs:
       """Tests for knowledge ingest docs command."""

       def test_ingest_docs_help(self) -> None:
           """Test help message displays."""
           result = runner.invoke(app, ["ingest", "docs", "--help"])
           assert result.exit_code == 0
           assert "Ingest local documents" in result.stdout

       def test_ingest_docs_nonexistent_path(self, tmp_path: Path) -> None:
           """Test error on nonexistent path."""
           result = runner.invoke(app, ["ingest", "docs", str(tmp_path / "nope")])
           assert result.exit_code != 0
           # Typer shows path validation error

       def test_ingest_docs_empty_directory(self, tmp_path: Path) -> None:
           """Test warning on empty directory."""
           result = runner.invoke(app, ["ingest", "docs", str(tmp_path)])
           assert "No PDF or DOCX files" in result.stdout or result.exit_code == 0

       @patch("knowledge_mcp.cli.ingest.IngestionPipeline")
       def test_ingest_docs_success(
           self,
           mock_pipeline_cls: MagicMock,
           tmp_path: Path,
       ) -> None:
           """Test successful file ingestion."""
           # Create test file
           test_pdf = tmp_path / "test.pdf"
           test_pdf.touch()

           # Mock pipeline
           mock_pipeline = MagicMock()
           mock_pipeline.ingest.return_value = [MagicMock(), MagicMock()]  # 2 chunks
           mock_pipeline_cls.return_value = mock_pipeline

           result = runner.invoke(app, ["ingest", "docs", str(test_pdf)])

           assert result.exit_code == 0
           mock_pipeline.ingest.assert_called_once()
   ```

3. Test cases to cover:
   - Help text displays correctly
   - Nonexistent path produces error
   - Empty directory produces warning
   - Single file ingestion (mocked pipeline)
   - Directory with multiple files (mocked pipeline)
   - Error in one file doesn't stop others
  </action>
  <verify>
    `poetry run pytest tests/unit/test_cli/test_ingest.py -v` passes
  </verify>
  <done>
    - All CLI tests pass
    - Tests cover help, error cases, and success cases
    - Pipeline is mocked to avoid real file processing
  </done>
</task>

</tasks>

<verification>
1. `poetry install` completes successfully
2. `poetry run knowledge --help` shows "Knowledge MCP" help
3. `poetry run knowledge ingest docs --help` shows ingest command help
4. `poetry run pytest tests/unit/test_cli/ -v` passes all tests
5. `poetry run pyright src/knowledge_mcp/cli/` reports no errors
</verification>

<success_criteria>
- `knowledge ingest docs <path>` CLI command exists and shows help
- CLI framework uses Typer with subcommand pattern
- Tests cover help, error handling, and success cases
- pyright passes on new CLI code
</success_criteria>

<output>
After completion, create `.planning/phases/05-extended-features/05-01-SUMMARY.md`
</output>
