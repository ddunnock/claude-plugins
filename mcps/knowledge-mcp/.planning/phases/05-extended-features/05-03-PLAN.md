---
phase: 05-extended-features
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/knowledge_mcp/search/reranker.py
  - src/knowledge_mcp/search/__init__.py
  - src/knowledge_mcp/cli/verify.py
  - src/knowledge_mcp/cli/main.py
  - pyproject.toml
  - tests/unit/test_search/test_reranker.py
  - tests/unit/test_cli/test_verify.py
autonomous: true

must_haves:
  truths:
    - "Reranker improves search result relevance ordering"
    - "Cohere reranking works when API key available"
    - "Local cross-encoder fallback works without API key"
    - "`knowledge verify` validates collection health"
  artifacts:
    - path: "src/knowledge_mcp/search/reranker.py"
      provides: "Reranker with Cohere and local cross-encoder support"
      exports: ["Reranker"]
      min_lines: 100
    - path: "src/knowledge_mcp/cli/verify.py"
      provides: "Verify CLI command"
      exports: ["verify_command"]
      min_lines: 40
    - path: "tests/unit/test_search/test_reranker.py"
      provides: "Reranker unit tests"
      min_lines: 80
  key_links:
    - from: "src/knowledge_mcp/search/reranker.py"
      to: "cohere"
      via: "cohere.ClientV2 for Cohere reranking"
      pattern: "cohere\\.ClientV2"
    - from: "src/knowledge_mcp/search/reranker.py"
      to: "sentence_transformers"
      via: "CrossEncoder for local fallback"
      pattern: "CrossEncoder"
    - from: "src/knowledge_mcp/cli/main.py"
      to: "src/knowledge_mcp/cli/verify.py"
      via: "app.command() registration"
      pattern: "verify_command"
---

<objective>
Implement result reranking and `knowledge verify` CLI command.

Purpose: Improve search quality via reranking; provide CLI to validate collection health and embeddings.
Output: Working Reranker (Cohere + local fallback) and verify command for collection validation.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-extended-features/05-CONTEXT.md
@.planning/phases/05-extended-features/05-RESEARCH.md
@.planning/phases/05-extended-features/05-01-SUMMARY.md
@src/knowledge_mcp/search/models.py
@src/knowledge_mcp/search/semantic_search.py
@src/knowledge_mcp/cli/main.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Reranker class</name>
  <files>
    src/knowledge_mcp/search/reranker.py
    src/knowledge_mcp/search/__init__.py
    pyproject.toml
  </files>
  <action>
1. Update pyproject.toml:
   - Update cohere version in rerank group: `cohere = ">=5.11.0"` (for v2 API)

2. Create src/knowledge_mcp/search/reranker.py:
   ```python
   """Result reranking using Cohere API or local cross-encoder.

   Provides relevance-based reranking to improve search result quality.
   Uses Cohere Rerank API when available, falls back to local cross-encoder.

   Example:
       >>> reranker = Reranker(provider="cohere", api_key="...")
       >>> reranked = await reranker.rerank(query, results, top_n=5)
   """
   from __future__ import annotations

   import asyncio
   import logging
   from typing import TYPE_CHECKING

   if TYPE_CHECKING:
       from knowledge_mcp.search.models import SearchResult

   logger = logging.getLogger(__name__)

   class Reranker:
       """Rerank search results using Cohere or local cross-encoder."""

       def __init__(
           self,
           provider: str = "cohere",
           api_key: str | None = None,
           model: str | None = None,
       ) -> None:
           """Initialize reranker.

           Args:
               provider: "cohere" or "local"
               api_key: Cohere API key (required if provider="cohere")
               model: Model name (defaults: rerank-english-v3.0 for Cohere,
                      cross-encoder/ms-marco-MiniLM-L6-v2 for local)
           """
           self._provider = provider
           self._client: Any = None
           self._model: Any = None
           self._model_name: str = ""

           if provider == "cohere":
               import cohere
               if not api_key:
                   raise ValueError("api_key required for Cohere provider")
               self._client = cohere.ClientV2(api_key=api_key)
               self._model_name = model or "rerank-english-v3.0"
           else:  # local
               from sentence_transformers import CrossEncoder
               self._model_name = model or "cross-encoder/ms-marco-MiniLM-L6-v2"
               self._model = CrossEncoder(self._model_name)

       async def rerank(
           self,
           query: str,
           results: list[SearchResult],
           top_n: int | None = None,
       ) -> list[SearchResult]:
           """Rerank results by relevance.

           Args:
               query: Search query
               results: Results from semantic search
               top_n: Return top N after reranking (None = all)

           Returns:
               Reranked results with updated scores
           """
           if not results:
               return results

           if self._provider == "cohere":
               return await self._rerank_cohere(query, results, top_n)
           else:
               return await self._rerank_local(query, results, top_n)

       async def _rerank_cohere(
           self,
           query: str,
           results: list[SearchResult],
           top_n: int | None,
       ) -> list[SearchResult]:
           """Rerank using Cohere API."""
           documents = [r.content for r in results]

           # Cohere client is sync, run in executor
           loop = asyncio.get_running_loop()
           response = await loop.run_in_executor(
               None,
               lambda: self._client.rerank(
                   model=self._model_name,
                   query=query,
                   documents=documents,
                   top_n=top_n or len(documents),
               ),
           )

           # Map back to SearchResult objects with updated scores
           reranked: list[SearchResult] = []
           for item in response.results:
               original = results[item.index]
               # Create new SearchResult with updated score
               reranked.append(SearchResult(
                   id=original.id,
                   content=original.content,
                   score=item.relevance_score,
                   metadata=original.metadata,
                   document_id=original.document_id,
                   document_title=original.document_title,
                   document_type=original.document_type,
                   section_title=original.section_title,
                   section_hierarchy=original.section_hierarchy,
                   chunk_type=original.chunk_type,
                   normative=original.normative,
                   clause_number=original.clause_number,
                   page_numbers=original.page_numbers,
               ))

           return reranked

       async def _rerank_local(
           self,
           query: str,
           results: list[SearchResult],
           top_n: int | None,
       ) -> list[SearchResult]:
           """Rerank using local cross-encoder."""
           pairs = [(query, r.content) for r in results]

           # CrossEncoder.predict is sync, run in executor
           loop = asyncio.get_running_loop()
           scores = await loop.run_in_executor(
               None,
               self._model.predict,
               pairs,
           )

           # Create new results with updated scores and sort
           reranked: list[SearchResult] = []
           for result, score in zip(results, scores):
               reranked.append(SearchResult(
                   id=result.id,
                   content=result.content,
                   score=float(score),
                   metadata=result.metadata,
                   document_id=result.document_id,
                   document_title=result.document_title,
                   document_type=result.document_type,
                   section_title=result.section_title,
                   section_hierarchy=result.section_hierarchy,
                   chunk_type=result.chunk_type,
                   normative=result.normative,
                   clause_number=result.clause_number,
                   page_numbers=result.page_numbers,
               ))

           # Sort by score descending
           reranked.sort(key=lambda r: r.score, reverse=True)

           if top_n:
               return reranked[:top_n]
           return reranked
   ```

3. Key implementation details from RESEARCH.md:
   - Use cohere.ClientV2 (not Client) for v2 API
   - Wrap sync API calls with run_in_executor
   - Create NEW SearchResult objects (dataclass is immutable by intent)
   - Handle rate limits via tenacity retry (optional enhancement)

4. Update src/knowledge_mcp/search/__init__.py:
   - Add conditional import of Reranker
   - Update __all__
  </action>
  <verify>
    `poetry install --with rerank --with local && poetry run python -c "from knowledge_mcp.search import Reranker; print('OK')"`
  </verify>
  <done>
    - Reranker supports both Cohere and local cross-encoder
    - Async methods don't block event loop
    - Returns reranked results with updated scores
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement verify CLI command</name>
  <files>
    src/knowledge_mcp/cli/verify.py
    src/knowledge_mcp/cli/main.py
  </files>
  <action>
1. Create src/knowledge_mcp/cli/verify.py:
   ```python
   """Verify command for collection health checks."""
   from __future__ import annotations

   import typer
   from rich.console import Console
   from rich.table import Table

   console = Console()

   def verify_command(
       collection: str = typer.Option(
           "knowledge",
           "--collection", "-c",
           help="Collection name to verify",
       ),
       check_embeddings: bool = typer.Option(
           False,
           "--embeddings", "-e",
           help="Verify embedding dimensions match",
       ),
   ) -> None:
       """Validate collection health and embeddings.

       Checks:
       - Collection exists and is accessible
       - Document and chunk counts
       - Embedding dimensions (if --embeddings flag)
       """
       import asyncio
       from knowledge_mcp.utils.config import Config

       # Load config
       config = Config.from_env()

       # Run async verification
       asyncio.run(_verify_async(collection, check_embeddings, config))

   async def _verify_async(
       collection: str,
       check_embeddings: bool,
       config: Any,
   ) -> None:
       """Async verification logic."""
       from knowledge_mcp.store import create_store

       console.print(f"\n[bold]Verifying collection:[/bold] {collection}\n")

       try:
           # Create store
           store = create_store(config, collection_name=collection)

           # Get collection stats
           stats = store.get_collection_stats()

           # Display stats table
           table = Table(title="Collection Statistics")
           table.add_column("Metric", style="cyan")
           table.add_column("Value", justify="right")

           table.add_row("Collection", collection)
           table.add_row("Total Chunks", str(stats.get("total_points", "N/A")))
           table.add_row("Unique Documents", str(stats.get("unique_documents", "N/A")))
           table.add_row("Vector Dimensions", str(stats.get("vector_dimensions", "N/A")))

           console.print(table)

           # Check embedding dimensions if requested
           if check_embeddings:
               console.print("\n[bold]Embedding Verification:[/bold]")
               # Sample a few vectors and check dimensions match config
               expected_dims = config.embedding_dimensions
               actual_dims = stats.get("vector_dimensions")

               if actual_dims == expected_dims:
                   console.print(f"[green]OK[/green] Dimensions match ({actual_dims})")
               else:
                   console.print(
                       f"[red]MISMATCH[/red] Expected {expected_dims}, found {actual_dims}"
                   )

           console.print("\n[green]Verification complete.[/green]")

       except Exception as e:
           console.print(f"\n[red]Error:[/red] {e}")
           raise typer.Exit(1)
   ```

2. Update src/knowledge_mcp/cli/main.py:
   - Import verify_command from verify module
   - Register with `app.command("verify")(verify_command)`

3. Verification checks:
   - Collection exists and is accessible
   - Returns chunk count and document count
   - Optionally validates embedding dimensions
   - Reports any errors clearly
  </action>
  <verify>
    `poetry run knowledge verify --help` shows verify command help
  </verify>
  <done>
    - `knowledge verify` command checks collection health
    - Shows chunk count, document count, dimensions
    - --embeddings flag validates dimension consistency
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Reranker and verify tests</name>
  <files>
    tests/unit/test_search/test_reranker.py
    tests/unit/test_cli/test_verify.py
  </files>
  <action>
1. Create tests/unit/test_search/test_reranker.py:
   ```python
   """Unit tests for Reranker."""
   from unittest.mock import MagicMock, patch
   import pytest

   from knowledge_mcp.search.models import SearchResult

   def make_result(id: str, content: str, score: float) -> SearchResult:
       """Helper to create SearchResult."""
       return SearchResult(id=id, content=content, score=score)

   class TestReranker:
       """Tests for Reranker class."""

       @pytest.fixture
       def mock_cohere(self) -> MagicMock:
           """Mock Cohere client."""
           client = MagicMock()
           return client

       @pytest.fixture
       def mock_cross_encoder(self) -> MagicMock:
           """Mock CrossEncoder."""
           model = MagicMock()
           return model

       @patch("knowledge_mcp.search.reranker.cohere")
       def test_cohere_init_requires_api_key(self, mock_cohere: MagicMock) -> None:
           """Test Cohere provider requires API key."""
           from knowledge_mcp.search.reranker import Reranker

           with pytest.raises(ValueError, match="api_key required"):
               Reranker(provider="cohere")

       @patch("knowledge_mcp.search.reranker.cohere")
       def test_cohere_init_with_api_key(self, mock_cohere: MagicMock) -> None:
           """Test Cohere provider initializes with API key."""
           from knowledge_mcp.search.reranker import Reranker

           reranker = Reranker(provider="cohere", api_key="test-key")
           assert reranker._provider == "cohere"
           mock_cohere.ClientV2.assert_called_once_with(api_key="test-key")

       @patch("knowledge_mcp.search.reranker.CrossEncoder")
       def test_local_init(self, mock_ce_cls: MagicMock) -> None:
           """Test local provider initializes cross-encoder."""
           from knowledge_mcp.search.reranker import Reranker

           reranker = Reranker(provider="local")
           assert reranker._provider == "local"
           mock_ce_cls.assert_called_once()

       @patch("knowledge_mcp.search.reranker.CrossEncoder")
       @pytest.mark.asyncio
       async def test_rerank_empty_results(self, mock_ce_cls: MagicMock) -> None:
           """Test rerank returns empty list for empty input."""
           from knowledge_mcp.search.reranker import Reranker

           reranker = Reranker(provider="local")
           result = await reranker.rerank("query", [])
           assert result == []

       @patch("knowledge_mcp.search.reranker.CrossEncoder")
       @pytest.mark.asyncio
       async def test_rerank_local_sorts_by_score(self, mock_ce_cls: MagicMock) -> None:
           """Test local reranking sorts results by score."""
           mock_model = MagicMock()
           mock_model.predict.return_value = [0.8, 0.3, 0.9]  # Second highest, lowest, highest
           mock_ce_cls.return_value = mock_model

           from knowledge_mcp.search.reranker import Reranker

           reranker = Reranker(provider="local")
           results = [
               make_result("1", "content 1", 0.5),
               make_result("2", "content 2", 0.6),
               make_result("3", "content 3", 0.4),
           ]

           reranked = await reranker.rerank("query", results)

           # Should be sorted by new scores: 0.9, 0.8, 0.3
           assert reranked[0].id == "3"  # score 0.9
           assert reranked[1].id == "1"  # score 0.8
           assert reranked[2].id == "2"  # score 0.3

       @patch("knowledge_mcp.search.reranker.CrossEncoder")
       @pytest.mark.asyncio
       async def test_rerank_top_n(self, mock_ce_cls: MagicMock) -> None:
           """Test top_n limits returned results."""
           mock_model = MagicMock()
           mock_model.predict.return_value = [0.8, 0.3, 0.9]
           mock_ce_cls.return_value = mock_model

           from knowledge_mcp.search.reranker import Reranker

           reranker = Reranker(provider="local")
           results = [
               make_result("1", "content 1", 0.5),
               make_result("2", "content 2", 0.6),
               make_result("3", "content 3", 0.4),
           ]

           reranked = await reranker.rerank("query", results, top_n=2)

           assert len(reranked) == 2
   ```

2. Create tests/unit/test_cli/test_verify.py:
   ```python
   """Unit tests for verify CLI command."""
   from unittest.mock import MagicMock, patch

   import pytest
   from typer.testing import CliRunner

   from knowledge_mcp.cli.main import app

   runner = CliRunner()

   class TestVerifyCommand:
       """Tests for knowledge verify command."""

       def test_verify_help(self) -> None:
           """Test help message displays."""
           result = runner.invoke(app, ["verify", "--help"])
           assert result.exit_code == 0
           assert "Validate collection health" in result.stdout

       @patch("knowledge_mcp.cli.verify.Config")
       @patch("knowledge_mcp.cli.verify.create_store")
       def test_verify_success(
           self,
           mock_create_store: MagicMock,
           mock_config: MagicMock,
       ) -> None:
           """Test successful verification."""
           mock_store = MagicMock()
           mock_store.get_collection_stats.return_value = {
               "total_points": 100,
               "unique_documents": 5,
               "vector_dimensions": 1536,
           }
           mock_create_store.return_value = mock_store
           mock_config.from_env.return_value = MagicMock()

           result = runner.invoke(app, ["verify"])

           assert result.exit_code == 0
           assert "100" in result.stdout  # total points
   ```
  </action>
  <verify>
    - `poetry run pytest tests/unit/test_search/test_reranker.py -v` passes
    - `poetry run pytest tests/unit/test_cli/test_verify.py -v` passes
  </verify>
  <done>
    - Reranker tests cover Cohere and local providers
    - Verify command tests cover help and success cases
    - All tests pass
  </done>
</task>

</tasks>

<verification>
1. `poetry install --with rerank --with local` completes successfully
2. `from knowledge_mcp.search import Reranker` works
3. `poetry run knowledge verify --help` shows command help
4. `poetry run pytest tests/unit/test_search/test_reranker.py tests/unit/test_cli/test_verify.py -v` passes
5. `poetry run pyright src/knowledge_mcp/search/reranker.py src/knowledge_mcp/cli/verify.py` reports no errors
</verification>

<success_criteria>
- Reranker supports Cohere and local cross-encoder
- `knowledge verify` validates collection health
- All tests pass
- pyright passes on new code
</success_criteria>

<output>
After completion, create `.planning/phases/05-extended-features/05-03-SUMMARY.md`
</output>
