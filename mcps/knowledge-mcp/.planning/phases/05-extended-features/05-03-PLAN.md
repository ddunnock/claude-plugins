---
phase: 05-extended-features
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_mcp/search/reranker.py
  - src/knowledge_mcp/search/__init__.py
  - pyproject.toml
  - tests/unit/test_search/test_reranker.py
autonomous: true

must_haves:
  truths:
    - "Reranker reorders search results by relevance score"
    - "Cohere reranking works when API key available"
    - "Local cross-encoder fallback works without API key"
    - "Reranked results have different order than original when relevant"
  artifacts:
    - path: "src/knowledge_mcp/search/reranker.py"
      provides: "Reranker with Cohere and local cross-encoder support"
      exports: ["Reranker"]
      min_lines: 100
    - path: "tests/unit/test_search/test_reranker.py"
      provides: "Reranker unit tests including reorder verification"
      min_lines: 80
  key_links:
    - from: "src/knowledge_mcp/search/reranker.py"
      to: "cohere"
      via: "cohere.ClientV2 for Cohere reranking"
      pattern: "cohere\\.ClientV2"
    - from: "src/knowledge_mcp/search/reranker.py"
      to: "sentence_transformers"
      via: "CrossEncoder for local fallback"
      pattern: "CrossEncoder"
    - from: "src/knowledge_mcp/search/reranker.py"
      to: "dataclasses"
      via: "dataclasses.replace for immutable updates"
      pattern: "replace\\(.*score="
---

<objective>
Implement result reranking using Cohere API or local cross-encoder.

Purpose: Improve search quality by reordering semantic search results based on query relevance.
Output: Working Reranker class supporting both Cohere and local cross-encoder backends.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-extended-features/05-CONTEXT.md
@.planning/phases/05-extended-features/05-RESEARCH.md
@src/knowledge_mcp/search/models.py
@src/knowledge_mcp/search/semantic_search.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Reranker class with dataclasses.replace</name>
  <files>
    src/knowledge_mcp/search/reranker.py
    src/knowledge_mcp/search/__init__.py
    pyproject.toml
  </files>
  <action>
1. Update pyproject.toml:
   - Update cohere version in rerank group: `cohere = ">=5.11.0"` (for v2 API)

2. Create src/knowledge_mcp/search/reranker.py using dataclasses.replace() for immutable SearchResult updates:

```python
"""Result reranking using Cohere API or local cross-encoder.

Provides relevance-based reranking to improve search result quality.
Uses Cohere Rerank API when available, falls back to local cross-encoder.

Example:
    >>> reranker = Reranker(provider="cohere", api_key="...")
    >>> reranked = await reranker.rerank(query, results, top_n=5)
"""
from __future__ import annotations

import asyncio
import logging
from dataclasses import replace
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from knowledge_mcp.search.models import SearchResult

logger = logging.getLogger(__name__)


class Reranker:
    """Rerank search results using Cohere or local cross-encoder."""

    def __init__(
        self,
        provider: str = "cohere",
        api_key: str | None = None,
        model: str | None = None,
    ) -> None:
        """Initialize reranker.

        Args:
            provider: "cohere" or "local"
            api_key: Cohere API key (required if provider="cohere")
            model: Model name (defaults: rerank-english-v3.0 for Cohere,
                   cross-encoder/ms-marco-MiniLM-L6-v2 for local)
        """
        self._provider = provider
        self._client: Any = None
        self._model: Any = None
        self._model_name: str = ""

        if provider == "cohere":
            import cohere
            if not api_key:
                raise ValueError("api_key required for Cohere provider")
            self._client = cohere.ClientV2(api_key=api_key)
            self._model_name = model or "rerank-english-v3.0"
        else:  # local
            from sentence_transformers import CrossEncoder
            self._model_name = model or "cross-encoder/ms-marco-MiniLM-L6-v2"
            self._model = CrossEncoder(self._model_name)

    async def rerank(
        self,
        query: str,
        results: list[SearchResult],
        top_n: int | None = None,
    ) -> list[SearchResult]:
        """Rerank results by relevance.

        Args:
            query: Search query
            results: Results from semantic search
            top_n: Return top N after reranking (None = all)

        Returns:
            Reranked results with updated scores
        """
        if not results:
            return results

        if self._provider == "cohere":
            return await self._rerank_cohere(query, results, top_n)
        else:
            return await self._rerank_local(query, results, top_n)

    async def _rerank_cohere(
        self,
        query: str,
        results: list[SearchResult],
        top_n: int | None,
    ) -> list[SearchResult]:
        """Rerank using Cohere API."""
        documents = [r.content for r in results]

        # Cohere client is sync, run in executor
        loop = asyncio.get_running_loop()
        response = await loop.run_in_executor(
            None,
            lambda: self._client.rerank(
                model=self._model_name,
                query=query,
                documents=documents,
                top_n=top_n or len(documents),
            ),
        )

        # Map back to SearchResult objects with updated scores using dataclasses.replace
        reranked: list[SearchResult] = []
        for item in response.results:
            original = results[item.index]
            # Use dataclasses.replace for immutable update - only change score
            reranked.append(replace(original, score=item.relevance_score))

        return reranked

    async def _rerank_local(
        self,
        query: str,
        results: list[SearchResult],
        top_n: int | None,
    ) -> list[SearchResult]:
        """Rerank using local cross-encoder."""
        pairs = [(query, r.content) for r in results]

        # CrossEncoder.predict is sync, run in executor
        loop = asyncio.get_running_loop()
        scores = await loop.run_in_executor(
            None,
            self._model.predict,
            pairs,
        )

        # Create new results with updated scores using dataclasses.replace and sort
        scored_results = [
            replace(result, score=float(score))
            for result, score in zip(results, scores)
        ]

        # Sort by score descending
        scored_results.sort(key=lambda r: r.score, reverse=True)

        if top_n:
            return scored_results[:top_n]
        return scored_results
```

3. Key implementation details:
   - Use `dataclasses.replace(original, score=new_score)` instead of manual SearchResult construction
   - This is safer because it preserves all fields and handles future field additions
   - Use cohere.ClientV2 (not Client) for v2 API
   - Wrap sync API calls with run_in_executor

4. Update src/knowledge_mcp/search/__init__.py:
   - Add conditional import of Reranker
   - Update __all__
  </action>
  <verify>
    `poetry install --with rerank --with local && poetry run python -c "from knowledge_mcp.search import Reranker; print('OK')"`
  </verify>
  <done>
    - Reranker supports both Cohere and local cross-encoder
    - Uses dataclasses.replace() for safe immutable updates
    - Async methods don't block event loop
    - Returns reranked results with updated scores
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Reranker tests with reorder verification</name>
  <files>
    tests/unit/test_search/test_reranker.py
  </files>
  <action>
1. Create tests/unit/test_search/test_reranker.py with tests that verify reordering behavior:

```python
"""Unit tests for Reranker."""
from dataclasses import replace
from unittest.mock import MagicMock, patch
import pytest

from knowledge_mcp.search.models import SearchResult


def make_result(id: str, content: str, score: float) -> SearchResult:
    """Helper to create SearchResult."""
    return SearchResult(id=id, content=content, score=score)


class TestReranker:
    """Tests for Reranker class."""

    @pytest.fixture
    def mock_cohere(self) -> MagicMock:
        """Mock Cohere client."""
        client = MagicMock()
        return client

    @pytest.fixture
    def mock_cross_encoder(self) -> MagicMock:
        """Mock CrossEncoder."""
        model = MagicMock()
        return model

    @patch("knowledge_mcp.search.reranker.cohere")
    def test_cohere_init_requires_api_key(self, mock_cohere: MagicMock) -> None:
        """Test Cohere provider requires API key."""
        from knowledge_mcp.search.reranker import Reranker

        with pytest.raises(ValueError, match="api_key required"):
            Reranker(provider="cohere")

    @patch("knowledge_mcp.search.reranker.cohere")
    def test_cohere_init_with_api_key(self, mock_cohere: MagicMock) -> None:
        """Test Cohere provider initializes with API key."""
        from knowledge_mcp.search.reranker import Reranker

        reranker = Reranker(provider="cohere", api_key="test-key")
        assert reranker._provider == "cohere"
        mock_cohere.ClientV2.assert_called_once_with(api_key="test-key")

    @patch("knowledge_mcp.search.reranker.CrossEncoder")
    def test_local_init(self, mock_ce_cls: MagicMock) -> None:
        """Test local provider initializes cross-encoder."""
        from knowledge_mcp.search.reranker import Reranker

        reranker = Reranker(provider="local")
        assert reranker._provider == "local"
        mock_ce_cls.assert_called_once()

    @patch("knowledge_mcp.search.reranker.CrossEncoder")
    @pytest.mark.asyncio
    async def test_rerank_empty_results(self, mock_ce_cls: MagicMock) -> None:
        """Test rerank returns empty list for empty input."""
        from knowledge_mcp.search.reranker import Reranker

        reranker = Reranker(provider="local")
        result = await reranker.rerank("query", [])
        assert result == []

    @patch("knowledge_mcp.search.reranker.CrossEncoder")
    @pytest.mark.asyncio
    async def test_rerank_local_reorders_by_score(self, mock_ce_cls: MagicMock) -> None:
        """Test local reranking actually reorders results by new scores.

        This test verifies that reranking changes the order of results
        based on cross-encoder scores, not just that it returns results.
        """
        mock_model = MagicMock()
        # Scores that reverse the original order: [0.3, 0.6, 0.9]
        # Original order: id=1, id=2, id=3
        # After reranking: id=3 (0.9), id=2 (0.6), id=1 (0.3)
        mock_model.predict.return_value = [0.3, 0.6, 0.9]
        mock_ce_cls.return_value = mock_model

        from knowledge_mcp.search.reranker import Reranker

        reranker = Reranker(provider="local")
        # Original results with semantic search scores (different from rerank scores)
        results = [
            make_result("1", "content 1", 0.95),  # Highest semantic score
            make_result("2", "content 2", 0.85),
            make_result("3", "content 3", 0.75),  # Lowest semantic score
        ]

        reranked = await reranker.rerank("query", results)

        # Verify order changed: id=3 should now be first (score 0.9)
        assert reranked[0].id == "3", "Highest rerank score should be first"
        assert reranked[1].id == "2", "Middle rerank score should be second"
        assert reranked[2].id == "1", "Lowest rerank score should be last"

        # Verify scores were updated
        assert reranked[0].score == 0.9
        assert reranked[1].score == 0.6
        assert reranked[2].score == 0.3

    @patch("knowledge_mcp.search.reranker.CrossEncoder")
    @pytest.mark.asyncio
    async def test_rerank_preserves_all_fields(self, mock_ce_cls: MagicMock) -> None:
        """Test that reranking preserves all SearchResult fields except score."""
        mock_model = MagicMock()
        mock_model.predict.return_value = [0.99]
        mock_ce_cls.return_value = mock_model

        from knowledge_mcp.search.reranker import Reranker

        reranker = Reranker(provider="local")

        # Create result with all fields populated
        original = SearchResult(
            id="chunk-42",
            content="Test content",
            score=0.5,
            metadata={"key": "value"},
            document_id="doc-1",
            document_title="IEEE 15288",
            document_type="standard",
            section_title="Requirements",
            section_hierarchy=["5", "5.3"],
            chunk_type="requirement",
            normative=True,
            clause_number="5.3.1",
            page_numbers=[42, 43],
        )

        reranked = await reranker.rerank("query", [original])

        # Score should be updated
        assert reranked[0].score == 0.99

        # All other fields should be preserved
        assert reranked[0].id == original.id
        assert reranked[0].content == original.content
        assert reranked[0].metadata == original.metadata
        assert reranked[0].document_id == original.document_id
        assert reranked[0].document_title == original.document_title
        assert reranked[0].document_type == original.document_type
        assert reranked[0].section_title == original.section_title
        assert reranked[0].section_hierarchy == original.section_hierarchy
        assert reranked[0].chunk_type == original.chunk_type
        assert reranked[0].normative == original.normative
        assert reranked[0].clause_number == original.clause_number
        assert reranked[0].page_numbers == original.page_numbers

    @patch("knowledge_mcp.search.reranker.CrossEncoder")
    @pytest.mark.asyncio
    async def test_rerank_top_n(self, mock_ce_cls: MagicMock) -> None:
        """Test top_n limits returned results."""
        mock_model = MagicMock()
        mock_model.predict.return_value = [0.8, 0.3, 0.9]
        mock_ce_cls.return_value = mock_model

        from knowledge_mcp.search.reranker import Reranker

        reranker = Reranker(provider="local")
        results = [
            make_result("1", "content 1", 0.5),
            make_result("2", "content 2", 0.6),
            make_result("3", "content 3", 0.4),
        ]

        reranked = await reranker.rerank("query", results, top_n=2)

        assert len(reranked) == 2
        # Should be top 2 by rerank score: id=3 (0.9), id=1 (0.8)
        assert reranked[0].id == "3"
        assert reranked[1].id == "1"
```

2. Test cases covered:
   - Cohere provider requires API key
   - Cohere provider initializes with API key
   - Local provider initializes cross-encoder
   - Empty results returns empty list
   - **Reranking actually reorders results** (critical verification)
   - Reranking preserves all SearchResult fields except score
   - top_n limits results
  </action>
  <verify>
    `poetry run pytest tests/unit/test_search/test_reranker.py -v` passes
  </verify>
  <done>
    - Reranker tests cover Cohere and local providers
    - Tests verify that reranking actually changes result order
    - Tests verify all fields are preserved via dataclasses.replace
    - All tests pass
  </done>
</task>

</tasks>

<verification>
1. `poetry install --with rerank --with local` completes successfully
2. `from knowledge_mcp.search import Reranker` works
3. `poetry run pytest tests/unit/test_search/test_reranker.py -v` passes
4. `poetry run pyright src/knowledge_mcp/search/reranker.py` reports no errors
5. Test verifies reranking reorders results (test_rerank_local_reorders_by_score)
</verification>

<success_criteria>
- Reranker supports Cohere and local cross-encoder
- Uses dataclasses.replace() for safe immutable SearchResult updates
- Tests verify actual reordering behavior (not just that results are returned)
- All tests pass
- pyright passes on new code
</success_criteria>

<output>
After completion, create `.planning/phases/05-extended-features/05-03-SUMMARY.md`
</output>
