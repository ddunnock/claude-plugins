---
phase: 04-test-coverage
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/test_server.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Server run() and shutdown tested without blocking"
    - "_ensure_dependencies() with real config creation tested"
    - "Server coverage reaches 80%+"
  artifacts:
    - path: "tests/unit/test_server.py"
      provides: "Extended server tests for run/shutdown paths"
      contains: "test_ensure_dependencies"
  key_links:
    - from: "tests/unit/test_server.py"
      to: "src/knowledge_mcp/server.py"
      via: "tests _ensure_dependencies and run"
      pattern: "_ensure_dependencies|_handle_shutdown"
---

<objective>
Extend server tests to cover remaining uncovered lines (run, shutdown, _ensure_dependencies with real config).

Purpose: server.py is at 64% coverage. The uncovered lines are in run(), _handle_shutdown(), and _ensure_dependencies() when creating real config/embedder/store.

Output: Extended test_server.py with tests for initialization and lifecycle.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key files:
@src/knowledge_mcp/server.py
@tests/unit/test_server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server initialization and lifecycle tests</name>
  <files>tests/unit/test_server.py</files>
  <action>
Extend existing test_server.py with additional test classes:

**Add to existing file:**

`TestEnsureDependencies`:
Tests for _ensure_dependencies() method with mocked externals.

- `test_ensure_dependencies_loads_config` - verify load_config called when no dependencies
- `test_ensure_dependencies_creates_embedder_with_cache` - verify cache created when enabled
- `test_ensure_dependencies_creates_embedder_with_tracker` - verify tracker created when enabled
- `test_ensure_dependencies_creates_store` - verify create_store called
- `test_ensure_dependencies_creates_searcher` - verify SemanticSearcher created
- `test_ensure_dependencies_skips_if_already_initialized` - verify no double init
- `test_ensure_dependencies_uses_injected_embedder` - verify provided embedder used
- `test_ensure_dependencies_uses_injected_store` - verify provided store used

**Pattern:**
```python
from unittest.mock import patch, MagicMock

class TestEnsureDependencies:
    def test_ensure_dependencies_loads_config(self):
        # Don't inject dependencies - force real initialization path
        server = KnowledgeMCPServer(name="test")

        with patch("knowledge_mcp.server.load_config") as mock_load:
            mock_config = MagicMock()
            mock_config.cache_enabled = False
            mock_config.token_tracking_enabled = False
            mock_load.return_value = mock_config

            with patch("knowledge_mcp.server.OpenAIEmbedder"):
                with patch("knowledge_mcp.server.create_store"):
                    server._ensure_dependencies()
                    mock_load.assert_called_once()
```

`TestServerRun`:
Tests for run() method - use asyncio timeout to prevent blocking.

- `test_run_sets_up_signal_handlers_unix` - verify signal handlers added on non-Windows
- `test_handle_shutdown_cancels_tasks` - verify tasks cancelled on shutdown

**Pattern for testing run without blocking:**
```python
import asyncio
from unittest.mock import patch, AsyncMock

class TestServerRun:
    @pytest.mark.asyncio
    async def test_run_sets_up_signal_handlers_unix(self):
        server = KnowledgeMCPServer(
            embedder=MagicMock(),
            store=MagicMock(),
        )

        # Mock stdio_server to exit immediately
        mock_stdio = AsyncMock()
        mock_context = AsyncMock()
        mock_context.__aenter__.return_value = (AsyncMock(), AsyncMock())
        mock_context.__aexit__.return_value = None

        with patch("knowledge_mcp.server.stdio_server", return_value=mock_context):
            with patch.object(server.server, "run", new_callable=AsyncMock):
                with patch("sys.platform", "linux"):
                    with patch("asyncio.get_running_loop") as mock_loop:
                        mock_loop.return_value.add_signal_handler = MagicMock()

                        # Run with short timeout
                        try:
                            await asyncio.wait_for(server.run(), timeout=0.1)
                        except asyncio.TimeoutError:
                            pass

                        # Signal handlers should be added
                        mock_loop.return_value.add_signal_handler.assert_called()

    def test_handle_shutdown_cancels_tasks(self):
        server = KnowledgeMCPServer(
            embedder=MagicMock(),
            store=MagicMock(),
        )

        with patch("asyncio.get_running_loop") as mock_loop:
            mock_task = MagicMock()
            mock_loop.return_value = MagicMock()
            with patch("asyncio.all_tasks", return_value={mock_task}):
                server._handle_shutdown()
                mock_task.cancel.assert_called_once()
```

`TestMain`:
Test for module-level main() function.

- `test_main_creates_server_and_runs` - verify main creates KnowledgeMCPServer and calls run

**Pattern:**
```python
class TestMain:
    @pytest.mark.asyncio
    async def test_main_creates_server_and_runs(self):
        with patch("knowledge_mcp.server.KnowledgeMCPServer") as MockServer:
            mock_instance = MagicMock()
            mock_instance.run = AsyncMock()
            MockServer.return_value = mock_instance

            from knowledge_mcp.server import main
            await main()

            MockServer.assert_called_once()
            mock_instance.run.assert_called_once()
```
  </action>
  <verify>
```bash
poetry run pytest tests/unit/test_server.py -v
poetry run pytest --cov=src/knowledge_mcp/server --cov-report=term-missing tests/unit/test_server.py
```
Coverage for server.py should be >80%.
  </verify>
  <done>server.py coverage reaches 80%+ with initialization, run, and shutdown paths tested.</done>
</task>

</tasks>

<verification>
```bash
# Run server tests
poetry run pytest tests/unit/test_server.py -v

# Check coverage
poetry run pytest --cov=src/knowledge_mcp/server --cov-report=term-missing tests/unit/test_server.py
```

server.py should now have >80% coverage.
</verification>

<success_criteria>
- tests/unit/test_server.py extended with 10+ new tests
- server.py coverage: 64% -> 80%+
- All new tests pass
- Zero pyright errors in test files
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage/04-03-SUMMARY.md`
</output>
