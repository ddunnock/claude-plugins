---
phase: 04-test-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/test_store/test_qdrant_store.py
  - tests/unit/test_store/test_chromadb_store.py
  - tests/unit/test_store/__init__.py
  - tests/integration/test_fallback.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "QdrantStore add_chunks, search, validate_embedding_model methods tested with mocked client"
    - "ChromaDBStore add_chunks, search, validate_embedding_model methods tested with mocked client"
    - "Store fallback behavior tested with categorized exceptions (network, auth, rate limit)"
  artifacts:
    - path: "tests/unit/test_store/test_qdrant_store.py"
      provides: "Unit tests for QdrantStore"
      min_lines: 200
    - path: "tests/unit/test_store/test_chromadb_store.py"
      provides: "Unit tests for ChromaDBStore"
      min_lines: 150
    - path: "tests/integration/test_fallback.py"
      provides: "Extended fallback tests with categorized exceptions"
      contains: "TestCategorizedExceptions"
  key_links:
    - from: "tests/unit/test_store/test_qdrant_store.py"
      to: "src/knowledge_mcp/store/qdrant_store.py"
      via: "imports and mocks QdrantClient"
      pattern: "from knowledge_mcp.store.qdrant_store import"
    - from: "tests/unit/test_store/test_chromadb_store.py"
      to: "src/knowledge_mcp/store/chromadb_store.py"
      via: "imports and mocks chromadb"
      pattern: "from knowledge_mcp.store.chromadb_store import"
    - from: "tests/integration/test_fallback.py"
      to: "src/knowledge_mcp/store/__init__.py"
      via: "tests create_store with exception scenarios"
      pattern: "from knowledge_mcp.store import create_store"
---

<objective>
Add comprehensive unit tests for QdrantStore and ChromaDBStore with mocked clients, plus extend fallback tests with categorized exceptions.

Purpose: These two stores are the critical coverage gaps (17% and 33%). Testing them with mocked clients exercises all code paths without requiring real databases. Fallback tests verify the store factory handles different exception types appropriately.

Output: Two test files covering all store methods, error paths, and edge cases, plus extended fallback tests.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key files:
@src/knowledge_mcp/store/qdrant_store.py
@src/knowledge_mcp/store/chromadb_store.py
@src/knowledge_mcp/store/__init__.py
@tests/conftest.py
@tests/integration/test_fallback.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: QdrantStore unit tests with mocked QdrantClient</name>
  <files>tests/unit/test_store/__init__.py, tests/unit/test_store/test_qdrant_store.py</files>
  <action>
Create comprehensive unit tests for QdrantStore:

1. Create `tests/unit/test_store/__init__.py` (empty file)

2. Create `tests/unit/test_store/test_qdrant_store.py` with:

**Fixtures:**
- `mock_qdrant_client` - MagicMock for QdrantClient with collection stubs
- `mock_config` - KnowledgeConfig with test values
- `store` - QdrantStore with mocked client injected via patching

**Test Classes:**

`TestQdrantStoreInit`:
- `test_creates_collection_if_not_exists` - verify create_collection called when collection missing
- `test_skips_collection_creation_if_exists` - verify no create when collection exists
- `test_creates_payload_indexes` - verify _create_payload_indexes called

`TestQdrantStoreAddChunks`:
- `test_add_chunks_upserts_points` - verify client.upsert called with correct points
- `test_add_chunks_returns_count` - verify correct count returned
- `test_add_empty_chunks_returns_zero` - verify empty list returns 0
- `test_add_chunks_raises_on_missing_embedding` - verify ValueError for None embedding
- `test_add_chunks_batches_large_lists` - verify batching for >100 chunks
- `test_add_chunks_hybrid_mode` - verify NamedVector used when hybrid_enabled

`TestQdrantStoreSearch`:
- `test_search_returns_formatted_results` - verify result format with content, score, metadata
- `test_search_with_filter_dict` - verify Filter built from filter_dict
- `test_search_with_bool_filter` - verify MatchValue for boolean values
- `test_search_with_list_filter` - verify MatchAny for list values
- `test_search_with_score_threshold` - verify threshold passed to client
- `test_search_hybrid_mode_uses_named_vector` - verify NamedVector in hybrid mode
- `test_search_non_hybrid_uses_plain_vector` - verify plain vector in standard mode

`TestQdrantStoreStats`:
- `test_get_stats_returns_collection_info` - verify stats format

`TestQdrantStoreValidation`:
- `test_validate_embedding_model_empty_collection` - verify True for empty
- `test_validate_embedding_model_matching` - verify True when models match
- `test_validate_embedding_model_mismatch` - verify ValueError when different
- `test_validate_embedding_model_handles_exceptions` - verify False on errors

`TestQdrantStoreHealthCheck`:
- `test_health_check_returns_true_when_healthy` - verify True on success
- `test_health_check_returns_false_on_error` - verify False on exception

**Pattern:** Use `@patch("knowledge_mcp.store.qdrant_store.QdrantClient")` to inject mock.
  </action>
  <verify>
```bash
poetry run pytest tests/unit/test_store/test_qdrant_store.py -v
poetry run pytest --cov=src/knowledge_mcp/store/qdrant_store --cov-report=term-missing tests/unit/test_store/test_qdrant_store.py
```
Coverage for qdrant_store.py should be >80%.
  </verify>
  <done>QdrantStore coverage reaches 80%+ with all methods and error paths tested.</done>
</task>

<task type="auto">
  <name>Task 2: ChromaDBStore unit tests with mocked chromadb</name>
  <files>tests/unit/test_store/test_chromadb_store.py</files>
  <action>
Create comprehensive unit tests for ChromaDBStore:

**Fixtures:**
- `mock_chromadb_client` - MagicMock for chromadb.PersistentClient
- `mock_collection` - MagicMock for collection with query/upsert/count stubs
- `mock_config` - KnowledgeConfig with chromadb settings
- `store` - ChromaDBStore with patched chromadb import

**Test Classes:**

`TestChromaDBStoreInit`:
- `test_creates_directory_if_not_exists` - verify mkdir called
- `test_gets_or_creates_collection` - verify get_or_create_collection called
- `test_raises_import_error_when_chromadb_missing` - verify helpful error

`TestChromaDBStoreAddChunks`:
- `test_add_chunks_upserts_data` - verify collection.upsert called
- `test_add_chunks_returns_count` - verify correct count
- `test_add_empty_chunks_returns_zero` - verify 0 for empty
- `test_add_chunks_raises_on_missing_embedding` - verify ValueError
- `test_add_chunks_includes_all_metadata` - verify all fields in metadatas

`TestChromaDBStoreSearch`:
- `test_search_returns_formatted_results` - verify format
- `test_search_converts_distance_to_score` - verify 1 - distance
- `test_search_with_filter_dict` - verify where filter built
- `test_search_respects_score_threshold` - verify low scores filtered
- `test_search_empty_collection` - verify empty list returned

`TestChromaDBStoreStats`:
- `test_get_stats_returns_info` - verify stats format
- `test_get_stats_includes_count` - verify total_chunks from count()

`TestChromaDBStoreValidation`:
- `test_validate_embedding_model_empty` - verify True for empty
- `test_validate_embedding_model_matching` - verify True when match
- `test_validate_embedding_model_mismatch` - verify ValueError
- `test_validate_embedding_model_handles_exceptions` - verify False on errors

`TestChromaDBStoreHealthCheck`:
- `test_health_check_returns_true` - verify True when count() succeeds
- `test_health_check_returns_false_on_error` - verify False on exception

**Pattern:** Use `@patch.dict("sys.modules", {"chromadb": mock_module})` or patch at import.
  </action>
  <verify>
```bash
poetry run pytest tests/unit/test_store/test_chromadb_store.py -v
poetry run pytest --cov=src/knowledge_mcp/store/chromadb_store --cov-report=term-missing tests/unit/test_store/test_chromadb_store.py
```
Coverage for chromadb_store.py should be >80%.
  </verify>
  <done>ChromaDBStore coverage reaches 80%+ with all methods and error paths tested.</done>
</task>

<task type="auto">
  <name>Task 3: Extend fallback tests with categorized exceptions</name>
  <files>tests/integration/test_fallback.py</files>
  <action>
Extend existing test_fallback.py with categorized exception tests:

**Add new test class:**

`TestCategorizedExceptions`:
Tests that verify fallback behavior based on exception type.

- `test_fallback_on_connection_timeout` - simulate requests.exceptions.ConnectTimeout, verify fallback
- `test_fallback_on_connection_refused` - simulate ConnectionRefusedError, verify fallback
- `test_fallback_on_dns_resolution_failure` - simulate socket.gaierror, verify fallback
- `test_fallback_on_authentication_error` - simulate 401/403 response, verify fallback and appropriate error message
- `test_fallback_on_rate_limit_error` - simulate 429 response, verify fallback and rate limit logged
- `test_no_fallback_on_invalid_config` - simulate ValueError for bad config, verify no fallback (config errors should propagate)

**Pattern:**
```python
from unittest.mock import patch, MagicMock
import socket

class TestCategorizedExceptions:
    """Test fallback behavior with categorized exception types."""

    @pytest.fixture
    def config_with_qdrant(self, tmp_path: Path) -> KnowledgeConfig:
        """Create config preferring Qdrant."""
        chromadb_dir = tmp_path / "chromadb"
        chromadb_dir.mkdir()
        return KnowledgeConfig(
            openai_api_key="test-key",
            vector_store="qdrant",
            qdrant_url="http://localhost:6333",
            qdrant_api_key="test-api-key",
            chromadb_path=chromadb_dir,
        )

    def test_fallback_on_connection_timeout(
        self, config_with_qdrant: KnowledgeConfig, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Verify fallback when Qdrant connection times out."""
        from requests.exceptions import ConnectTimeout

        with patch("knowledge_mcp.store.qdrant_store.QdrantClient") as mock_client:
            mock_client.side_effect = ConnectTimeout("Connection timed out")

            with caplog.at_level(logging.WARNING):
                store = create_store(config_with_qdrant)

            assert isinstance(store, ChromaDBStore)
            assert any("timeout" in r.message.lower() or "fallback" in r.message.lower()
                       for r in caplog.records)

    def test_fallback_on_authentication_error(
        self, config_with_qdrant: KnowledgeConfig, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Verify fallback and error message on auth failure."""
        from qdrant_client.http.exceptions import UnexpectedResponse

        mock_response = MagicMock()
        mock_response.status_code = 401

        with patch("knowledge_mcp.store.qdrant_store.QdrantClient") as mock_client:
            mock_client.side_effect = UnexpectedResponse(
                status_code=401,
                reason_phrase="Unauthorized",
                content=b"Invalid API key"
            )

            with caplog.at_level(logging.WARNING):
                store = create_store(config_with_qdrant)

            assert isinstance(store, ChromaDBStore)
            # Auth errors should be logged distinctly
            assert any("auth" in r.message.lower() or "401" in r.message or "unauthorized" in r.message.lower()
                       for r in caplog.records)
```

Note: The exact exception types depend on what qdrant-client raises. Check the actual exceptions in the store/__init__.py create_store function and match tests to those.
  </action>
  <verify>
```bash
poetry run pytest tests/integration/test_fallback.py -v
```
All fallback tests should pass including new categorized exception tests.
  </verify>
  <done>Store fallback logic tested with categorized exceptions (network, auth, rate limit).</done>
</task>

</tasks>

<verification>
```bash
# Run all store tests
poetry run pytest tests/unit/test_store/ -v

# Run fallback tests
poetry run pytest tests/integration/test_fallback.py -v

# Check combined coverage for store module
poetry run pytest --cov=src/knowledge_mcp/store --cov-report=term-missing tests/unit/test_store/ tests/integration/test_fallback.py
```

Both stores should now have >80% coverage individually, and fallback logic tested with exception categories.
</verification>

<success_criteria>
- tests/unit/test_store/test_qdrant_store.py exists with 15+ tests
- tests/unit/test_store/test_chromadb_store.py exists with 15+ tests
- tests/integration/test_fallback.py extended with categorized exception tests
- QdrantStore coverage: 17% -> 80%+
- ChromaDBStore coverage: 33% -> 80%+
- Fallback tests cover network errors, auth errors, rate limits
- All new tests pass
- Zero pyright errors in test files
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage/04-01-SUMMARY.md`
</output>
