---
phase: 04-test-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/test_store/test_qdrant_store.py
  - tests/unit/test_store/test_chromadb_store.py
  - tests/unit/test_store/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "QdrantStore methods tested with mocked client"
    - "ChromaDBStore methods tested with mocked client"
    - "Store coverage jumps from 17%/33% to 80%+"
  artifacts:
    - path: "tests/unit/test_store/test_qdrant_store.py"
      provides: "Unit tests for QdrantStore"
      min_lines: 200
    - path: "tests/unit/test_store/test_chromadb_store.py"
      provides: "Unit tests for ChromaDBStore"
      min_lines: 150
  key_links:
    - from: "tests/unit/test_store/test_qdrant_store.py"
      to: "src/knowledge_mcp/store/qdrant_store.py"
      via: "imports and mocks QdrantClient"
      pattern: "from knowledge_mcp.store.qdrant_store import"
    - from: "tests/unit/test_store/test_chromadb_store.py"
      to: "src/knowledge_mcp/store/chromadb_store.py"
      via: "imports and mocks chromadb"
      pattern: "from knowledge_mcp.store.chromadb_store import"
---

<objective>
Add comprehensive unit tests for QdrantStore and ChromaDBStore with mocked clients.

Purpose: These two stores are the critical coverage gaps (17% and 33%). Testing them with mocked clients exercises all code paths without requiring real databases.

Output: Two test files covering all store methods, error paths, and edge cases.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key files:
@src/knowledge_mcp/store/qdrant_store.py
@src/knowledge_mcp/store/chromadb_store.py
@tests/conftest.py
@tests/integration/test_fallback.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: QdrantStore unit tests with mocked QdrantClient</name>
  <files>tests/unit/test_store/__init__.py, tests/unit/test_store/test_qdrant_store.py</files>
  <action>
Create comprehensive unit tests for QdrantStore:

1. Create `tests/unit/test_store/__init__.py` (empty file)

2. Create `tests/unit/test_store/test_qdrant_store.py` with:

**Fixtures:**
- `mock_qdrant_client` - MagicMock for QdrantClient with collection stubs
- `mock_config` - KnowledgeConfig with test values
- `store` - QdrantStore with mocked client injected via patching

**Test Classes:**

`TestQdrantStoreInit`:
- `test_creates_collection_if_not_exists` - verify create_collection called when collection missing
- `test_skips_collection_creation_if_exists` - verify no create when collection exists
- `test_creates_payload_indexes` - verify _create_payload_indexes called

`TestQdrantStoreAddChunks`:
- `test_add_chunks_upserts_points` - verify client.upsert called with correct points
- `test_add_chunks_returns_count` - verify correct count returned
- `test_add_empty_chunks_returns_zero` - verify empty list returns 0
- `test_add_chunks_raises_on_missing_embedding` - verify ValueError for None embedding
- `test_add_chunks_batches_large_lists` - verify batching for >100 chunks
- `test_add_chunks_hybrid_mode` - verify NamedVector used when hybrid_enabled

`TestQdrantStoreSearch`:
- `test_search_returns_formatted_results` - verify result format with content, score, metadata
- `test_search_with_filter_dict` - verify Filter built from filter_dict
- `test_search_with_bool_filter` - verify MatchValue for boolean values
- `test_search_with_list_filter` - verify MatchAny for list values
- `test_search_with_score_threshold` - verify threshold passed to client
- `test_search_hybrid_mode_uses_named_vector` - verify NamedVector in hybrid mode
- `test_search_non_hybrid_uses_plain_vector` - verify plain vector in standard mode

`TestQdrantStoreStats`:
- `test_get_stats_returns_collection_info` - verify stats format

`TestQdrantStoreValidation`:
- `test_validate_embedding_model_empty_collection` - verify True for empty
- `test_validate_embedding_model_matching` - verify True when models match
- `test_validate_embedding_model_mismatch` - verify ValueError when different
- `test_validate_embedding_model_handles_exceptions` - verify False on errors

`TestQdrantStoreHealthCheck`:
- `test_health_check_returns_true_when_healthy` - verify True on success
- `test_health_check_returns_false_on_error` - verify False on exception

**Pattern:** Use `@patch("knowledge_mcp.store.qdrant_store.QdrantClient")` to inject mock.
  </action>
  <verify>
```bash
poetry run pytest tests/unit/test_store/test_qdrant_store.py -v
poetry run pytest --cov=src/knowledge_mcp/store/qdrant_store --cov-report=term-missing tests/unit/test_store/test_qdrant_store.py
```
Coverage for qdrant_store.py should be >80%.
  </verify>
  <done>QdrantStore coverage reaches 80%+ with all methods and error paths tested.</done>
</task>

<task type="auto">
  <name>Task 2: ChromaDBStore unit tests with mocked chromadb</name>
  <files>tests/unit/test_store/test_chromadb_store.py</files>
  <action>
Create comprehensive unit tests for ChromaDBStore:

**Fixtures:**
- `mock_chromadb_client` - MagicMock for chromadb.PersistentClient
- `mock_collection` - MagicMock for collection with query/upsert/count stubs
- `mock_config` - KnowledgeConfig with chromadb settings
- `store` - ChromaDBStore with patched chromadb import

**Test Classes:**

`TestChromaDBStoreInit`:
- `test_creates_directory_if_not_exists` - verify mkdir called
- `test_gets_or_creates_collection` - verify get_or_create_collection called
- `test_raises_import_error_when_chromadb_missing` - verify helpful error

`TestChromaDBStoreAddChunks`:
- `test_add_chunks_upserts_data` - verify collection.upsert called
- `test_add_chunks_returns_count` - verify correct count
- `test_add_empty_chunks_returns_zero` - verify 0 for empty
- `test_add_chunks_raises_on_missing_embedding` - verify ValueError
- `test_add_chunks_includes_all_metadata` - verify all fields in metadatas

`TestChromaDBStoreSearch`:
- `test_search_returns_formatted_results` - verify format
- `test_search_converts_distance_to_score` - verify 1 - distance
- `test_search_with_filter_dict` - verify where filter built
- `test_search_respects_score_threshold` - verify low scores filtered
- `test_search_empty_collection` - verify empty list returned

`TestChromaDBStoreStats`:
- `test_get_stats_returns_info` - verify stats format
- `test_get_stats_includes_count` - verify total_chunks from count()

`TestChromaDBStoreValidation`:
- `test_validate_embedding_model_empty` - verify True for empty
- `test_validate_embedding_model_matching` - verify True when match
- `test_validate_embedding_model_mismatch` - verify ValueError
- `test_validate_embedding_model_handles_exceptions` - verify False on errors

`TestChromaDBStoreHealthCheck`:
- `test_health_check_returns_true` - verify True when count() succeeds
- `test_health_check_returns_false_on_error` - verify False on exception

**Pattern:** Use `@patch.dict("sys.modules", {"chromadb": mock_module})` or patch at import.
  </action>
  <verify>
```bash
poetry run pytest tests/unit/test_store/test_chromadb_store.py -v
poetry run pytest --cov=src/knowledge_mcp/store/chromadb_store --cov-report=term-missing tests/unit/test_store/test_chromadb_store.py
```
Coverage for chromadb_store.py should be >80%.
  </verify>
  <done>ChromaDBStore coverage reaches 80%+ with all methods and error paths tested.</done>
</task>

</tasks>

<verification>
```bash
# Run all store tests
poetry run pytest tests/unit/test_store/ -v

# Check combined coverage for store module
poetry run pytest --cov=src/knowledge_mcp/store --cov-report=term-missing tests/unit/test_store/ tests/integration/test_fallback.py
```

Both stores should now have >80% coverage individually.
</verification>

<success_criteria>
- tests/unit/test_store/test_qdrant_store.py exists with 15+ tests
- tests/unit/test_store/test_chromadb_store.py exists with 15+ tests
- QdrantStore coverage: 17% -> 80%+
- ChromaDBStore coverage: 33% -> 80%+
- All new tests pass
- Zero pyright errors in test files
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage/04-01-SUMMARY.md`
</output>
