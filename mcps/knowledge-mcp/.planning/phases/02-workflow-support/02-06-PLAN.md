---
phase: 02-workflow-support
plan: 06
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/knowledge_mcp/search/strategies/plan.py
  - src/knowledge_mcp/db/repositories.py
  - tests/unit/test_search/test_plan_strategy.py
autonomous: true

must_haves:
  truths:
    - "PlanStrategy searches for templates, risks, and precedents"
    - "PlanStrategy supports project capture operations (create, update, add query, add decision)"
    - "ProjectRepository provides async CRUD for projects and related entities"
    - "Project capture creates/updates project records with outcomes"
  artifacts:
    - path: "src/knowledge_mcp/search/strategies/plan.py"
      provides: "PlanStrategy class with capture operations"
      contains: "class PlanStrategy"
    - path: "src/knowledge_mcp/db/repositories.py"
      provides: "ProjectRepository class"
      contains: "class ProjectRepository"
    - path: "tests/unit/test_search/test_plan_strategy.py"
      provides: "Unit tests for plan strategy"
      contains: "class TestPlanStrategy"
  key_links:
    - from: "PlanStrategy"
      to: "SearchStrategy"
      via: "inheritance"
      pattern: "class PlanStrategy.*SearchStrategy"
    - from: "PlanStrategy"
      to: "ProjectRepository"
      via: "composition"
      pattern: "ProjectRepository"
---

<objective>
Implement PlanStrategy for planning workflow support with project capture capabilities.

Purpose: Enable template retrieval, risk identification, and comprehensive project capture including query history, project profiles, and decision trails - forming a project knowledge graph for personalized future searches.

Output: PlanStrategy class with search and capture, plus ProjectRepository for database operations.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-workflow-support/02-RESEARCH.md
@.planning/phases/02-workflow-support/02-CONTEXT.md

# Strategy base (from 02-02)
@src/knowledge_mcp/search/strategies/base.py

# Database models (from 02-01)
@src/knowledge_mcp/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProjectRepository for database operations</name>
  <files>src/knowledge_mcp/db/repositories.py</files>
  <action>
Create or extend repositories.py with ProjectRepository:

```python
"""Repository pattern for database access.

Provides async-safe data access methods for Knowledge MCP entities.
Each method creates its own session for proper lifecycle management.
"""

from __future__ import annotations

import logging
from datetime import datetime, timezone
from typing import TYPE_CHECKING, Any
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.orm import selectinload

if TYPE_CHECKING:
    from sqlalchemy.ext.asyncio import AsyncSession

from knowledge_mcp.db.models import (
    Decision,
    DecisionSource,
    Project,
    ProjectStatus,
    QueryHistory,
)

logger = logging.getLogger(__name__)


class ProjectRepository:
    """Async repository for project operations.

    Handles CRUD operations for projects and related entities
    (query history, decisions, decision sources).

    All methods expect an AsyncSession parameter for proper
    session-per-operation lifecycle management.

    Example:
        >>> async with get_session() as session:
        ...     repo = ProjectRepository()
        ...     project = await repo.create_project(
        ...         session, name="My Project", domain="aerospace"
        ...     )
    """

    async def create_project(
        self,
        session: AsyncSession,
        name: str,
        domain: str | None = None,
        applicable_standards: list[str] | None = None,
        description: str | None = None,
    ) -> Project:
        """Create a new project.

        Args:
            session: Database session.
            name: Project name.
            domain: Optional domain (e.g., "aerospace", "medical").
            applicable_standards: Optional list of relevant standards.
            description: Optional project description.

        Returns:
            Created Project instance.
        """
        project = Project(
            name=name,
            domain=domain,
            applicable_standards=applicable_standards,
            description=description,
            status=ProjectStatus.PLANNING,
        )
        session.add(project)
        await session.flush()
        await session.refresh(project)
        logger.info("Created project %s: %s", project.id, name)
        return project

    async def get_project(
        self,
        session: AsyncSession,
        project_id: UUID,
    ) -> Project | None:
        """Get project by ID.

        Args:
            session: Database session.
            project_id: Project UUID.

        Returns:
            Project or None if not found.
        """
        result = await session.execute(
            select(Project).where(Project.id == project_id)
        )
        return result.scalar_one_or_none()

    async def get_project_with_history(
        self,
        session: AsyncSession,
        project_id: UUID,
    ) -> Project | None:
        """Get project with eager-loaded query history.

        Args:
            session: Database session.
            project_id: Project UUID.

        Returns:
            Project with query_history loaded, or None.
        """
        result = await session.execute(
            select(Project)
            .where(Project.id == project_id)
            .options(selectinload(Project.query_history))
        )
        return result.scalar_one_or_none()

    async def update_project_status(
        self,
        session: AsyncSession,
        project_id: UUID,
        new_status: ProjectStatus,
    ) -> Project:
        """Update project status with state machine validation.

        Args:
            session: Database session.
            project_id: Project UUID.
            new_status: Target status.

        Returns:
            Updated Project.

        Raises:
            ValueError: If project not found or transition invalid.
        """
        project = await self.get_project(session, project_id)
        if project is None:
            raise ValueError(f"Project {project_id} not found")

        project.transition_to(new_status)

        if new_status in (ProjectStatus.COMPLETED, ProjectStatus.ABANDONED):
            project.completed_at = datetime.now(timezone.utc)

        await session.flush()
        await session.refresh(project)
        logger.info("Project %s transitioned to %s", project_id, new_status.value)
        return project

    async def list_projects(
        self,
        session: AsyncSession,
        status: ProjectStatus | None = None,
        domain: str | None = None,
        limit: int = 50,
    ) -> list[Project]:
        """List projects with optional filtering.

        Args:
            session: Database session.
            status: Filter by status.
            domain: Filter by domain.
            limit: Maximum results.

        Returns:
            List of matching projects.
        """
        query = select(Project)

        if status is not None:
            query = query.where(Project.status == status)
        if domain is not None:
            query = query.where(Project.domain == domain)

        query = query.order_by(Project.created_at.desc()).limit(limit)

        result = await session.execute(query)
        return list(result.scalars().all())

    async def capture_query(
        self,
        session: AsyncSession,
        project_id: UUID,
        query: str,
        result_count: int,
        workflow_type: str | None = None,
    ) -> QueryHistory:
        """Record a query in project history.

        Args:
            session: Database session.
            project_id: Project UUID.
            query: Search query text.
            result_count: Number of results returned.
            workflow_type: Type of workflow (rcca, trade, explore, plan).

        Returns:
            Created QueryHistory record.
        """
        query_record = QueryHistory(
            project_id=project_id,
            query=query,
            result_count=result_count,
            workflow_type=workflow_type,
        )
        session.add(query_record)
        await session.flush()
        await session.refresh(query_record)
        logger.debug("Captured query for project %s: %s", project_id, query[:50])
        return query_record

    async def get_query_history(
        self,
        session: AsyncSession,
        project_id: UUID,
        limit: int = 20,
    ) -> list[QueryHistory]:
        """Get recent queries for a project.

        Args:
            session: Database session.
            project_id: Project UUID.
            limit: Maximum queries to return.

        Returns:
            List of QueryHistory records, most recent first.
        """
        result = await session.execute(
            select(QueryHistory)
            .where(QueryHistory.project_id == project_id)
            .order_by(QueryHistory.created_at.desc())
            .limit(limit)
        )
        return list(result.scalars().all())

    async def capture_decision(
        self,
        session: AsyncSession,
        project_id: UUID,
        decision: str,
        rationale: str,
        alternatives: list[str] | None = None,
        supporting_chunks: list[tuple[str, float]] | None = None,
    ) -> Decision:
        """Record a decision with rationale and sources.

        Args:
            session: Database session.
            project_id: Project UUID.
            decision: What was decided.
            rationale: Why this choice was made.
            alternatives: Other options that were considered.
            supporting_chunks: List of (chunk_id, relevance) tuples.

        Returns:
            Created Decision record.
        """
        decision_record = Decision(
            project_id=project_id,
            decision=decision,
            rationale=rationale,
            alternatives=alternatives or [],
        )
        session.add(decision_record)
        await session.flush()

        # Link supporting sources
        if supporting_chunks:
            for chunk_id, relevance in supporting_chunks:
                source = DecisionSource(
                    decision_id=decision_record.id,
                    chunk_id=chunk_id,
                    relevance=relevance,
                )
                session.add(source)
            await session.flush()

        await session.refresh(decision_record)
        logger.info("Captured decision for project %s", project_id)
        return decision_record

    async def get_decisions(
        self,
        session: AsyncSession,
        project_id: UUID,
    ) -> list[Decision]:
        """Get all decisions for a project with sources.

        Args:
            session: Database session.
            project_id: Project UUID.

        Returns:
            List of Decision records with sources loaded.
        """
        result = await session.execute(
            select(Decision)
            .where(Decision.project_id == project_id)
            .options(selectinload(Decision.sources))
            .order_by(Decision.created_at.desc())
        )
        return list(result.scalars().all())

    def project_to_dict(self, project: Project) -> dict[str, Any]:
        """Convert Project to JSON-serializable dict.

        Args:
            project: Project ORM instance.

        Returns:
            Dict representation.
        """
        return {
            "id": str(project.id),
            "name": project.name,
            "domain": project.domain,
            "status": project.status.value,
            "applicable_standards": project.applicable_standards,
            "description": project.description,
            "created_at": project.created_at.isoformat() if project.created_at else None,
            "updated_at": project.updated_at.isoformat() if project.updated_at else None,
            "completed_at": project.completed_at.isoformat() if project.completed_at else None,
        }

    def query_history_to_dict(self, qh: QueryHistory) -> dict[str, Any]:
        """Convert QueryHistory to JSON-serializable dict."""
        return {
            "id": str(qh.id),
            "query": qh.query,
            "result_count": qh.result_count,
            "workflow_type": qh.workflow_type,
            "created_at": qh.created_at.isoformat() if qh.created_at else None,
        }

    def decision_to_dict(self, decision: Decision) -> dict[str, Any]:
        """Convert Decision to JSON-serializable dict."""
        return {
            "id": str(decision.id),
            "decision": decision.decision,
            "alternatives": decision.alternatives,
            "rationale": decision.rationale,
            "created_at": decision.created_at.isoformat() if decision.created_at else None,
            "sources": [
                {"chunk_id": s.chunk_id, "relevance": s.relevance}
                for s in (decision.sources or [])
            ],
        }
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.db.repositories import ProjectRepository
repo = ProjectRepository()
print('ProjectRepository imports OK')
"
poetry run ruff check src/knowledge_mcp/db/repositories.py --select E,F,W
```
  </verify>
  <done>ProjectRepository imports and passes linting</done>
</task>

<task type="auto">
  <name>Task 2: Create PlanStrategy implementation</name>
  <files>src/knowledge_mcp/search/strategies/plan.py</files>
  <action>
Create the Plan strategy with search and capture operations:

```python
"""Planning workflow search strategy with project capture.

Provides template retrieval, risk identification, and precedent search
combined with comprehensive project capture capabilities.

Example:
    >>> from knowledge_mcp.search.strategies.plan import PlanStrategy
    >>> strategy = PlanStrategy()
    >>> output = strategy.format_output(results, {"include_risks": True})
"""

from __future__ import annotations

from typing import Any

from knowledge_mcp.search.models import SearchResult
from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy


class PlanStrategy(SearchStrategy):
    """Strategy for planning workflow with project capture.

    Searches for templates, risks, precedents, and lessons learned
    to support project planning activities. Also enables project
    capture operations for tracking context and decisions.

    Features:
    - Template and precedent retrieval
    - Risk identification and lessons learned
    - Project capture integration

    Example:
        >>> strategy = PlanStrategy()
        >>> output = strategy.format_output(results, {
        ...     "include_risks": True,
        ...     "include_lessons": True,
        ... })
    """

    # Keywords for planning-relevant content
    TEMPLATE_KEYWORDS = [
        "template",
        "checklist",
        "process",
        "procedure",
        "workflow",
        "plan",
        "guide",
    ]

    RISK_KEYWORDS = [
        "risk",
        "hazard",
        "mitigation",
        "contingency",
        "issue",
        "concern",
        "warning",
    ]

    LESSON_KEYWORDS = [
        "lesson learned",
        "lessons learned",
        "experience",
        "retrospective",
        "post-mortem",
        "insight",
        "recommendation",
    ]

    PRECEDENT_KEYWORDS = [
        "precedent",
        "previous",
        "similar project",
        "case study",
        "example",
        "prior art",
    ]

    async def preprocess_query(
        self,
        query: str,
        params: dict[str, Any],
    ) -> SearchQuery:
        """Expand query to cover planning aspects.

        Args:
            query: Planning topic or project type.
            params: Optional flags: include_risks, include_lessons, include_precedents.

        Returns:
            SearchQuery with planning-focused expansion.
        """
        expanded_terms = [
            f"{query} template",
            f"{query} checklist",
            f"{query} process",
        ]

        # Add optional aspects based on params
        if params.get("include_risks", True):
            expanded_terms.append(f"{query} risk mitigation")

        if params.get("include_lessons", True):
            expanded_terms.append(f"{query} lessons learned")

        if params.get("include_precedents", True):
            expanded_terms.append(f"{query} precedent example")

        return SearchQuery(
            original=query,
            expanded_terms=expanded_terms,
            filters=params.get("filters", {}),
            facets=["templates", "risks", "lessons", "precedents"],
        )

    def adjust_ranking(
        self,
        results: list[SearchResult],
    ) -> list[SearchResult]:
        """Boost actionable planning content.

        Args:
            results: Raw semantic search results.

        Returns:
            Re-ranked results with boosted planning content.
        """
        for result in results:
            boost = 1.0
            content_lower = result.content.lower()

            # Boost for templates and checklists
            for keyword in self.TEMPLATE_KEYWORDS:
                if keyword in content_lower:
                    boost += 0.05

            # Boost for risk content
            for keyword in self.RISK_KEYWORDS:
                if keyword in content_lower:
                    boost += 0.03

            # Boost for lessons learned
            for keyword in self.LESSON_KEYWORDS:
                if keyword in content_lower:
                    boost += 0.04

            # Extra boost for actionable content
            if any(word in content_lower for word in ["shall", "should", "must", "step", "action"]):
                boost += 0.05

            result.score = min(1.0, result.score * boost)

        return sorted(results, key=lambda r: r.score, reverse=True)

    def format_output(
        self,
        results: list[SearchResult],
        params: dict[str, Any],
    ) -> dict[str, Any]:
        """Organize results into planning categories.

        Args:
            results: Ranked search results.
            params: Original parameters.

        Returns:
            Dict with categorized planning resources.
        """
        # Categorize results
        templates: list[dict[str, Any]] = []
        risks: list[dict[str, Any]] = []
        lessons: list[dict[str, Any]] = []
        precedents: list[dict[str, Any]] = []

        for result in results:
            content_lower = result.content.lower()
            result_dict = self._result_to_dict(result)

            # Assign to categories (can belong to multiple)
            if any(kw in content_lower for kw in self.TEMPLATE_KEYWORDS):
                if len(templates) < 5:
                    templates.append(result_dict)

            if any(kw in content_lower for kw in self.RISK_KEYWORDS):
                if len(risks) < 5:
                    risks.append(result_dict)

            if any(kw in content_lower for kw in self.LESSON_KEYWORDS):
                if len(lessons) < 5:
                    lessons.append(result_dict)

            if any(kw in content_lower for kw in self.PRECEDENT_KEYWORDS):
                if len(precedents) < 5:
                    precedents.append(result_dict)

        return {
            "templates": templates,
            "risks": risks if params.get("include_risks", True) else [],
            "lessons_learned": lessons if params.get("include_lessons", True) else [],
            "precedents": precedents if params.get("include_precedents", True) else [],
            "result_type": "planning",
            "total_results": len(results),
            "categories": {
                "templates": len(templates),
                "risks": len(risks),
                "lessons_learned": len(lessons),
                "precedents": len(precedents),
            },
        }

    def _result_to_dict(self, result: SearchResult) -> dict[str, Any]:
        """Convert result to output dict."""
        return {
            "id": result.id,
            "content": result.content[:400] + "..." if len(result.content) > 400 else result.content,
            "score": result.score,
            "source": {
                "document_title": result.document_title,
                "section_title": result.section_title,
                "document_type": result.document_type,
                "clause_number": result.clause_number,
            },
        }
```

Update `strategies/__init__.py` to export PlanStrategy:
```python
from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy
from knowledge_mcp.search.strategies.explore import ExploreStrategy, Facet
from knowledge_mcp.search.strategies.plan import PlanStrategy
from knowledge_mcp.search.strategies.rcca import RCCAMetadata, RCCAStrategy
from knowledge_mcp.search.strategies.trade import (
    AlternativeEvaluation,
    CriteriaEvidence,
    TradeStudyStrategy,
)

__all__ = [
    "SearchStrategy",
    "SearchQuery",
    "RCCAStrategy",
    "RCCAMetadata",
    "TradeStudyStrategy",
    "CriteriaEvidence",
    "AlternativeEvaluation",
    "ExploreStrategy",
    "Facet",
    "PlanStrategy",
]
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.search.strategies import PlanStrategy
strategy = PlanStrategy()
print('PlanStrategy imports OK')
"
poetry run ruff check src/knowledge_mcp/search/strategies/plan.py --select E,F,W
```
  </verify>
  <done>PlanStrategy imports and passes linting</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for PlanStrategy and ProjectRepository</name>
  <files>tests/unit/test_search/test_plan_strategy.py</files>
  <action>
Create comprehensive tests for plan strategy:

```python
"""Unit tests for Plan search strategy."""

from __future__ import annotations

import pytest

from knowledge_mcp.search.models import SearchResult
from knowledge_mcp.search.strategies.plan import PlanStrategy


class TestPlanStrategy:
    """Tests for PlanStrategy."""

    @pytest.fixture
    def strategy(self) -> PlanStrategy:
        """Create plan strategy instance."""
        return PlanStrategy()

    @pytest.mark.asyncio
    async def test_preprocess_expands_for_templates(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """preprocess_query adds template-related terms."""
        result = await strategy.preprocess_query("SRR planning", {})

        assert result.original == "SRR planning"
        assert any("template" in term for term in result.expanded_terms)
        assert any("checklist" in term for term in result.expanded_terms)

    @pytest.mark.asyncio
    async def test_preprocess_includes_risks_by_default(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """preprocess_query includes risk terms by default."""
        result = await strategy.preprocess_query("test", {})

        assert any("risk" in term for term in result.expanded_terms)

    @pytest.mark.asyncio
    async def test_preprocess_excludes_risks_when_disabled(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """preprocess_query excludes risks when include_risks=False."""
        result = await strategy.preprocess_query("test", {"include_risks": False})

        assert not any("risk" in term for term in result.expanded_terms)

    @pytest.mark.asyncio
    async def test_preprocess_includes_lessons_by_default(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """preprocess_query includes lessons learned by default."""
        result = await strategy.preprocess_query("test", {})

        assert any("lessons" in term for term in result.expanded_terms)

    @pytest.mark.asyncio
    async def test_preprocess_includes_precedents_by_default(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """preprocess_query includes precedent terms by default."""
        result = await strategy.preprocess_query("test", {})

        assert any("precedent" in term for term in result.expanded_terms)

    def test_adjust_ranking_boosts_templates(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """adjust_ranking boosts template content."""
        results = [
            SearchResult(
                id="1",
                content="This is a template for SRR planning.",
                score=0.7,
            ),
            SearchResult(
                id="2",
                content="General information about reviews.",
                score=0.75,
            ),
        ]

        ranked = strategy.adjust_ranking(results)

        template_result = next(r for r in ranked if "template" in r.content)
        assert template_result.score > 0.7

    def test_adjust_ranking_boosts_actionable(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """adjust_ranking boosts actionable content."""
        results = [
            SearchResult(
                id="1",
                content="Step 1: Review requirements. Step 2: Verify traceability.",
                score=0.7,
            ),
        ]

        ranked = strategy.adjust_ranking(results)

        assert ranked[0].score > 0.7

    def test_format_output_categorizes_templates(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output categorizes template content."""
        results = [
            SearchResult(
                id="1",
                content="This checklist covers all SRR requirements.",
                score=0.9,
                document_title="SRR Guide",
            ),
        ]

        output = strategy.format_output(results, {})

        assert output["result_type"] == "planning"
        assert len(output["templates"]) >= 1

    def test_format_output_categorizes_risks(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output categorizes risk content."""
        results = [
            SearchResult(
                id="1",
                content="Risk: Schedule delays due to incomplete requirements. Mitigation: Early review.",
                score=0.85,
                document_title="Risk Register",
            ),
        ]

        output = strategy.format_output(results, {})

        assert len(output["risks"]) >= 1

    def test_format_output_categorizes_lessons(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output categorizes lessons learned."""
        results = [
            SearchResult(
                id="1",
                content="Lessons learned: Start requirements review earlier.",
                score=0.8,
                document_title="Project Retrospective",
            ),
        ]

        output = strategy.format_output(results, {})

        assert len(output["lessons_learned"]) >= 1

    def test_format_output_categorizes_precedents(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output categorizes precedent content."""
        results = [
            SearchResult(
                id="1",
                content="A similar project in 2023 used this approach.",
                score=0.75,
                document_title="Case Study",
            ),
        ]

        output = strategy.format_output(results, {})

        assert len(output["precedents"]) >= 1

    def test_format_output_respects_include_flags(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output respects include_* params."""
        results = [
            SearchResult(
                id="1",
                content="Risk: Something could go wrong.",
                score=0.8,
            ),
        ]

        output = strategy.format_output(results, {"include_risks": False})

        assert output["risks"] == []

    def test_format_output_limits_per_category(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output limits results per category."""
        results = [
            SearchResult(
                id=str(i),
                content=f"Template {i} for review checklist.",
                score=0.9 - i * 0.01,
            )
            for i in range(10)
        ]

        output = strategy.format_output(results, {})

        assert len(output["templates"]) <= 5

    def test_format_output_includes_categories_summary(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output includes category counts."""
        results = [
            SearchResult(
                id="1",
                content="Template checklist",
                score=0.9,
            ),
            SearchResult(
                id="2",
                content="Risk assessment",
                score=0.85,
            ),
        ]

        output = strategy.format_output(results, {})

        assert "categories" in output
        assert "templates" in output["categories"]
        assert "risks" in output["categories"]

    def test_format_output_truncates_content(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output truncates long content."""
        long_content = "Template: " + "A" * 500
        results = [
            SearchResult(
                id="1",
                content=long_content,
                score=0.9,
            ),
        ]

        output = strategy.format_output(results, {})

        result_content = output["templates"][0]["content"]
        assert len(result_content) <= 410  # 400 + "..."

    def test_format_output_includes_source_info(
        self,
        strategy: PlanStrategy,
    ) -> None:
        """format_output includes source citation."""
        results = [
            SearchResult(
                id="1",
                content="This template is from IEEE 15288.",
                score=0.9,
                document_title="IEEE 15288",
                section_title="Review Templates",
                document_type="standard",
                clause_number="6.4.2",
            ),
        ]

        output = strategy.format_output(results, {})

        source = output["templates"][0]["source"]
        assert source["document_title"] == "IEEE 15288"
        assert source["clause_number"] == "6.4.2"
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pytest tests/unit/test_search/test_plan_strategy.py -v
```
  </verify>
  <done>All plan strategy tests pass</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Both classes import correctly:
```bash
poetry run python -c "
from knowledge_mcp.search.strategies import PlanStrategy
from knowledge_mcp.db.repositories import ProjectRepository
print('Both classes import OK')
"
```

2. All tests pass:
```bash
poetry run pytest tests/unit/test_search/test_plan_strategy.py -v
```

3. Code quality:
```bash
poetry run ruff check src/knowledge_mcp/search/strategies/plan.py src/knowledge_mcp/db/repositories.py --select E,F,W
```
</verification>

<success_criteria>
- [ ] ProjectRepository provides async CRUD for projects, queries, decisions
- [ ] PlanStrategy extends SearchStrategy ABC
- [ ] preprocess_query expands for templates, risks, lessons, precedents
- [ ] format_output categorizes results into planning categories
- [ ] Include flags control which categories appear in output
- [ ] All unit tests pass
- [ ] Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-support/02-06-SUMMARY.md`
</output>
