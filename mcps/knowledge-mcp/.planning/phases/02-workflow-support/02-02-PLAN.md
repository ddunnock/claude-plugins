---
phase: 02-workflow-support
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/knowledge_mcp/search/strategies/__init__.py
  - src/knowledge_mcp/search/strategies/base.py
  - src/knowledge_mcp/search/workflow_search.py
autonomous: true

must_haves:
  truths:
    - "SearchStrategy ABC defines preprocess_query, adjust_ranking, format_output methods"
    - "SearchQuery dataclass holds original query, expanded terms, filters, and facets"
    - "WorkflowSearcher orchestrates search using strategy pattern"
    - "WorkflowSearcher.search() calls strategy methods in correct order"
  artifacts:
    - path: "src/knowledge_mcp/search/strategies/__init__.py"
      provides: "Module exports for strategies"
      contains: "SearchStrategy"
    - path: "src/knowledge_mcp/search/strategies/base.py"
      provides: "SearchStrategy ABC and SearchQuery dataclass"
      contains: "class SearchStrategy"
    - path: "src/knowledge_mcp/search/workflow_search.py"
      provides: "WorkflowSearcher orchestrator"
      contains: "class WorkflowSearcher"
  key_links:
    - from: "WorkflowSearcher"
      to: "SemanticSearcher"
      via: "composition"
      pattern: "self._searcher.*search"
    - from: "WorkflowSearcher.search"
      to: "SearchStrategy.preprocess_query"
      via: "method call"
      pattern: "strategy.preprocess_query"
---

<objective>
Create the strategy pattern foundation for workflow-specific search: SearchStrategy ABC, SearchQuery dataclass, and WorkflowSearcher orchestrator.

Purpose: Establish the extensible architecture that enables adding new workflow strategies without modifying the core search code. This is the template method pattern where the algorithm structure is fixed but steps are customizable.

Output: Strategy base classes and workflow orchestrator that Phase 2 plans 03-06 will implement concrete strategies for.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-workflow-support/02-RESEARCH.md
@.planning/phases/02-workflow-support/02-CONTEXT.md

# Existing search architecture
@src/knowledge_mcp/search/semantic_search.py
@src/knowledge_mcp/search/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SearchStrategy ABC and SearchQuery dataclass</name>
  <files>src/knowledge_mcp/search/strategies/base.py, src/knowledge_mcp/search/strategies/__init__.py</files>
  <action>
Create the strategies directory and base module:

**strategies/__init__.py**:
```python
"""Workflow-specific search strategies.

This module provides the strategy pattern implementation for specialized
retrieval across different systems engineering workflows.

Example:
    >>> from knowledge_mcp.search.strategies import SearchStrategy, SearchQuery
    >>> from knowledge_mcp.search.strategies.rcca import RCCAStrategy
"""

from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy

__all__ = ["SearchStrategy", "SearchQuery"]
```

**strategies/base.py**:
```python
"""Base classes for workflow search strategies.

Defines the SearchStrategy abstract base class and SearchQuery dataclass
used by all workflow-specific search implementations.

The strategy pattern allows customizing:
1. Query preprocessing (expansion, faceting)
2. Ranking adjustments (boost domain-specific fields)
3. Output formatting (structured metadata)
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from knowledge_mcp.search.models import SearchResult


@dataclass
class SearchQuery:
    """Internal representation of a processed query.

    Holds the original query along with any expansions, filters,
    and facets added by strategy preprocessing.

    Attributes:
        original: The original query string from the user.
        expanded_terms: Additional query terms for broader search.
        filters: Metadata filters to apply (e.g., document_type).
        facets: Named facets for multi-aspect search (e.g., "definitions").
    """

    original: str
    expanded_terms: list[str] = field(default_factory=list)
    filters: dict[str, Any] = field(default_factory=dict)
    facets: list[str] = field(default_factory=list)


class SearchStrategy(ABC):
    """Abstract base class for workflow-specific search strategies.

    Strategies customize three phases of the search process:
    1. Query preprocessing - expand terms, add filters, define facets
    2. Ranking adjustments - boost results matching domain criteria
    3. Output formatting - structure results for specific workflow needs

    Subclasses must implement all three abstract methods.

    Example:
        >>> class MyStrategy(SearchStrategy):
        ...     async def preprocess_query(self, query, params):
        ...         return SearchQuery(original=query)
        ...
        ...     def adjust_ranking(self, results):
        ...         return results
        ...
        ...     def format_output(self, results, params):
        ...         return {"results": [r.content for r in results]}
    """

    @abstractmethod
    async def preprocess_query(
        self,
        query: str,
        params: dict[str, Any],
    ) -> SearchQuery:
        """Transform user query into internal search representation.

        Args:
            query: Natural language query from user.
            params: Tool-specific parameters (filters, options, alternatives).

        Returns:
            SearchQuery with expanded terms, filters, and facets.

        Note:
            This method is async to allow for LLM-based query expansion
            in future implementations.
        """
        pass

    @abstractmethod
    def adjust_ranking(
        self,
        results: list[SearchResult],
    ) -> list[SearchResult]:
        """Apply strategy-specific ranking adjustments.

        Args:
            results: Raw semantic search results from SemanticSearcher.

        Returns:
            Reranked results with strategy-specific score adjustments.

        Note:
            Implementations should modify result.score and re-sort.
            Scores should remain in 0-1 range.
        """
        pass

    @abstractmethod
    def format_output(
        self,
        results: list[SearchResult],
        params: dict[str, Any],
    ) -> dict[str, Any]:
        """Structure output according to strategy requirements.

        Args:
            results: Ranked search results.
            params: Original tool parameters (for context like alternatives list).

        Returns:
            Formatted dict suitable for MCP tool response.

        Note:
            Output must be JSON-serializable. Include result_type field
            to identify the workflow (e.g., "rcca_analysis", "trade_study").
        """
        pass
```

Create `__init__.py` in strategies directory to make it a package.
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.search.strategies import SearchStrategy, SearchQuery
from abc import ABC
assert issubclass(SearchStrategy, ABC)
q = SearchQuery(original='test')
print('Strategy base imports OK')
"
poetry run ruff check src/knowledge_mcp/search/strategies/ --select E,F,W
```
  </verify>
  <done>SearchStrategy ABC and SearchQuery dataclass exist and import correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create WorkflowSearcher orchestrator</name>
  <files>src/knowledge_mcp/search/workflow_search.py</files>
  <action>
Create the workflow search orchestrator that uses strategies:

```python
"""Workflow search orchestrator using strategy pattern.

This module provides the WorkflowSearcher class that orchestrates
specialized searches by delegating to strategy objects.

The template method pattern defines the search algorithm structure:
1. Preprocess query (strategy)
2. Execute semantic search (shared)
3. Adjust ranking (strategy)
4. Format output (strategy)

Example:
    >>> from knowledge_mcp.search import SemanticSearcher
    >>> from knowledge_mcp.search.workflow_search import WorkflowSearcher
    >>> from knowledge_mcp.search.strategies.rcca import RCCAStrategy
    >>>
    >>> searcher = WorkflowSearcher(semantic_searcher, RCCAStrategy())
    >>> results = await searcher.search("power supply failure")
"""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from knowledge_mcp.search.semantic_search import SemanticSearcher
    from knowledge_mcp.search.strategies.base import SearchStrategy

logger = logging.getLogger(__name__)


class WorkflowSearcher:
    """Orchestrates workflow-specific searches using strategy pattern.

    Combines a shared SemanticSearcher with interchangeable strategies
    to provide specialized retrieval for different workflows.

    Attributes:
        searcher: The underlying semantic search implementation.
        strategy: The workflow-specific search strategy.

    Example:
        >>> from knowledge_mcp.search.strategies.trade import TradeStudyStrategy
        >>>
        >>> workflow = WorkflowSearcher(semantic_searcher, TradeStudyStrategy())
        >>> results = await workflow.search(
        ...     query="database comparison",
        ...     params={"alternatives": ["PostgreSQL", "MongoDB"]}
        ... )
    """

    def __init__(
        self,
        searcher: SemanticSearcher,
        strategy: SearchStrategy,
    ) -> None:
        """Initialize workflow searcher.

        Args:
            searcher: Semantic search implementation for vector similarity.
            strategy: Workflow-specific strategy for customization.
        """
        self._searcher = searcher
        self._strategy = strategy

    @property
    def strategy(self) -> SearchStrategy:
        """Get the current search strategy."""
        return self._strategy

    def set_strategy(self, strategy: SearchStrategy) -> None:
        """Change the search strategy at runtime.

        Args:
            strategy: New workflow strategy to use.

        Example:
            >>> workflow.set_strategy(ExploreStrategy())
        """
        self._strategy = strategy

    async def search(
        self,
        query: str,
        params: dict[str, Any] | None = None,
        n_results: int = 10,
        score_threshold: float = 0.0,
    ) -> dict[str, Any]:
        """Execute workflow-specific search.

        Template method that defines the search algorithm:
        1. Preprocess query using strategy
        2. Execute semantic search
        3. Adjust ranking using strategy
        4. Format output using strategy

        Args:
            query: Natural language search query.
            params: Strategy-specific parameters (varies by workflow).
            n_results: Maximum results to return. Defaults to 10.
            score_threshold: Minimum similarity score. Defaults to 0.0.

        Returns:
            Formatted dict from strategy.format_output().
            Always includes "result_type" and "total_results" fields.

        Example:
            >>> results = await workflow.search(
            ...     query="requirements traceability",
            ...     params={"facets": ["definitions", "examples"]},
            ...     n_results=20,
            ... )
        """
        params = params or {}

        try:
            # 1. Preprocess query (strategy-specific)
            search_query = await self._strategy.preprocess_query(query, params)
            logger.debug(
                "Preprocessed query: original=%s, expanded=%d terms, filters=%s",
                search_query.original[:50],
                len(search_query.expanded_terms),
                list(search_query.filters.keys()),
            )

            # 2. Execute semantic search (shared core)
            results = await self._searcher.search(
                query=search_query.original,
                n_results=n_results,
                filter_dict=search_query.filters if search_query.filters else None,
                score_threshold=score_threshold,
            )
            logger.debug("Semantic search returned %d results", len(results))

            # 3. Adjust ranking (strategy-specific)
            ranked_results = self._strategy.adjust_ranking(results)

            # 4. Format output (strategy-specific)
            output = self._strategy.format_output(ranked_results, params)

            # Ensure standard fields
            if "total_results" not in output:
                output["total_results"] = len(ranked_results)

            return output

        except Exception as e:
            logger.error("Workflow search failed: %s", e)
            return {
                "error": str(e),
                "result_type": "error",
                "total_results": 0,
            }
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.search.workflow_search import WorkflowSearcher
print('WorkflowSearcher imports OK')
"
poetry run ruff check src/knowledge_mcp/search/workflow_search.py --select E,F,W
```
  </verify>
  <done>WorkflowSearcher class exists with search() method that calls strategy methods in order</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for strategy base and orchestrator</name>
  <files>tests/unit/test_search/test_workflow_search.py</files>
  <action>
Create test file for the strategy pattern foundation:

```python
"""Unit tests for workflow search orchestrator and strategy base."""

from __future__ import annotations

from typing import Any
from unittest.mock import AsyncMock, MagicMock

import pytest

from knowledge_mcp.search.models import SearchResult
from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy
from knowledge_mcp.search.workflow_search import WorkflowSearcher


class MockStrategy(SearchStrategy):
    """Concrete strategy for testing."""

    async def preprocess_query(
        self,
        query: str,
        params: dict[str, Any],
    ) -> SearchQuery:
        return SearchQuery(
            original=query,
            expanded_terms=[f"{query} expanded"],
            filters=params.get("filters", {}),
        )

    def adjust_ranking(
        self,
        results: list[SearchResult],
    ) -> list[SearchResult]:
        # Boost scores by 10%
        for r in results:
            r.score = min(1.0, r.score * 1.1)
        return sorted(results, key=lambda r: r.score, reverse=True)

    def format_output(
        self,
        results: list[SearchResult],
        params: dict[str, Any],
    ) -> dict[str, Any]:
        return {
            "results": [{"content": r.content, "score": r.score} for r in results],
            "result_type": "mock",
            "total_results": len(results),
        }


class TestSearchQuery:
    """Tests for SearchQuery dataclass."""

    def test_defaults(self) -> None:
        """SearchQuery has sensible defaults."""
        q = SearchQuery(original="test")
        assert q.original == "test"
        assert q.expanded_terms == []
        assert q.filters == {}
        assert q.facets == []

    def test_with_all_fields(self) -> None:
        """SearchQuery accepts all fields."""
        q = SearchQuery(
            original="test",
            expanded_terms=["test expanded"],
            filters={"type": "standard"},
            facets=["definitions"],
        )
        assert len(q.expanded_terms) == 1
        assert q.filters["type"] == "standard"


class TestWorkflowSearcher:
    """Tests for WorkflowSearcher orchestrator."""

    @pytest.fixture
    def mock_semantic_searcher(self) -> MagicMock:
        """Create mock semantic searcher."""
        searcher = MagicMock()
        searcher.search = AsyncMock(
            return_value=[
                SearchResult(id="1", content="Result 1", score=0.9),
                SearchResult(id="2", content="Result 2", score=0.8),
            ]
        )
        return searcher

    @pytest.fixture
    def mock_strategy(self) -> MockStrategy:
        """Create mock strategy."""
        return MockStrategy()

    @pytest.fixture
    def workflow_searcher(
        self,
        mock_semantic_searcher: MagicMock,
        mock_strategy: MockStrategy,
    ) -> WorkflowSearcher:
        """Create workflow searcher with mocks."""
        return WorkflowSearcher(mock_semantic_searcher, mock_strategy)

    @pytest.mark.asyncio
    async def test_search_calls_strategy_preprocess(
        self,
        workflow_searcher: WorkflowSearcher,
    ) -> None:
        """Search calls strategy preprocess_query."""
        result = await workflow_searcher.search("test query")
        assert result["result_type"] == "mock"

    @pytest.mark.asyncio
    async def test_search_calls_semantic_search(
        self,
        workflow_searcher: WorkflowSearcher,
        mock_semantic_searcher: MagicMock,
    ) -> None:
        """Search calls underlying semantic searcher."""
        await workflow_searcher.search("test query")
        mock_semantic_searcher.search.assert_called_once()

    @pytest.mark.asyncio
    async def test_search_applies_ranking_adjustment(
        self,
        workflow_searcher: WorkflowSearcher,
    ) -> None:
        """Search applies strategy ranking adjustment."""
        result = await workflow_searcher.search("test query")
        # MockStrategy boosts scores by 10%
        assert result["results"][0]["score"] == pytest.approx(0.99, rel=0.01)

    @pytest.mark.asyncio
    async def test_search_returns_formatted_output(
        self,
        workflow_searcher: WorkflowSearcher,
    ) -> None:
        """Search returns strategy-formatted output."""
        result = await workflow_searcher.search("test query")
        assert "results" in result
        assert "result_type" in result
        assert result["total_results"] == 2

    @pytest.mark.asyncio
    async def test_search_handles_empty_results(
        self,
        mock_strategy: MockStrategy,
    ) -> None:
        """Search handles empty results gracefully."""
        searcher = MagicMock()
        searcher.search = AsyncMock(return_value=[])
        workflow = WorkflowSearcher(searcher, mock_strategy)

        result = await workflow.search("obscure query")
        assert result["total_results"] == 0

    @pytest.mark.asyncio
    async def test_search_passes_params_to_strategy(
        self,
        workflow_searcher: WorkflowSearcher,
        mock_semantic_searcher: MagicMock,
    ) -> None:
        """Search passes params to strategy methods."""
        params = {"filters": {"document_type": "standard"}}
        await workflow_searcher.search("test", params=params)

        # Verify filters were passed to semantic search
        call_kwargs = mock_semantic_searcher.search.call_args.kwargs
        assert call_kwargs.get("filter_dict") == {"document_type": "standard"}

    def test_set_strategy(
        self,
        workflow_searcher: WorkflowSearcher,
    ) -> None:
        """Can change strategy at runtime."""
        new_strategy = MockStrategy()
        workflow_searcher.set_strategy(new_strategy)
        assert workflow_searcher.strategy is new_strategy

    @pytest.mark.asyncio
    async def test_search_handles_errors(
        self,
        mock_strategy: MockStrategy,
    ) -> None:
        """Search returns error dict on exception."""
        searcher = MagicMock()
        searcher.search = AsyncMock(side_effect=Exception("Connection failed"))
        workflow = WorkflowSearcher(searcher, mock_strategy)

        result = await workflow.search("test")
        assert "error" in result
        assert result["result_type"] == "error"
```

Ensure test directory exists: `tests/unit/test_search/`
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pytest tests/unit/test_search/test_workflow_search.py -v
```
  </verify>
  <done>All unit tests pass, verifying strategy pattern and orchestrator behavior</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Strategy base imports:
```bash
poetry run python -c "
from knowledge_mcp.search.strategies import SearchStrategy, SearchQuery
from knowledge_mcp.search.workflow_search import WorkflowSearcher
print('All imports OK')
"
```

2. All tests pass:
```bash
poetry run pytest tests/unit/test_search/test_workflow_search.py -v
```

3. Code quality:
```bash
poetry run ruff check src/knowledge_mcp/search/strategies/ src/knowledge_mcp/search/workflow_search.py --select E,F,W
```
</verification>

<success_criteria>
- [ ] SearchStrategy ABC with preprocess_query, adjust_ranking, format_output methods
- [ ] SearchQuery dataclass with original, expanded_terms, filters, facets fields
- [ ] WorkflowSearcher orchestrates search using strategy pattern
- [ ] WorkflowSearcher.search() calls methods in correct order: preprocess -> search -> rank -> format
- [ ] All unit tests pass
- [ ] Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-support/02-02-SUMMARY.md`
</output>
