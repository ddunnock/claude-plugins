---
phase: 02-workflow-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_mcp/db/models.py
  - src/knowledge_mcp/db/migrations/versions/002_project_capture.py
autonomous: true

must_haves:
  truths:
    - "Project model exists with name, domain, status, applicable_standards fields"
    - "QueryHistory model links queries to projects with result_count"
    - "Decision model stores decision, alternatives, rationale with project link"
    - "DecisionSource links decisions to supporting chunk IDs"
    - "Project state machine enforces valid transitions (PLANNING->ACTIVE->COMPLETED/ABANDONED)"
    - "Migration creates all tables with proper foreign keys and indexes"
  artifacts:
    - path: "src/knowledge_mcp/db/models.py"
      provides: "Project, ProjectStatus, QueryHistory, Decision, DecisionSource models"
      contains: "class Project"
    - path: "src/knowledge_mcp/db/migrations/versions/002_project_capture.py"
      provides: "Migration for project capture tables"
      contains: "def upgrade"
  key_links:
    - from: "QueryHistory.project_id"
      to: "Project.id"
      via: "ForeignKey"
      pattern: "ForeignKey.*projects.id"
    - from: "Decision.project_id"
      to: "Project.id"
      via: "ForeignKey"
      pattern: "ForeignKey.*projects.id"
    - from: "DecisionSource.decision_id"
      to: "Decision.id"
      via: "ForeignKey"
      pattern: "ForeignKey.*decisions.id"
---

<objective>
Add PostgreSQL models for project capture workflow: projects, query history, decisions, and decision sources.

Purpose: Enable tracking of project context, search history, and decision rationale with source links - forms the foundation for knowledge_plan tool's comprehensive capture capability.

Output: Extended db/models.py with 4 new ORM models and Alembic migration for schema creation.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-workflow-support/02-RESEARCH.md
@.planning/phases/02-workflow-support/02-CONTEXT.md
@.planning/phases/01-core-acquisition/01-03-SUMMARY.md

# Existing models pattern
@src/knowledge_mcp/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project capture models to db/models.py</name>
  <files>src/knowledge_mcp/db/models.py</files>
  <action>
Add the following models to the existing models.py file, following the established patterns:

1. **ProjectStatus enum** (str, Enum) with values:
   - PLANNING = "planning"
   - ACTIVE = "active"
   - COMPLETED = "completed"
   - ABANDONED = "abandoned"

2. **STATE_TRANSITIONS dict** mapping valid state transitions:
   - PLANNING -> [ACTIVE, ABANDONED]
   - ACTIVE -> [COMPLETED, ABANDONED]
   - COMPLETED -> [] (terminal)
   - ABANDONED -> [] (terminal)

3. **Project model**:
   - id: UUID primary key (use uuid4 default)
   - name: String(255), not null
   - domain: String(255), nullable (e.g., "aerospace", "medical")
   - status: ProjectStatus enum, default PLANNING
   - applicable_standards: ARRAY(String), nullable (e.g., ["IEEE 15288", "DO-178C"])
   - description: Text, nullable
   - created_at: DateTime(timezone=True), server_default now
   - updated_at: DateTime(timezone=True), server_default now, onupdate
   - completed_at: DateTime(timezone=True), nullable

   Add methods:
   - `can_transition_to(new_status: ProjectStatus) -> bool`
   - `transition_to(new_status: ProjectStatus) -> None` (raises ValueError on invalid)

4. **QueryHistory model**:
   - id: UUID primary key
   - project_id: UUID ForeignKey("projects.id")
   - query: Text, not null
   - result_count: Integer, not null
   - workflow_type: String(50), nullable (e.g., "rcca", "trade", "explore", "plan")
   - created_at: DateTime(timezone=True), server_default now

   Add relationship: `project: Mapped["Project"]`

5. **Decision model**:
   - id: UUID primary key
   - project_id: UUID ForeignKey("projects.id")
   - decision: Text, not null (what was decided)
   - alternatives: ARRAY(String), nullable (what else was considered)
   - rationale: Text, not null (why this choice)
   - created_at: DateTime(timezone=True), server_default now

   Add relationships:
   - `project: Mapped["Project"]`
   - `sources: Mapped[list["DecisionSource"]]`

6. **DecisionSource model**:
   - id: UUID primary key
   - decision_id: UUID ForeignKey("decisions.id")
   - chunk_id: String(255), not null (references Qdrant chunk UUID)
   - relevance: Float, not null (0.0-1.0)

   Add relationship: `decision: Mapped["Decision"]`

Import UUID from uuid, add `from uuid import uuid4` and `from sqlalchemy.dialects.postgresql import UUID as PGUUID, ARRAY`.

Use native_enum=False for ProjectStatus enum (matching existing pattern).
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "from knowledge_mcp.db.models import Project, ProjectStatus, QueryHistory, Decision, DecisionSource; print('Models import OK')"
poetry run ruff check src/knowledge_mcp/db/models.py --select E,F,W --ignore E501
```
  </verify>
  <done>All 4 models import successfully, Project.can_transition_to and transition_to methods exist</done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for project capture tables</name>
  <files>src/knowledge_mcp/db/migrations/versions/002_project_capture.py</files>
  <action>
Create migration file `002_project_capture.py` in migrations/versions/ directory.

Follow the pattern from 001_initial_schema.py:
- revision = "002"
- down_revision = "001"
- Use `op.create_table()` for each table
- Use VARCHAR with CHECK constraints for ProjectStatus enum (not native)
- Add foreign key constraints
- Add indexes on frequently queried columns

Tables to create:

1. **projects**:
   - id UUID primary key (default gen_random_uuid())
   - name VARCHAR(255) NOT NULL
   - domain VARCHAR(255) NULLABLE
   - status VARCHAR(50) NOT NULL DEFAULT 'planning' with CHECK constraint
   - applicable_standards VARCHAR[] NULLABLE
   - description TEXT NULLABLE
   - created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   - updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   - completed_at TIMESTAMP WITH TIME ZONE NULLABLE
   - Index on status

2. **query_history**:
   - id UUID primary key
   - project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE
   - query TEXT NOT NULL
   - result_count INTEGER NOT NULL
   - workflow_type VARCHAR(50) NULLABLE
   - created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   - Index on project_id
   - Index on workflow_type

3. **decisions**:
   - id UUID primary key
   - project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE
   - decision TEXT NOT NULL
   - alternatives VARCHAR[] NULLABLE
   - rationale TEXT NOT NULL
   - created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
   - Index on project_id

4. **decision_sources**:
   - id UUID primary key
   - decision_id UUID NOT NULL REFERENCES decisions(id) ON DELETE CASCADE
   - chunk_id VARCHAR(255) NOT NULL
   - relevance FLOAT NOT NULL
   - Index on decision_id
   - Index on chunk_id

Use `op.drop_table()` in downgrade() in reverse order (decision_sources, decisions, query_history, projects).
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "from knowledge_mcp.db.migrations.versions import __file__; print('Migrations module OK')" || echo "Migrations are standalone files"
# Check migration syntax
poetry run python -c "
import ast
with open('src/knowledge_mcp/db/migrations/versions/002_project_capture.py') as f:
    ast.parse(f.read())
print('Migration syntax OK')
"
```
  </verify>
  <done>Migration file exists with upgrade() and downgrade() functions, creates all 4 tables with proper constraints and indexes</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for Project state machine</name>
  <files>tests/unit/test_db/test_models.py</files>
  <action>
Create test file for database models focusing on Project state machine:

```python
"""Unit tests for database models."""

import pytest
from knowledge_mcp.db.models import (
    Project,
    ProjectStatus,
    STATE_TRANSITIONS,
)


class TestProjectStateMachine:
    """Tests for Project state transitions."""

    def test_state_transitions_defined(self) -> None:
        """All states have transition rules."""
        for status in ProjectStatus:
            assert status in STATE_TRANSITIONS

    def test_planning_can_transition_to_active(self) -> None:
        """Planning projects can become active."""
        project = Project(name="Test", status=ProjectStatus.PLANNING)
        assert project.can_transition_to(ProjectStatus.ACTIVE) is True

    def test_planning_can_transition_to_abandoned(self) -> None:
        """Planning projects can be abandoned."""
        project = Project(name="Test", status=ProjectStatus.PLANNING)
        assert project.can_transition_to(ProjectStatus.ABANDONED) is True

    def test_planning_cannot_transition_to_completed(self) -> None:
        """Planning projects cannot skip to completed."""
        project = Project(name="Test", status=ProjectStatus.PLANNING)
        assert project.can_transition_to(ProjectStatus.COMPLETED) is False

    def test_active_can_transition_to_completed(self) -> None:
        """Active projects can be completed."""
        project = Project(name="Test", status=ProjectStatus.ACTIVE)
        assert project.can_transition_to(ProjectStatus.COMPLETED) is True

    def test_completed_is_terminal(self) -> None:
        """Completed is a terminal state."""
        project = Project(name="Test", status=ProjectStatus.COMPLETED)
        for status in ProjectStatus:
            assert project.can_transition_to(status) is False

    def test_abandoned_is_terminal(self) -> None:
        """Abandoned is a terminal state."""
        project = Project(name="Test", status=ProjectStatus.ABANDONED)
        for status in ProjectStatus:
            assert project.can_transition_to(status) is False

    def test_transition_to_valid_updates_status(self) -> None:
        """Valid transition updates status."""
        project = Project(name="Test", status=ProjectStatus.PLANNING)
        project.transition_to(ProjectStatus.ACTIVE)
        assert project.status == ProjectStatus.ACTIVE

    def test_transition_to_invalid_raises(self) -> None:
        """Invalid transition raises ValueError."""
        project = Project(name="Test", status=ProjectStatus.PLANNING)
        with pytest.raises(ValueError, match="Invalid transition"):
            project.transition_to(ProjectStatus.COMPLETED)
```

Create the test directory if needed: `tests/unit/test_db/`
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pytest tests/unit/test_db/test_models.py -v
```
  </verify>
  <done>All state machine tests pass, covering valid transitions, terminal states, and error cases</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Models import correctly:
```bash
poetry run python -c "
from knowledge_mcp.db.models import (
    Project, ProjectStatus, QueryHistory, Decision, DecisionSource,
    STATE_TRANSITIONS
)
p = Project(name='Test')
assert p.can_transition_to(ProjectStatus.ACTIVE)
print('Project state machine works')
"
```

2. Migration file is valid Python:
```bash
poetry run python -c "
import ast
with open('src/knowledge_mcp/db/migrations/versions/002_project_capture.py') as f:
    ast.parse(f.read())
print('Migration syntax valid')
"
```

3. All tests pass:
```bash
poetry run pytest tests/unit/test_db/ -v
```

4. Code quality:
```bash
poetry run ruff check src/knowledge_mcp/db/models.py --select E,F,W --ignore E501
```
</verification>

<success_criteria>
- [ ] Project, ProjectStatus, QueryHistory, Decision, DecisionSource models defined
- [ ] STATE_TRANSITIONS dict maps all valid state changes
- [ ] Project.can_transition_to() and transition_to() methods work correctly
- [ ] Migration 002 creates all 4 tables with foreign keys and indexes
- [ ] Unit tests verify state machine behavior
- [ ] All tests pass
- [ ] Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-support/02-01-SUMMARY.md`
</output>
