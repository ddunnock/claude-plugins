---
phase: 02-workflow-support
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/knowledge_mcp/search/strategies/rcca.py
  - tests/unit/test_search/test_rcca_strategy.py
autonomous: true

must_haves:
  truths:
    - "RCCAStrategy searches symptoms and root causes simultaneously (unified)"
    - "RCCAStrategy extracts structured metadata: symptoms, root_cause, contributing_factors, resolution"
    - "RCCAStrategy boosts results containing RCCA keywords"
    - "Format output includes rcca_metadata for each result"
  artifacts:
    - path: "src/knowledge_mcp/search/strategies/rcca.py"
      provides: "RCCAStrategy and RCCAMetadata classes"
      contains: "class RCCAStrategy"
    - path: "tests/unit/test_search/test_rcca_strategy.py"
      provides: "Unit tests for RCCA strategy"
      contains: "class TestRCCAStrategy"
  key_links:
    - from: "RCCAStrategy"
      to: "SearchStrategy"
      via: "inheritance"
      pattern: "class RCCAStrategy.*SearchStrategy"
---

<objective>
Implement RCCAStrategy for Root Cause Corrective Action workflow searches.

Purpose: Provide unified symptom/cause search with structured metadata extraction, enabling Claude to synthesize failure analysis from search results.

Output: RCCAStrategy class that extracts symptoms, root causes, contributing factors, and resolutions from content.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-workflow-support/02-RESEARCH.md
@.planning/phases/02-workflow-support/02-CONTEXT.md

# Strategy base (from 02-02)
@src/knowledge_mcp/search/strategies/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RCCAStrategy implementation</name>
  <files>src/knowledge_mcp/search/strategies/rcca.py</files>
  <action>
Create the RCCA strategy following the research document patterns:

```python
"""RCCA (Root Cause Corrective Action) search strategy.

Provides unified search across symptoms and root causes with
structured metadata extraction for failure analysis workflows.

Example:
    >>> from knowledge_mcp.search.strategies.rcca import RCCAStrategy
    >>> strategy = RCCAStrategy()
    >>> query = await strategy.preprocess_query("power supply failure", {})
    >>> # Returns SearchQuery with expanded terms for symptoms and causes
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from typing import Any

from knowledge_mcp.search.models import SearchResult
from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy


@dataclass
class RCCAMetadata:
    """Extracted structured fields from RCCA content.

    Attributes:
        symptoms: Observable behaviors, error messages, or failure indicators.
        root_cause: Underlying cause identified in the content.
        contributing_factors: Secondary causes or conditions.
        resolution: How the issue was resolved or mitigated.
    """

    symptoms: list[str] = field(default_factory=list)
    root_cause: str | None = None
    contributing_factors: list[str] = field(default_factory=list)
    resolution: str | None = None


class RCCAStrategy(SearchStrategy):
    """Strategy for Root Cause Corrective Action searches.

    Implements unified search that finds both symptom descriptions
    and root cause analyses simultaneously, then extracts structured
    metadata from results.

    Features:
    - Query expansion to cover symptoms, causes, and resolutions
    - Keyword boosting for RCCA-relevant terms
    - Metadata extraction using heuristics and regex

    Example:
        >>> strategy = RCCAStrategy()
        >>> results = strategy.adjust_ranking(raw_results)
        >>> output = strategy.format_output(results, {})
        >>> print(output["result_type"])  # "rcca_analysis"
    """

    # Keywords that indicate RCCA-relevant content
    BOOST_KEYWORDS = [
        "root cause",
        "failure",
        "corrective action",
        "symptom",
        "fault",
        "defect",
        "anomaly",
        "incident",
        "problem",
        "resolution",
    ]

    # Patterns for metadata extraction
    SYMPTOM_PATTERNS = [
        r"symptom[s]?:?\s*(.+?)(?:\n|$)",
        r"observed:?\s*(.+?)(?:\n|$)",
        r"error[s]?:?\s*(.+?)(?:\n|$)",
        r"indicator[s]?:?\s*(.+?)(?:\n|$)",
    ]

    ROOT_CAUSE_PATTERNS = [
        r"root cause:?\s*(.+?)(?:\n|$)",
        r"cause:?\s*(.+?)(?:\n|$)",
        r"determined that:?\s*(.+?)(?:\n|$)",
    ]

    CONTRIBUTING_PATTERNS = [
        r"contributing factor[s]?:?\s*(.+?)(?:\n|$)",
        r"contributing cause[s]?:?\s*(.+?)(?:\n|$)",
        r"also caused by:?\s*(.+?)(?:\n|$)",
    ]

    RESOLUTION_PATTERNS = [
        r"resolution:?\s*(.+?)(?:\n|$)",
        r"corrective action:?\s*(.+?)(?:\n|$)",
        r"fixed by:?\s*(.+?)(?:\n|$)",
        r"mitigation:?\s*(.+?)(?:\n|$)",
    ]

    async def preprocess_query(
        self,
        query: str,
        params: dict[str, Any],
    ) -> SearchQuery:
        """Expand query to cover symptoms, causes, and resolutions.

        Args:
            query: User's failure description or search terms.
            params: Optional parameters (currently unused for RCCA).

        Returns:
            SearchQuery with expanded terms for unified search.
        """
        # Build expanded query terms
        expanded_terms = [
            f"{query} symptoms",
            f"{query} root cause",
            f"{query} failure analysis",
            f"{query} corrective action",
        ]

        # Default to standards and handbooks for RCCA content
        filters = params.get("filters", {})
        if "document_type" not in filters:
            filters["document_type"] = ["standard", "handbook"]

        return SearchQuery(
            original=query,
            expanded_terms=expanded_terms,
            filters=filters,
        )

    def adjust_ranking(
        self,
        results: list[SearchResult],
    ) -> list[SearchResult]:
        """Boost results containing RCCA-specific keywords.

        Args:
            results: Raw semantic search results.

        Returns:
            Re-ranked results with boosted RCCA content.
        """
        for result in results:
            boost = 1.0
            content_lower = result.content.lower()

            # Boost for each RCCA keyword found
            for keyword in self.BOOST_KEYWORDS:
                if keyword in content_lower:
                    boost += 0.05  # 5% boost per keyword

            # Extra boost for structured RCCA content
            if "root cause:" in content_lower or "corrective action:" in content_lower:
                boost += 0.1

            # Apply boost, cap at 1.0
            result.score = min(1.0, result.score * boost)

        return sorted(results, key=lambda r: r.score, reverse=True)

    def format_output(
        self,
        results: list[SearchResult],
        params: dict[str, Any],
    ) -> dict[str, Any]:
        """Extract RCCA metadata and structure output.

        Args:
            results: Ranked search results.
            params: Original parameters (unused for RCCA).

        Returns:
            Dict with results including rcca_metadata for each.
        """
        formatted_results = []

        for result in results:
            metadata = self._extract_rcca_metadata(result.content)
            formatted_results.append({
                "id": result.id,
                "content": result.content,
                "score": result.score,
                "source": {
                    "document_title": result.document_title,
                    "section_title": result.section_title,
                    "document_type": result.document_type,
                    "clause_number": result.clause_number,
                },
                "rcca_metadata": {
                    "symptoms": metadata.symptoms,
                    "root_cause": metadata.root_cause,
                    "contributing_factors": metadata.contributing_factors,
                    "resolution": metadata.resolution,
                    "has_structured_data": bool(
                        metadata.symptoms or metadata.root_cause or metadata.resolution
                    ),
                },
            })

        return {
            "results": formatted_results,
            "result_type": "rcca_analysis",
            "total_results": len(formatted_results),
            "query_expansion": [
                "symptoms",
                "root cause",
                "failure analysis",
                "corrective action",
            ],
        }

    def _extract_rcca_metadata(self, content: str) -> RCCAMetadata:
        """Parse content for RCCA fields using heuristics.

        Uses regex patterns to extract structured information
        from semi-structured content.

        Args:
            content: Text content to analyze.

        Returns:
            RCCAMetadata with extracted fields.
        """
        symptoms = self._extract_by_patterns(content, self.SYMPTOM_PATTERNS)
        contributing = self._extract_by_patterns(content, self.CONTRIBUTING_PATTERNS)

        root_cause = None
        for pattern in self.ROOT_CAUSE_PATTERNS:
            if match := re.search(pattern, content, re.IGNORECASE):
                root_cause = match.group(1).strip()
                break

        resolution = None
        for pattern in self.RESOLUTION_PATTERNS:
            if match := re.search(pattern, content, re.IGNORECASE):
                resolution = match.group(1).strip()
                break

        return RCCAMetadata(
            symptoms=symptoms[:5],  # Limit to top 5
            root_cause=root_cause,
            contributing_factors=contributing[:5],
            resolution=resolution,
        )

    def _extract_by_patterns(
        self,
        content: str,
        patterns: list[str],
    ) -> list[str]:
        """Extract values matching any of the given patterns.

        Args:
            content: Text to search.
            patterns: List of regex patterns with capture group.

        Returns:
            List of extracted values (deduplicated).
        """
        items: list[str] = []
        seen: set[str] = set()

        for pattern in patterns:
            for match in re.finditer(pattern, content, re.IGNORECASE):
                value = match.group(1).strip()
                if value and value.lower() not in seen:
                    items.append(value)
                    seen.add(value.lower())

        return items
```

Update `strategies/__init__.py` to export RCCAStrategy:
```python
from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy
from knowledge_mcp.search.strategies.rcca import RCCAMetadata, RCCAStrategy

__all__ = ["SearchStrategy", "SearchQuery", "RCCAStrategy", "RCCAMetadata"]
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.search.strategies import RCCAStrategy, RCCAMetadata
strategy = RCCAStrategy()
print('RCCAStrategy imports OK')
"
poetry run ruff check src/knowledge_mcp/search/strategies/rcca.py --select E,F,W
```
  </verify>
  <done>RCCAStrategy imports and passes linting</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for RCCAStrategy</name>
  <files>tests/unit/test_search/test_rcca_strategy.py</files>
  <action>
Create comprehensive tests for RCCA strategy:

```python
"""Unit tests for RCCA search strategy."""

from __future__ import annotations

import pytest

from knowledge_mcp.search.models import SearchResult
from knowledge_mcp.search.strategies.rcca import RCCAMetadata, RCCAStrategy


class TestRCCAMetadata:
    """Tests for RCCAMetadata dataclass."""

    def test_defaults(self) -> None:
        """RCCAMetadata has sensible defaults."""
        meta = RCCAMetadata()
        assert meta.symptoms == []
        assert meta.root_cause is None
        assert meta.contributing_factors == []
        assert meta.resolution is None

    def test_with_all_fields(self) -> None:
        """RCCAMetadata accepts all fields."""
        meta = RCCAMetadata(
            symptoms=["error message"],
            root_cause="memory leak",
            contributing_factors=["high load"],
            resolution="increased memory",
        )
        assert len(meta.symptoms) == 1
        assert meta.root_cause == "memory leak"


class TestRCCAStrategy:
    """Tests for RCCAStrategy."""

    @pytest.fixture
    def strategy(self) -> RCCAStrategy:
        """Create RCCA strategy instance."""
        return RCCAStrategy()

    @pytest.mark.asyncio
    async def test_preprocess_expands_query(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """preprocess_query adds symptom and cause terms."""
        result = await strategy.preprocess_query("power failure", {})

        assert result.original == "power failure"
        assert "power failure symptoms" in result.expanded_terms
        assert "power failure root cause" in result.expanded_terms

    @pytest.mark.asyncio
    async def test_preprocess_adds_default_filters(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """preprocess_query filters to standards and handbooks by default."""
        result = await strategy.preprocess_query("test", {})

        assert "document_type" in result.filters
        assert "standard" in result.filters["document_type"]
        assert "handbook" in result.filters["document_type"]

    @pytest.mark.asyncio
    async def test_preprocess_preserves_custom_filters(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """preprocess_query preserves user-provided filters."""
        params = {"filters": {"document_type": "guide"}}
        result = await strategy.preprocess_query("test", params)

        assert result.filters["document_type"] == "guide"

    def test_adjust_ranking_boosts_rcca_keywords(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """adjust_ranking boosts results with RCCA keywords."""
        results = [
            SearchResult(
                id="1",
                content="This describes the root cause of the failure.",
                score=0.8,
            ),
            SearchResult(
                id="2",
                content="General information about systems.",
                score=0.85,
            ),
        ]

        ranked = strategy.adjust_ranking(results)

        # Result 1 should be boosted above result 2
        assert ranked[0].id == "1"
        assert ranked[0].score > 0.8

    def test_adjust_ranking_caps_score_at_one(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """adjust_ranking caps boosted scores at 1.0."""
        results = [
            SearchResult(
                id="1",
                content="root cause failure corrective action symptom fault defect",
                score=0.95,
            ),
        ]

        ranked = strategy.adjust_ranking(results)

        assert ranked[0].score <= 1.0

    def test_format_output_includes_result_type(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """format_output includes rcca_analysis result_type."""
        results = [
            SearchResult(
                id="1",
                content="Test content",
                score=0.9,
                document_title="Test Doc",
            ),
        ]

        output = strategy.format_output(results, {})

        assert output["result_type"] == "rcca_analysis"
        assert output["total_results"] == 1

    def test_format_output_includes_rcca_metadata(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """format_output extracts rcca_metadata for each result."""
        results = [
            SearchResult(
                id="1",
                content="Symptom: system crash. Root cause: memory leak.",
                score=0.9,
            ),
        ]

        output = strategy.format_output(results, {})

        result = output["results"][0]
        assert "rcca_metadata" in result
        assert result["rcca_metadata"]["has_structured_data"] is True

    def test_extract_symptoms(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """Extracts symptoms from content."""
        content = "Symptom: high CPU usage. Observed: system slowdown."
        meta = strategy._extract_rcca_metadata(content)

        assert len(meta.symptoms) >= 1
        assert "high CPU usage" in meta.symptoms

    def test_extract_root_cause(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """Extracts root cause from content."""
        content = "Root cause: memory leak in process handler."
        meta = strategy._extract_rcca_metadata(content)

        assert meta.root_cause is not None
        assert "memory leak" in meta.root_cause

    def test_extract_contributing_factors(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """Extracts contributing factors from content."""
        content = "Contributing factors: insufficient testing, time pressure."
        meta = strategy._extract_rcca_metadata(content)

        assert len(meta.contributing_factors) >= 1

    def test_extract_resolution(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """Extracts resolution from content."""
        content = "Resolution: patched memory management module."
        meta = strategy._extract_rcca_metadata(content)

        assert meta.resolution is not None
        assert "patched" in meta.resolution

    def test_extract_limits_to_five(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """Metadata extraction limits to 5 items per field."""
        content = """
        Symptom: a
        Symptom: b
        Symptom: c
        Symptom: d
        Symptom: e
        Symptom: f
        Symptom: g
        """
        meta = strategy._extract_rcca_metadata(content)

        assert len(meta.symptoms) <= 5

    def test_format_output_includes_source_citation(
        self,
        strategy: RCCAStrategy,
    ) -> None:
        """format_output includes source citation info."""
        results = [
            SearchResult(
                id="1",
                content="Test",
                score=0.9,
                document_title="NASA Handbook",
                section_title="Failure Analysis",
                document_type="handbook",
                clause_number="5.3.1",
            ),
        ]

        output = strategy.format_output(results, {})
        source = output["results"][0]["source"]

        assert source["document_title"] == "NASA Handbook"
        assert source["section_title"] == "Failure Analysis"
        assert source["clause_number"] == "5.3.1"
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pytest tests/unit/test_search/test_rcca_strategy.py -v
```
  </verify>
  <done>All RCCA strategy tests pass</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Strategy imports and works:
```bash
poetry run python -c "
from knowledge_mcp.search.strategies import RCCAStrategy
s = RCCAStrategy()
import asyncio
q = asyncio.run(s.preprocess_query('test', {}))
print(f'Query expanded: {len(q.expanded_terms)} terms')
"
```

2. All tests pass:
```bash
poetry run pytest tests/unit/test_search/test_rcca_strategy.py -v
```

3. Code quality:
```bash
poetry run ruff check src/knowledge_mcp/search/strategies/rcca.py --select E,F,W
```
</verification>

<success_criteria>
- [ ] RCCAStrategy extends SearchStrategy ABC
- [ ] preprocess_query expands to symptoms, root cause, failure analysis, corrective action
- [ ] adjust_ranking boosts results with RCCA keywords
- [ ] format_output extracts rcca_metadata (symptoms, root_cause, contributing_factors, resolution)
- [ ] Output includes has_structured_data indicator
- [ ] All unit tests pass
- [ ] Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-support/02-03-SUMMARY.md`
</output>
