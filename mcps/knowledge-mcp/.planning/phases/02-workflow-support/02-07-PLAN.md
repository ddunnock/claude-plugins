---
phase: 02-workflow-support
plan: 07
type: execute
wave: 4
depends_on: ["02-03", "02-04", "02-05", "02-06"]
files_modified:
  - src/knowledge_mcp/tools/workflows.py
  - src/knowledge_mcp/server.py
  - tests/integration/test_workflow_tools.py
autonomous: true

must_haves:
  truths:
    - "knowledge_rcca tool registered in server and calls RCCAStrategy"
    - "knowledge_trade tool registered in server and calls TradeStudyStrategy"
    - "knowledge_explore tool registered in server and calls ExploreStrategy"
    - "knowledge_plan tool registered in server and calls PlanStrategy"
    - "All 4 tools accept project_id for capture integration"
    - "All tools return JSON-serializable responses"
  artifacts:
    - path: "src/knowledge_mcp/tools/workflows.py"
      provides: "Workflow tool handlers"
      contains: "handle_rcca"
    - path: "src/knowledge_mcp/server.py"
      provides: "Extended server with 4 workflow tools"
      contains: "knowledge_rcca"
    - path: "tests/integration/test_workflow_tools.py"
      provides: "Integration tests for workflow tools"
      contains: "test_knowledge_rcca"
  key_links:
    - from: "server.py"
      to: "tools/workflows.py"
      via: "import"
      pattern: "from knowledge_mcp.tools.workflows import"
    - from: "handle_rcca"
      to: "RCCAStrategy"
      via: "instantiation"
      pattern: "RCCAStrategy"
---

<objective>
Register 4 workflow MCP tools in the server: knowledge_rcca, knowledge_trade, knowledge_explore, knowledge_plan.

Purpose: Expose Phase 2 workflow strategies as MCP tools that Claude can invoke for specialized retrieval and project capture.

Output: 4 new MCP tools with tool handlers, extending the server from 8 to 12 total tools.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-workflow-support/02-RESEARCH.md
@.planning/phases/02-workflow-support/02-CONTEXT.md
@.planning/phases/01-core-acquisition/01-06-SUMMARY.md

# Existing server and tools
@src/knowledge_mcp/server.py
@src/knowledge_mcp/tools/acquisition.py

# Strategies to wire up
@src/knowledge_mcp/search/strategies/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workflow tool handlers</name>
  <files>src/knowledge_mcp/tools/workflows.py</files>
  <action>
Create the workflow tool handlers module:

```python
"""MCP tool handlers for workflow-specific searches.

Provides handlers for the 4 workflow tools:
- knowledge_rcca: Root Cause Corrective Action analysis
- knowledge_trade: Trade study decision support
- knowledge_explore: Multi-facet exploratory search
- knowledge_plan: Planning with project capture

Each handler creates a WorkflowSearcher with the appropriate strategy
and optionally captures queries to a project.
"""

from __future__ import annotations

import json
import logging
from typing import TYPE_CHECKING, Any
from uuid import UUID

from knowledge_mcp.search.strategies import (
    ExploreStrategy,
    PlanStrategy,
    RCCAStrategy,
    TradeStudyStrategy,
)
from knowledge_mcp.search.workflow_search import WorkflowSearcher

if TYPE_CHECKING:
    from knowledge_mcp.db.repositories import ProjectRepository
    from knowledge_mcp.search.semantic_search import SemanticSearcher
    from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)


async def handle_rcca(
    searcher: SemanticSearcher,
    query: str,
    n_results: int = 10,
    project_id: str | None = None,
    session: AsyncSession | None = None,
    repo: ProjectRepository | None = None,
) -> dict[str, Any]:
    """Handle knowledge_rcca tool invocation.

    Searches for similar failures with symptom and root cause analysis.

    Args:
        searcher: Semantic search implementation.
        query: Failure description or symptoms.
        n_results: Maximum results to return.
        project_id: Optional project UUID for query capture.
        session: Database session for capture.
        repo: Project repository for capture.

    Returns:
        RCCA analysis results with extracted metadata.
    """
    strategy = RCCAStrategy()
    workflow = WorkflowSearcher(searcher, strategy)

    result = await workflow.search(
        query=query,
        params={},
        n_results=n_results,
    )

    # Capture query if project specified
    if project_id and session and repo:
        try:
            await repo.capture_query(
                session,
                project_id=UUID(project_id),
                query=query,
                result_count=result.get("total_results", 0),
                workflow_type="rcca",
            )
            await session.commit()
        except Exception as e:
            logger.warning("Failed to capture query: %s", e)

    return result


async def handle_trade(
    searcher: SemanticSearcher,
    query: str,
    alternatives: list[str],
    criteria: list[str] | None = None,
    n_results: int = 20,
    project_id: str | None = None,
    session: AsyncSession | None = None,
    repo: ProjectRepository | None = None,
) -> dict[str, Any]:
    """Handle knowledge_trade tool invocation.

    Searches for trade study evidence grouped by alternative.

    Args:
        searcher: Semantic search implementation.
        query: Comparison topic.
        alternatives: List of alternatives to compare.
        criteria: Optional list of evaluation criteria.
        n_results: Maximum results to return.
        project_id: Optional project UUID for query capture.
        session: Database session for capture.
        repo: Project repository for capture.

    Returns:
        Trade study results grouped by alternative.
    """
    strategy = TradeStudyStrategy()
    workflow = WorkflowSearcher(searcher, strategy)

    params = {
        "alternatives": alternatives,
        "criteria": criteria or [],
    }

    result = await workflow.search(
        query=query,
        params=params,
        n_results=n_results,
    )

    # Capture query if project specified
    if project_id and session and repo:
        try:
            await repo.capture_query(
                session,
                project_id=UUID(project_id),
                query=f"{query} comparing: {', '.join(alternatives)}",
                result_count=result.get("total_results", 0),
                workflow_type="trade",
            )
            await session.commit()
        except Exception as e:
            logger.warning("Failed to capture query: %s", e)

    return result


async def handle_explore(
    searcher: SemanticSearcher,
    query: str,
    facets: list[str] | None = None,
    n_results: int = 20,
    project_id: str | None = None,
    session: AsyncSession | None = None,
    repo: ProjectRepository | None = None,
) -> dict[str, Any]:
    """Handle knowledge_explore tool invocation.

    Multi-facet exploratory search for comprehensive topic coverage.

    Args:
        searcher: Semantic search implementation.
        query: Exploration topic.
        facets: Optional list of facets to include.
        n_results: Maximum results to return.
        project_id: Optional project UUID for query capture.
        session: Database session for capture.
        repo: Project repository for capture.

    Returns:
        Results organized by facet.
    """
    strategy = ExploreStrategy()
    workflow = WorkflowSearcher(searcher, strategy)

    params = {}
    if facets:
        params["facets"] = facets

    result = await workflow.search(
        query=query,
        params=params,
        n_results=n_results,
    )

    # Capture query if project specified
    if project_id and session and repo:
        try:
            await repo.capture_query(
                session,
                project_id=UUID(project_id),
                query=query,
                result_count=result.get("total_results", 0),
                workflow_type="explore",
            )
            await session.commit()
        except Exception as e:
            logger.warning("Failed to capture query: %s", e)

    return result


async def handle_plan(
    searcher: SemanticSearcher,
    query: str,
    include_risks: bool = True,
    include_lessons: bool = True,
    include_precedents: bool = True,
    n_results: int = 20,
    project_id: str | None = None,
    session: AsyncSession | None = None,
    repo: ProjectRepository | None = None,
) -> dict[str, Any]:
    """Handle knowledge_plan tool invocation.

    Planning support with templates, risks, lessons, and precedents.

    Args:
        searcher: Semantic search implementation.
        query: Planning topic or activity.
        include_risks: Include risk analysis results.
        include_lessons: Include lessons learned.
        include_precedents: Include precedent examples.
        n_results: Maximum results to return.
        project_id: Optional project UUID for query capture.
        session: Database session for capture.
        repo: Project repository for capture.

    Returns:
        Planning resources categorized by type.
    """
    strategy = PlanStrategy()
    workflow = WorkflowSearcher(searcher, strategy)

    params = {
        "include_risks": include_risks,
        "include_lessons": include_lessons,
        "include_precedents": include_precedents,
    }

    result = await workflow.search(
        query=query,
        params=params,
        n_results=n_results,
    )

    # Capture query if project specified
    if project_id and session and repo:
        try:
            await repo.capture_query(
                session,
                project_id=UUID(project_id),
                query=query,
                result_count=result.get("total_results", 0),
                workflow_type="plan",
            )
            await session.commit()
        except Exception as e:
            logger.warning("Failed to capture query: %s", e)

    return result


async def handle_capture_decision(
    session: AsyncSession,
    repo: ProjectRepository,
    project_id: str,
    decision: str,
    rationale: str,
    alternatives: list[str] | None = None,
    supporting_chunk_ids: list[str] | None = None,
) -> dict[str, Any]:
    """Handle decision capture for a project.

    Args:
        session: Database session.
        repo: Project repository.
        project_id: Project UUID.
        decision: What was decided.
        rationale: Why this decision was made.
        alternatives: Other options considered.
        supporting_chunk_ids: Chunk IDs that supported the decision.

    Returns:
        Created decision record.
    """
    # Build supporting chunks with default relevance
    supporting_chunks = None
    if supporting_chunk_ids:
        supporting_chunks = [(cid, 1.0) for cid in supporting_chunk_ids]

    decision_record = await repo.capture_decision(
        session,
        project_id=UUID(project_id),
        decision=decision,
        rationale=rationale,
        alternatives=alternatives,
        supporting_chunks=supporting_chunks,
    )

    await session.commit()

    return repo.decision_to_dict(decision_record)
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.tools.workflows import (
    handle_rcca, handle_trade, handle_explore, handle_plan
)
print('Workflow handlers import OK')
"
poetry run ruff check src/knowledge_mcp/tools/workflows.py --select E,F,W
```
  </verify>
  <done>Workflow handlers import and pass linting</done>
</task>

<task type="auto">
  <name>Task 2: Extend server.py with workflow tools</name>
  <files>src/knowledge_mcp/server.py</files>
  <action>
Add the 4 workflow tools to server.py. Find the existing tool registrations and add after them:

1. Add imports at the top of the file (find the existing imports section):
```python
from knowledge_mcp.tools.workflows import (
    handle_rcca,
    handle_trade,
    handle_explore,
    handle_plan,
    handle_capture_decision,
)
from knowledge_mcp.db.repositories import ProjectRepository
```

2. In `handle_list_tools()`, add these 4 tool definitions after the existing 8 tools:
```python
Tool(
    name="knowledge_rcca",
    description="""Search for Root Cause Corrective Action (RCCA) information.

Finds similar failures, symptom patterns, root causes, and corrective actions.
Extracts structured metadata: symptoms, root_cause, contributing_factors, resolution.

Use for:
- Analyzing failures and incidents
- Finding similar past issues
- Identifying root causes
- Learning from corrective actions

Returns results with RCCA metadata for failure analysis synthesis.""",
    inputSchema={
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "Failure description, symptoms, or error messages"
            },
            "n_results": {
                "type": "integer",
                "description": "Maximum results (default: 10)",
                "default": 10
            },
            "project_id": {
                "type": "string",
                "description": "Optional project UUID for query capture"
            }
        },
        "required": ["query"]
    }
),
Tool(
    name="knowledge_trade",
    description="""Search for trade study and decision support information.

Groups results by alternative with criteria evidence. Synthesizes comparison
data from any relevant content, enabling trade studies without pre-tagged docs.

Use for:
- Comparing technical alternatives
- Evaluating design options
- Collecting criteria evidence
- Supporting technical decisions

Returns alternative-grouped results with criteria evidence per option.""",
    inputSchema={
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "Comparison topic (e.g., 'database selection')"
            },
            "alternatives": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Alternatives to compare (e.g., ['PostgreSQL', 'MongoDB'])"
            },
            "criteria": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Evaluation criteria (e.g., ['cost', 'performance'])"
            },
            "n_results": {
                "type": "integer",
                "description": "Maximum results (default: 20)",
                "default": 20
            },
            "project_id": {
                "type": "string",
                "description": "Optional project UUID for query capture"
            }
        },
        "required": ["query", "alternatives"]
    }
),
Tool(
    name="knowledge_explore",
    description="""Multi-facet exploratory search for comprehensive topic understanding.

Automatically searches: definitions, examples, standards, best practices.
Returns results organized by facet, not a flat list.

Use for:
- Learning about new topics
- Gathering comprehensive context
- Finding diverse perspectives
- Building foundational understanding

Returns results organized by facet with coverage summary.""",
    inputSchema={
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "Topic to explore"
            },
            "facets": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Facets to include (default: all). Options: definitions, examples, standards, best_practices"
            },
            "n_results": {
                "type": "integer",
                "description": "Maximum results (default: 20)",
                "default": 20
            },
            "project_id": {
                "type": "string",
                "description": "Optional project UUID for query capture"
            }
        },
        "required": ["query"]
    }
),
Tool(
    name="knowledge_plan",
    description="""Planning workflow support with templates, risks, and precedents.

Searches for: templates, checklists, risk mitigations, lessons learned, precedents.
Supports project capture for tracking queries and decisions.

Use for:
- Planning activities (SRR, PDR, CDR)
- Finding relevant templates
- Identifying risks and mitigations
- Learning from past projects

Returns categorized planning resources.""",
    inputSchema={
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "Planning topic or activity"
            },
            "include_risks": {
                "type": "boolean",
                "description": "Include risk analysis (default: true)",
                "default": True
            },
            "include_lessons": {
                "type": "boolean",
                "description": "Include lessons learned (default: true)",
                "default": True
            },
            "include_precedents": {
                "type": "boolean",
                "description": "Include precedent examples (default: true)",
                "default": True
            },
            "n_results": {
                "type": "integer",
                "description": "Maximum results (default: 20)",
                "default": 20
            },
            "project_id": {
                "type": "string",
                "description": "Optional project UUID for query capture"
            }
        },
        "required": ["query"]
    }
),
```

3. In `handle_call_tool()`, add cases for each new tool in the match statement:
```python
case "knowledge_rcca":
    return await self._handle_knowledge_rcca(arguments)
case "knowledge_trade":
    return await self._handle_knowledge_trade(arguments)
case "knowledge_explore":
    return await self._handle_knowledge_explore(arguments)
case "knowledge_plan":
    return await self._handle_knowledge_plan(arguments)
```

4. Add handler methods (place near other handler methods):
```python
async def _handle_knowledge_rcca(self, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle knowledge_rcca tool."""
    query = arguments.get("query", "")
    n_results = arguments.get("n_results", 10)
    project_id = arguments.get("project_id")

    if not self._searcher:
        return [TextContent(type="text", text=json.dumps({
            "error": "Searcher not initialized",
            "isError": True
        }))]

    session = None
    repo = None
    if project_id and self._session_factory:
        from knowledge_mcp.db.engine import get_session
        session = await get_session(self._session_factory).__aenter__()
        repo = ProjectRepository()

    try:
        result = await handle_rcca(
            searcher=self._searcher,
            query=query,
            n_results=n_results,
            project_id=project_id,
            session=session,
            repo=repo,
        )
        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    finally:
        if session:
            await session.__aexit__(None, None, None)

async def _handle_knowledge_trade(self, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle knowledge_trade tool."""
    query = arguments.get("query", "")
    alternatives = arguments.get("alternatives", [])
    criteria = arguments.get("criteria")
    n_results = arguments.get("n_results", 20)
    project_id = arguments.get("project_id")

    if not self._searcher:
        return [TextContent(type="text", text=json.dumps({
            "error": "Searcher not initialized",
            "isError": True
        }))]

    if not alternatives:
        return [TextContent(type="text", text=json.dumps({
            "error": "alternatives parameter is required",
            "isError": True
        }))]

    session = None
    repo = None
    if project_id and self._session_factory:
        from knowledge_mcp.db.engine import get_session
        session = await get_session(self._session_factory).__aenter__()
        repo = ProjectRepository()

    try:
        result = await handle_trade(
            searcher=self._searcher,
            query=query,
            alternatives=alternatives,
            criteria=criteria,
            n_results=n_results,
            project_id=project_id,
            session=session,
            repo=repo,
        )
        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    finally:
        if session:
            await session.__aexit__(None, None, None)

async def _handle_knowledge_explore(self, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle knowledge_explore tool."""
    query = arguments.get("query", "")
    facets = arguments.get("facets")
    n_results = arguments.get("n_results", 20)
    project_id = arguments.get("project_id")

    if not self._searcher:
        return [TextContent(type="text", text=json.dumps({
            "error": "Searcher not initialized",
            "isError": True
        }))]

    session = None
    repo = None
    if project_id and self._session_factory:
        from knowledge_mcp.db.engine import get_session
        session = await get_session(self._session_factory).__aenter__()
        repo = ProjectRepository()

    try:
        result = await handle_explore(
            searcher=self._searcher,
            query=query,
            facets=facets,
            n_results=n_results,
            project_id=project_id,
            session=session,
            repo=repo,
        )
        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    finally:
        if session:
            await session.__aexit__(None, None, None)

async def _handle_knowledge_plan(self, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle knowledge_plan tool."""
    query = arguments.get("query", "")
    include_risks = arguments.get("include_risks", True)
    include_lessons = arguments.get("include_lessons", True)
    include_precedents = arguments.get("include_precedents", True)
    n_results = arguments.get("n_results", 20)
    project_id = arguments.get("project_id")

    if not self._searcher:
        return [TextContent(type="text", text=json.dumps({
            "error": "Searcher not initialized",
            "isError": True
        }))]

    session = None
    repo = None
    if project_id and self._session_factory:
        from knowledge_mcp.db.engine import get_session
        session = await get_session(self._session_factory).__aenter__()
        repo = ProjectRepository()

    try:
        result = await handle_plan(
            searcher=self._searcher,
            query=query,
            include_risks=include_risks,
            include_lessons=include_lessons,
            include_precedents=include_precedents,
            n_results=n_results,
            project_id=project_id,
            session=session,
            repo=repo,
        )
        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    finally:
        if session:
            await session.__aexit__(None, None, None)
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.server import KnowledgeMCPServer
server = KnowledgeMCPServer()
print('Server imports OK')
"
poetry run ruff check src/knowledge_mcp/server.py --select E,F,W --ignore E501
```
  </verify>
  <done>Server imports correctly with all 12 tools registered</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for workflow tools</name>
  <files>tests/integration/test_workflow_tools.py</files>
  <action>
Create integration tests verifying tool registration:

```python
"""Integration tests for workflow MCP tools."""

from __future__ import annotations

import pytest

from knowledge_mcp.server import KnowledgeMCPServer


class TestWorkflowToolRegistration:
    """Tests for workflow tool registration."""

    @pytest.fixture
    def server(self) -> KnowledgeMCPServer:
        """Create server instance."""
        return KnowledgeMCPServer()

    @pytest.mark.asyncio
    async def test_knowledge_rcca_registered(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_rcca tool is registered."""
        tools = await server.handle_list_tools()
        tool_names = [t.name for t in tools]
        assert "knowledge_rcca" in tool_names

    @pytest.mark.asyncio
    async def test_knowledge_trade_registered(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_trade tool is registered."""
        tools = await server.handle_list_tools()
        tool_names = [t.name for t in tools]
        assert "knowledge_trade" in tool_names

    @pytest.mark.asyncio
    async def test_knowledge_explore_registered(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_explore tool is registered."""
        tools = await server.handle_list_tools()
        tool_names = [t.name for t in tools]
        assert "knowledge_explore" in tool_names

    @pytest.mark.asyncio
    async def test_knowledge_plan_registered(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_plan tool is registered."""
        tools = await server.handle_list_tools()
        tool_names = [t.name for t in tools]
        assert "knowledge_plan" in tool_names

    @pytest.mark.asyncio
    async def test_total_tools_is_twelve(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """Server has 12 total tools (8 from Phase 1 + 4 workflow)."""
        tools = await server.handle_list_tools()
        assert len(tools) == 12

    @pytest.mark.asyncio
    async def test_rcca_tool_schema(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_rcca has correct input schema."""
        tools = await server.handle_list_tools()
        rcca_tool = next(t for t in tools if t.name == "knowledge_rcca")

        assert "query" in rcca_tool.inputSchema["properties"]
        assert "query" in rcca_tool.inputSchema["required"]

    @pytest.mark.asyncio
    async def test_trade_tool_schema(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_trade has required alternatives parameter."""
        tools = await server.handle_list_tools()
        trade_tool = next(t for t in tools if t.name == "knowledge_trade")

        assert "alternatives" in trade_tool.inputSchema["properties"]
        assert "alternatives" in trade_tool.inputSchema["required"]

    @pytest.mark.asyncio
    async def test_explore_tool_schema(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_explore has optional facets parameter."""
        tools = await server.handle_list_tools()
        explore_tool = next(t for t in tools if t.name == "knowledge_explore")

        assert "facets" in explore_tool.inputSchema["properties"]
        assert "facets" not in explore_tool.inputSchema.get("required", [])

    @pytest.mark.asyncio
    async def test_plan_tool_schema(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_plan has include_* parameters."""
        tools = await server.handle_list_tools()
        plan_tool = next(t for t in tools if t.name == "knowledge_plan")

        props = plan_tool.inputSchema["properties"]
        assert "include_risks" in props
        assert "include_lessons" in props
        assert "include_precedents" in props


class TestWorkflowToolErrors:
    """Tests for error handling in workflow tools."""

    @pytest.fixture
    def server(self) -> KnowledgeMCPServer:
        """Create server without searcher initialized."""
        return KnowledgeMCPServer()

    @pytest.mark.asyncio
    async def test_rcca_without_searcher(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_rcca returns error without searcher."""
        result = await server.handle_call_tool(
            "knowledge_rcca",
            {"query": "test failure"}
        )
        assert len(result) == 1
        # Should contain error message

    @pytest.mark.asyncio
    async def test_trade_without_alternatives(
        self,
        server: KnowledgeMCPServer,
    ) -> None:
        """knowledge_trade returns error without alternatives."""
        result = await server.handle_call_tool(
            "knowledge_trade",
            {"query": "test", "alternatives": []}
        )
        assert len(result) == 1
        # Should contain error about alternatives
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pytest tests/integration/test_workflow_tools.py -v
```
  </verify>
  <done>All workflow tool integration tests pass</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. All imports work:
```bash
poetry run python -c "
from knowledge_mcp.server import KnowledgeMCPServer
from knowledge_mcp.tools.workflows import handle_rcca
print('All imports OK')
"
```

2. 12 tools registered:
```bash
poetry run python -c "
import asyncio
from knowledge_mcp.server import KnowledgeMCPServer
server = KnowledgeMCPServer()
tools = asyncio.run(server.handle_list_tools())
print(f'{len(tools)} tools registered')
for t in tools:
    print(f'  - {t.name}')
"
```

3. All tests pass:
```bash
poetry run pytest tests/integration/test_workflow_tools.py -v
```

4. Code quality:
```bash
poetry run ruff check src/knowledge_mcp/tools/workflows.py src/knowledge_mcp/server.py --select E,F,W --ignore E501
```
</verification>

<success_criteria>
- [ ] tools/workflows.py has handlers for all 4 tools
- [ ] server.py registers knowledge_rcca, knowledge_trade, knowledge_explore, knowledge_plan
- [ ] handle_call_tool dispatches to correct handlers
- [ ] All tools accept optional project_id for capture
- [ ] Server has 12 total tools
- [ ] Integration tests verify tool registration
- [ ] Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-support/02-07-SUMMARY.md`
</output>
