---
phase: 02-workflow-support
plan: 05
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/knowledge_mcp/search/strategies/explore.py
  - tests/unit/test_search/test_explore_strategy.py
autonomous: true

must_haves:
  truths:
    - "ExploreStrategy searches multiple facets automatically (definitions, examples, standards, best_practices)"
    - "ExploreStrategy organizes results by facet, not flat list"
    - "ExploreStrategy maintains facet diversity in output"
    - "Format output includes facets with top results per facet"
  artifacts:
    - path: "src/knowledge_mcp/search/strategies/explore.py"
      provides: "ExploreStrategy class and Facet dataclass"
      contains: "class ExploreStrategy"
    - path: "tests/unit/test_search/test_explore_strategy.py"
      provides: "Unit tests for explore strategy"
      contains: "class TestExploreStrategy"
  key_links:
    - from: "ExploreStrategy"
      to: "SearchStrategy"
      via: "inheritance"
      pattern: "class ExploreStrategy.*SearchStrategy"
---

<objective>
Implement ExploreStrategy for multi-facet exploratory searches.

Purpose: Enable comprehensive topic exploration by automatically searching definitions, examples, standards, and best practices - returning results organized by facet for broader understanding.

Output: ExploreStrategy class that searches multiple aspects of a topic and organizes results by facet.
</objective>

<execution_context>
@/Users/dunnock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dunnock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-workflow-support/02-RESEARCH.md
@.planning/phases/02-workflow-support/02-CONTEXT.md

# Strategy base (from 02-02)
@src/knowledge_mcp/search/strategies/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExploreStrategy implementation</name>
  <files>src/knowledge_mcp/search/strategies/explore.py</files>
  <action>
Create the Explore strategy following the research document patterns:

```python
"""Exploratory multi-facet search strategy.

Provides comprehensive topic exploration by searching across multiple
facets (definitions, examples, standards, best practices) and organizing
results by facet.

Example:
    >>> from knowledge_mcp.search.strategies.explore import ExploreStrategy
    >>> strategy = ExploreStrategy()
    >>> output = strategy.format_output(results, {})
    >>> for facet in output["facets"]:
    ...     print(f"{facet['name']}: {len(facet['results'])} results")
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any

from knowledge_mcp.search.models import SearchResult
from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy


@dataclass
class Facet:
    """A facet of exploratory search.

    Attributes:
        name: Facet identifier (e.g., "definitions", "examples").
        query_expansion: Terms to add to base query for this facet.
        keywords: Keywords that indicate content belongs to this facet.
        results: Results assigned to this facet.
    """

    name: str
    query_expansion: str
    keywords: list[str]
    results: list[SearchResult] = field(default_factory=list)


class ExploreStrategy(SearchStrategy):
    """Strategy for multi-facet exploratory searches.

    Automatically searches multiple aspects of a topic and organizes
    results by facet for comprehensive exploration.

    Default facets:
    - definitions: Terminology and concept definitions
    - examples: Case studies and practical examples
    - standards: Requirements and specifications
    - best_practices: Guidance and recommendations

    Features:
    - Multi-facet query expansion
    - Facet-aware result organization
    - Diversity maintenance across facets

    Example:
        >>> strategy = ExploreStrategy()
        >>> output = strategy.format_output(results, {})
        >>> print(output["result_type"])  # "exploratory"
    """

    # Default facet definitions
    DEFAULT_FACETS = [
        Facet(
            name="definitions",
            query_expansion="definition terminology meaning",
            keywords=["definition", "defined as", "means", "terminology", "refers to", "is a"],
        ),
        Facet(
            name="examples",
            query_expansion="example case study instance",
            keywords=["example", "case study", "instance", "such as", "for instance", "e.g."],
        ),
        Facet(
            name="standards",
            query_expansion="standard requirement specification",
            keywords=["shall", "must", "requirement", "standard", "specification", "IEEE", "ISO"],
        ),
        Facet(
            name="best_practices",
            query_expansion="best practice guidance recommendation",
            keywords=["best practice", "guidance", "recommended", "should", "guideline", "tip"],
        ),
    ]

    def __init__(
        self,
        facets: list[Facet] | None = None,
        max_results_per_facet: int = 5,
    ) -> None:
        """Initialize explore strategy.

        Args:
            facets: Custom facets to use. Defaults to DEFAULT_FACETS.
            max_results_per_facet: Maximum results to show per facet.
        """
        self._facets = facets if facets is not None else self.DEFAULT_FACETS.copy()
        self._max_per_facet = max_results_per_facet

    @property
    def facets(self) -> list[Facet]:
        """Get current facet definitions."""
        return self._facets

    async def preprocess_query(
        self,
        query: str,
        params: dict[str, Any],
    ) -> SearchQuery:
        """Expand query with facet-specific terms.

        Args:
            query: Base exploration topic.
            params: Optional "facets" list to filter which facets to use.

        Returns:
            SearchQuery with expanded terms for each active facet.
        """
        # Get active facets (all by default, or filtered by params)
        active_facet_names = params.get("facets", [f.name for f in self._facets])
        active_facets = [f for f in self._facets if f.name in active_facet_names]

        # Build expanded terms for each facet
        expanded_terms = []
        facet_names = []

        for facet in active_facets:
            expanded_terms.append(f"{query} {facet.query_expansion}")
            facet_names.append(facet.name)

        return SearchQuery(
            original=query,
            expanded_terms=expanded_terms,
            filters=params.get("filters", {}),
            facets=facet_names,
        )

    def adjust_ranking(
        self,
        results: list[SearchResult],
    ) -> list[SearchResult]:
        """Maintain diversity by not over-boosting any facet.

        For exploratory search, we want diverse results across facets
        rather than concentrating on one aspect.

        Args:
            results: Raw semantic search results.

        Returns:
            Results with minimal ranking adjustment.
        """
        # Light boost for content that matches multiple facets
        for result in results:
            content_lower = result.content.lower()
            facet_match_count = 0

            for facet in self._facets:
                if any(kw in content_lower for kw in facet.keywords):
                    facet_match_count += 1

            # Small boost for content matching multiple facets (cross-cutting)
            if facet_match_count > 1:
                result.score = min(1.0, result.score * (1 + 0.02 * facet_match_count))

        return sorted(results, key=lambda r: r.score, reverse=True)

    def format_output(
        self,
        results: list[SearchResult],
        params: dict[str, Any],
    ) -> dict[str, Any]:
        """Organize results by facet.

        Args:
            results: Ranked search results.
            params: Original parameters.

        Returns:
            Dict with results organized by facet.
        """
        # Reset facet results
        for facet in self._facets:
            facet.results = []

        # Assign results to facets
        unassigned: list[SearchResult] = []
        assigned_ids: set[str] = set()

        for result in results:
            content_lower = result.content.lower()
            best_facet = None
            best_match_count = 0

            for facet in self._facets:
                match_count = sum(1 for kw in facet.keywords if kw in content_lower)
                if match_count > best_match_count:
                    best_match_count = match_count
                    best_facet = facet

            if best_facet and best_match_count > 0:
                if len(best_facet.results) < self._max_per_facet:
                    best_facet.results.append(result)
                    assigned_ids.add(result.id)
            else:
                unassigned.append(result)

        # Build output
        facets_output = []
        for facet in self._facets:
            facets_output.append({
                "name": facet.name,
                "description": self._get_facet_description(facet.name),
                "result_count": len(facet.results),
                "results": [
                    {
                        "id": r.id,
                        "content": r.content[:300] + "..." if len(r.content) > 300 else r.content,
                        "score": r.score,
                        "source": {
                            "document_title": r.document_title,
                            "section_title": r.section_title,
                            "document_type": r.document_type,
                        },
                    }
                    for r in facet.results
                ],
            })

        return {
            "facets": facets_output,
            "result_type": "exploratory",
            "total_facets": len(self._facets),
            "total_results": len(results),
            "facet_coverage": {
                facet.name: len(facet.results) > 0
                for facet in self._facets
            },
            "unassigned_count": len(unassigned),
        }

    def _get_facet_description(self, facet_name: str) -> str:
        """Get human-readable description for a facet.

        Args:
            facet_name: Facet identifier.

        Returns:
            Description string.
        """
        descriptions = {
            "definitions": "Terminology and concept definitions",
            "examples": "Case studies and practical examples",
            "standards": "Requirements and specifications from standards",
            "best_practices": "Guidance and recommended approaches",
        }
        return descriptions.get(facet_name, facet_name)
```

Update `strategies/__init__.py` to export ExploreStrategy:
```python
from knowledge_mcp.search.strategies.base import SearchQuery, SearchStrategy
from knowledge_mcp.search.strategies.explore import ExploreStrategy, Facet
from knowledge_mcp.search.strategies.rcca import RCCAMetadata, RCCAStrategy
from knowledge_mcp.search.strategies.trade import (
    AlternativeEvaluation,
    CriteriaEvidence,
    TradeStudyStrategy,
)

__all__ = [
    "SearchStrategy",
    "SearchQuery",
    "RCCAStrategy",
    "RCCAMetadata",
    "TradeStudyStrategy",
    "CriteriaEvidence",
    "AlternativeEvaluation",
    "ExploreStrategy",
    "Facet",
]
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "
from knowledge_mcp.search.strategies import ExploreStrategy, Facet
strategy = ExploreStrategy()
print(f'ExploreStrategy has {len(strategy.facets)} facets')
"
poetry run ruff check src/knowledge_mcp/search/strategies/explore.py --select E,F,W
```
  </verify>
  <done>ExploreStrategy imports and passes linting</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for ExploreStrategy</name>
  <files>tests/unit/test_search/test_explore_strategy.py</files>
  <action>
Create comprehensive tests for explore strategy:

```python
"""Unit tests for Explore search strategy."""

from __future__ import annotations

import pytest

from knowledge_mcp.search.models import SearchResult
from knowledge_mcp.search.strategies.explore import ExploreStrategy, Facet


class TestFacet:
    """Tests for Facet dataclass."""

    def test_defaults(self) -> None:
        """Facet has sensible defaults."""
        facet = Facet(name="test", query_expansion="test exp", keywords=["kw"])
        assert facet.results == []

    def test_with_results(self) -> None:
        """Facet can hold results."""
        result = SearchResult(id="1", content="test", score=0.9)
        facet = Facet(
            name="test",
            query_expansion="test exp",
            keywords=["kw"],
            results=[result],
        )
        assert len(facet.results) == 1


class TestExploreStrategy:
    """Tests for ExploreStrategy."""

    @pytest.fixture
    def strategy(self) -> ExploreStrategy:
        """Create explore strategy instance."""
        return ExploreStrategy()

    def test_default_facets(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """Strategy has 4 default facets."""
        assert len(strategy.facets) == 4
        names = [f.name for f in strategy.facets]
        assert "definitions" in names
        assert "examples" in names
        assert "standards" in names
        assert "best_practices" in names

    def test_custom_facets(self) -> None:
        """Strategy accepts custom facets."""
        custom_facets = [
            Facet(name="custom", query_expansion="custom exp", keywords=["custom"]),
        ]
        strategy = ExploreStrategy(facets=custom_facets)
        assert len(strategy.facets) == 1
        assert strategy.facets[0].name == "custom"

    @pytest.mark.asyncio
    async def test_preprocess_expands_for_all_facets(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """preprocess_query creates terms for each facet."""
        result = await strategy.preprocess_query("requirements traceability", {})

        assert result.original == "requirements traceability"
        assert len(result.expanded_terms) == 4  # One per default facet
        assert len(result.facets) == 4

    @pytest.mark.asyncio
    async def test_preprocess_filters_facets(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """preprocess_query respects facet filter in params."""
        params = {"facets": ["definitions", "examples"]}
        result = await strategy.preprocess_query("test", params)

        assert len(result.facets) == 2
        assert "definitions" in result.facets
        assert "examples" in result.facets
        assert "standards" not in result.facets

    def test_adjust_ranking_boosts_cross_cutting(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """adjust_ranking boosts content matching multiple facets."""
        results = [
            SearchResult(
                id="1",
                content="This example shows the definition of requirements.",
                score=0.7,
            ),
            SearchResult(
                id="2",
                content="Basic content with nothing special.",
                score=0.75,
            ),
        ]

        ranked = strategy.adjust_ranking(results)

        # Result with multiple facet matches should be boosted
        cross_cutting = next(r for r in ranked if "example" in r.content)
        assert cross_cutting.score > 0.7

    def test_format_output_organizes_by_facet(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """format_output organizes results by facet."""
        results = [
            SearchResult(
                id="1",
                content="The definition of traceability is...",
                score=0.9,
                document_title="Glossary",
            ),
            SearchResult(
                id="2",
                content="This example shows how to trace requirements.",
                score=0.85,
                document_title="Tutorial",
            ),
            SearchResult(
                id="3",
                content="Requirements shall be traced. IEEE 12207",
                score=0.8,
                document_title="IEEE 12207",
            ),
        ]

        output = strategy.format_output(results, {})

        assert output["result_type"] == "exploratory"
        assert output["total_facets"] == 4

        # Check definitions facet
        def_facet = next(f for f in output["facets"] if f["name"] == "definitions")
        assert def_facet["result_count"] >= 1

        # Check examples facet
        ex_facet = next(f for f in output["facets"] if f["name"] == "examples")
        assert ex_facet["result_count"] >= 1

    def test_format_output_limits_per_facet(self) -> None:
        """format_output respects max_results_per_facet."""
        strategy = ExploreStrategy(max_results_per_facet=2)

        results = [
            SearchResult(
                id=str(i),
                content=f"Definition {i}: this is defined as...",
                score=0.9 - i * 0.01,
            )
            for i in range(10)
        ]

        output = strategy.format_output(results, {})

        def_facet = next(f for f in output["facets"] if f["name"] == "definitions")
        assert def_facet["result_count"] <= 2

    def test_format_output_includes_facet_coverage(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """format_output includes facet_coverage summary."""
        results = [
            SearchResult(
                id="1",
                content="The definition is clear.",
                score=0.9,
            ),
        ]

        output = strategy.format_output(results, {})

        assert "facet_coverage" in output
        assert output["facet_coverage"]["definitions"] is True
        assert output["facet_coverage"]["examples"] is False

    def test_format_output_truncates_content(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """format_output truncates long content."""
        long_content = "Definition: " + "A" * 500
        results = [
            SearchResult(
                id="1",
                content=long_content,
                score=0.9,
            ),
        ]

        output = strategy.format_output(results, {})

        def_facet = next(f for f in output["facets"] if f["name"] == "definitions")
        result_content = def_facet["results"][0]["content"]
        assert len(result_content) <= 310  # 300 + "..."

    def test_format_output_includes_source_info(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """format_output includes source citation."""
        results = [
            SearchResult(
                id="1",
                content="The definition per IEEE is...",
                score=0.9,
                document_title="IEEE 15288",
                section_title="Definitions",
                document_type="standard",
            ),
        ]

        output = strategy.format_output(results, {})

        def_facet = next(f for f in output["facets"] if f["name"] == "definitions")
        source = def_facet["results"][0]["source"]
        assert source["document_title"] == "IEEE 15288"
        assert source["section_title"] == "Definitions"

    def test_format_output_tracks_unassigned(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """format_output counts unassigned results."""
        results = [
            SearchResult(
                id="1",
                content="Random content with no facet keywords.",
                score=0.8,
            ),
        ]

        output = strategy.format_output(results, {})

        assert output["unassigned_count"] >= 1

    def test_facet_descriptions(
        self,
        strategy: ExploreStrategy,
    ) -> None:
        """Each facet has a description."""
        results: list[SearchResult] = []
        output = strategy.format_output(results, {})

        for facet in output["facets"]:
            assert "description" in facet
            assert len(facet["description"]) > 0
```
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pytest tests/unit/test_search/test_explore_strategy.py -v
```
  </verify>
  <done>All explore strategy tests pass</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Strategy imports and works:
```bash
poetry run python -c "
from knowledge_mcp.search.strategies import ExploreStrategy
s = ExploreStrategy()
import asyncio
q = asyncio.run(s.preprocess_query('requirements', {}))
print(f'Query expanded: {len(q.expanded_terms)} terms, {len(q.facets)} facets')
"
```

2. All tests pass:
```bash
poetry run pytest tests/unit/test_search/test_explore_strategy.py -v
```

3. Code quality:
```bash
poetry run ruff check src/knowledge_mcp/search/strategies/explore.py --select E,F,W
```
</verification>

<success_criteria>
- [ ] ExploreStrategy extends SearchStrategy ABC
- [ ] Default 4 facets: definitions, examples, standards, best_practices
- [ ] preprocess_query expands for each active facet
- [ ] format_output organizes results by facet
- [ ] Results per facet are limited by max_results_per_facet
- [ ] Output includes facet_coverage summary
- [ ] All unit tests pass
- [ ] Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-support/02-05-SUMMARY.md`
</output>
