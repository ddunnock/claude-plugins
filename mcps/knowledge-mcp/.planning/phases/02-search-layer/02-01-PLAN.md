---
phase: 02-search-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge_mcp/search/models.py
  - src/knowledge_mcp/search/semantic_search.py
  - src/knowledge_mcp/search/__init__.py
  - tests/unit/test_search/test_semantic_search.py
  - tests/unit/test_search/__init__.py
autonomous: true

must_haves:
  truths:
    - "SemanticSearcher.search(query) returns relevant results from the vector store"
    - "Search results include content, score, and document metadata"
    - "Results can be filtered by document_type and other metadata fields"
    - "Empty query or no results returns empty list (not error)"
  artifacts:
    - path: "src/knowledge_mcp/search/models.py"
      provides: "SearchResult dataclass with flattened citation fields"
      contains: "@dataclass"
    - path: "src/knowledge_mcp/search/semantic_search.py"
      provides: "SemanticSearcher class composing embedder and store"
      exports: ["SemanticSearcher"]
    - path: "src/knowledge_mcp/search/__init__.py"
      provides: "Module exports"
      exports: ["SemanticSearcher", "SearchResult"]
    - path: "tests/unit/test_search/test_semantic_search.py"
      provides: "Unit tests for SemanticSearcher"
      min_lines: 100
  key_links:
    - from: "src/knowledge_mcp/search/semantic_search.py"
      to: "src/knowledge_mcp/embed/base.py"
      via: "embedder.embed() call"
      pattern: "await self._embedder.embed"
    - from: "src/knowledge_mcp/search/semantic_search.py"
      to: "src/knowledge_mcp/store/base.py"
      via: "store.search() call"
      pattern: "self._store.search"
---

<objective>
Implement the semantic search layer that connects the existing embedder and vector store components.

Purpose: Provide a clean `SemanticSearcher.search(query)` interface that MCP tools will use in Phase 3. This is the core search capability for the knowledge base.

Output: Working SemanticSearcher class with SearchResult dataclass and comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-search-layer/02-RESEARCH.md

# Existing components this plan integrates:
@src/knowledge_mcp/embed/base.py
@src/knowledge_mcp/store/base.py
@src/knowledge_mcp/store/qdrant_store.py
@src/knowledge_mcp/search/__init__.py

# Test patterns to follow:
@tests/conftest.py
@tests/unit/test_embed/test_openai_embedder.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SearchResult dataclass and SemanticSearcher class</name>
  <files>
    src/knowledge_mcp/search/models.py
    src/knowledge_mcp/search/semantic_search.py
    src/knowledge_mcp/search/__init__.py
  </files>
  <action>
Create the search layer implementation following patterns from 02-RESEARCH.md:

**1. Create `src/knowledge_mcp/search/models.py`:**
- Define `SearchResult` dataclass with:
  - Core fields: `id`, `content`, `score`, `metadata`
  - Flattened citation fields (FR-3.4): `document_id`, `document_title`, `document_type`, `section_title`, `section_hierarchy`, `chunk_type`, `normative`, `clause_number`, `page_numbers`
- Use `from __future__ import annotations` and `from dataclasses import dataclass, field`
- Add docstrings per CLAUDE.md Google-style requirements

**2. Create `src/knowledge_mcp/search/semantic_search.py`:**
- Define `SemanticSearcher` class that composes embedder and store
- Constructor takes `embedder: BaseEmbedder` and `store: Union[QdrantStore, ChromaDBStore]`
- Implement `async def search(query, n_results=10, filter_dict=None, score_threshold=0.0) -> list[SearchResult]`:
  - Return empty list for empty/whitespace query (Success Criterion #4)
  - Call `await embedder.embed(query)` to get query embedding
  - Call `store.search()` with embedding and parameters
  - Transform raw results to SearchResult objects via `_to_search_result()` helper
  - Log errors but return empty list for graceful degradation
- Use TYPE_CHECKING imports for type hints to avoid circular imports
- Add comprehensive docstrings with examples

**3. Update `src/knowledge_mcp/search/__init__.py`:**
- Import and export `SearchResult` from models
- Import and export `SemanticSearcher` from semantic_search
- Update `__all__` list

Important: Use `.get()` with defaults when extracting metadata fields to handle missing keys safely.
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run python -c "from knowledge_mcp.search import SemanticSearcher, SearchResult; print('Imports OK')"
poetry run pyright src/knowledge_mcp/search/
```
  </verify>
  <done>
- SearchResult dataclass exists with all citation fields
- SemanticSearcher class exists with search() method
- Both are exported from search module
- Pyright passes with zero errors on search module
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive unit tests for SemanticSearcher</name>
  <files>
    tests/unit/test_search/__init__.py
    tests/unit/test_search/test_semantic_search.py
  </files>
  <action>
Create unit tests following the AAA pattern and existing test conventions:

**1. Create `tests/unit/test_search/__init__.py`:**
- Empty file with docstring

**2. Create `tests/unit/test_search/test_semantic_search.py`:**

Test classes to implement:

**TestSemanticSearcherSearch:**
- `test_search_returns_results`: Mock embedder and store, verify SearchResult objects returned with correct fields
- `test_search_calls_embedder_with_query`: Verify embedder.embed() called with query string
- `test_search_calls_store_with_embedding`: Verify store.search() called with embedding and parameters
- `test_search_transforms_metadata_to_search_result`: Verify metadata fields mapped correctly

**TestSemanticSearcherEmptyHandling:**
- `test_empty_query_returns_empty_list`: Empty string returns []
- `test_whitespace_query_returns_empty_list`: "   " returns []
- `test_no_results_returns_empty_list`: Mock store returns [], verify empty list returned

**TestSemanticSearcherFiltering:**
- `test_filter_dict_passed_to_store`: Verify filter_dict forwarded to store.search()
- `test_score_threshold_passed_to_store`: Verify score_threshold forwarded
- `test_n_results_passed_to_store`: Verify n_results forwarded

**TestSemanticSearcherErrorHandling:**
- `test_embedder_error_returns_empty_list`: Embedder raises, returns []
- `test_store_error_returns_empty_list`: Store raises, returns []

Use fixtures:
- `mock_embedder`: AsyncMock returning [0.1] * 1536
- `mock_store`: MagicMock returning sample result dicts
- `searcher`: SemanticSearcher(mock_embedder, mock_store)
- `sample_store_result`: Dict matching store.search() output format

All tests must use `@pytest.mark.asyncio` decorator for async tests.
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pytest tests/unit/test_search/test_semantic_search.py -v
```
  </verify>
  <done>
- Test file exists with at least 12 test cases
- All tests pass
- Tests cover all four success criteria from ROADMAP.md
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify full integration and update test count</name>
  <files>None (verification only)</files>
  <action>
Run full verification to ensure the search layer integrates correctly:

1. Run pyright on entire src directory to ensure no type regressions
2. Run all tests to verify no regressions
3. Verify SearchResult and SemanticSearcher are properly exported

No code changes needed - this task verifies the implementation is complete.
  </action>
  <verify>
```bash
cd /Users/dunnock/projects/claude-plugins/mcps/knowledge-mcp
poetry run pyright src/
poetry run pytest --tb=short
poetry run python -c "
from knowledge_mcp.search import SemanticSearcher, SearchResult
from dataclasses import fields
print('SearchResult fields:', [f.name for f in fields(SearchResult)])
print('SemanticSearcher methods:', [m for m in dir(SemanticSearcher) if not m.startswith('_')])
"
```
  </verify>
  <done>
- Pyright passes with zero errors
- All tests pass (should be ~52+ tests: 40 existing + 12 new)
- SearchResult has expected fields
- SemanticSearcher has search method
  </done>
</task>

</tasks>

<verification>
Phase 2 verification against success criteria:

1. **SemanticSearcher.search(query) returns relevant results from the vector store**
   - Test: `test_search_returns_results` passes
   - Verify: `poetry run pytest tests/unit/test_search/ -k "returns_results"`

2. **Search results include content, score, and document metadata**
   - Test: `test_search_transforms_metadata_to_search_result` passes
   - Verify: SearchResult dataclass has all required fields

3. **Results can be filtered by document_type and other metadata fields**
   - Test: `test_filter_dict_passed_to_store` passes
   - Verify: filter_dict parameter forwarded to store.search()

4. **Empty query or no results returns empty list (not error)**
   - Tests: `test_empty_query_returns_empty_list`, `test_whitespace_query_returns_empty_list`, `test_no_results_returns_empty_list` pass
   - Verify: No exceptions raised for edge cases
</verification>

<success_criteria>
- [ ] `poetry run pyright src/knowledge_mcp/search/` reports zero errors
- [ ] `poetry run pytest tests/unit/test_search/` passes all tests
- [ ] `from knowledge_mcp.search import SemanticSearcher, SearchResult` works
- [ ] SearchResult has fields: id, content, score, metadata, document_id, document_title, section_title
- [ ] SemanticSearcher.search() is async and returns list[SearchResult]
- [ ] Empty query returns empty list without error
- [ ] All 4 phase success criteria verified
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-layer/02-01-SUMMARY.md`
</output>
